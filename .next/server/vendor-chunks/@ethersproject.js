"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ethersproject";
exports.ids = ["vendor-chunks/@ethersproject"];
exports.modules = {

/***/ "(ssr)/./node_modules/@ethersproject/abstract-provider/lib.esm/_version.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@ethersproject/abstract-provider/lib.esm/_version.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"abstract-provider/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXIvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSwwQkFBMEIsQ0FDakQsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1zdGFydGVyLWtpdC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlci9saWIuZXNtL192ZXJzaW9uLmpzPzdjODQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImFic3RyYWN0LXByb3ZpZGVyLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/abstract-provider/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/abstract-provider/lib.esm/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@ethersproject/abstract-provider/lib.esm/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockForkEvent: () => (/* binding */ BlockForkEvent),\n/* harmony export */   ForkEvent: () => (/* binding */ ForkEvent),\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   TransactionForkEvent: () => (/* binding */ TransactionForkEvent),\n/* harmony export */   TransactionOrderForkEvent: () => (/* binding */ TransactionOrderForkEvent)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/abstract-provider/lib.esm/_version.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n;\n;\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\nclass ForkEvent extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.Description {\n    static isForkEvent(value) {\n        return !!(value && value._isForkEvent);\n    }\n}\nclass BlockForkEvent extends ForkEvent {\n    constructor(blockHash, expiry){\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(blockHash, 32)) {\n            logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n        }\n        super({\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: expiry || 0,\n            blockHash: blockHash\n        });\n    }\n}\nclass TransactionForkEvent extends ForkEvent {\n    constructor(hash, expiry){\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(hash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n        super({\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: expiry || 0,\n            hash: hash\n        });\n    }\n}\nclass TransactionOrderForkEvent extends ForkEvent {\n    constructor(beforeHash, afterHash, expiry){\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(beforeHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(afterHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n        super({\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: expiry || 0,\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        });\n    }\n}\n///////////////////////////////\n// Exported Abstracts\nclass Provider {\n    constructor(){\n        logger.checkAbstract(new.target, Provider);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"_isProvider\", true);\n    }\n    getFeeData() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { block, gasPrice } = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)({\n                block: this.getBlock(\"latest\"),\n                gasPrice: this.getGasPrice().catch((error)=>{\n                    // @TODO: Why is this now failing on Calaveras?\n                    //console.log(error);\n                    return null;\n                })\n            });\n            let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;\n            if (block && block.baseFeePerGas) {\n                // We may want to compute this more accurately in the future,\n                // using the formula \"check if the base fee is correct\".\n                // See: https://eips.ethereum.org/EIPS/eip-1559\n                lastBaseFeePerGas = block.baseFeePerGas;\n                maxPriorityFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(\"1500000000\");\n                maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n            }\n            return {\n                lastBaseFeePerGas,\n                maxFeePerGas,\n                maxPriorityFeePerGas,\n                gasPrice\n            };\n        });\n    }\n    // Alias for \"on\"\n    addListener(eventName, listener) {\n        return this.on(eventName, listener);\n    }\n    // Alias for \"off\"\n    removeListener(eventName, listener) {\n        return this.off(eventName, listener);\n    }\n    static isProvider(value) {\n        return !!(value && value._isProvider);\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXIvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQWE7QUFDYixJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDcUQ7QUFDRjtBQUN3QztBQUM1QztBQUNWO0FBQ3JDLE1BQU1jLFNBQVMsSUFBSUYseURBQU1BLENBQUNDLDZDQUFPQTs7O0FBR2pDLHFDQUFxQztBQUNyQywwRUFBMEU7QUFDMUUsSUFBSTtBQUNHLE1BQU1FLGtCQUFrQk4sa0VBQVdBO0lBQ3RDLE9BQU9PLFlBQVl0QixLQUFLLEVBQUU7UUFDdEIsT0FBTyxDQUFDLENBQUVBLENBQUFBLFNBQVNBLE1BQU11QixZQUFZO0lBQ3pDO0FBQ0o7QUFDTyxNQUFNQyx1QkFBdUJIO0lBQ2hDSSxZQUFZQyxTQUFTLEVBQUVDLE1BQU0sQ0FBRTtRQUMzQixJQUFJLENBQUNiLGlFQUFXQSxDQUFDWSxXQUFXLEtBQUs7WUFDN0JOLE9BQU9RLGtCQUFrQixDQUFDLHFCQUFxQixhQUFhRjtRQUNoRTtRQUNBLEtBQUssQ0FBQztZQUNGSCxjQUFjO1lBQ2RNLG1CQUFtQjtZQUNuQkYsUUFBU0EsVUFBVTtZQUNuQkQsV0FBV0E7UUFDZjtJQUNKO0FBQ0o7QUFDTyxNQUFNSSw2QkFBNkJUO0lBQ3RDSSxZQUFZTSxJQUFJLEVBQUVKLE1BQU0sQ0FBRTtRQUN0QixJQUFJLENBQUNiLGlFQUFXQSxDQUFDaUIsTUFBTSxLQUFLO1lBQ3hCWCxPQUFPUSxrQkFBa0IsQ0FBQyw0QkFBNEIsUUFBUUc7UUFDbEU7UUFDQSxLQUFLLENBQUM7WUFDRlIsY0FBYztZQUNkUyx5QkFBeUI7WUFDekJMLFFBQVNBLFVBQVU7WUFDbkJJLE1BQU1BO1FBQ1Y7SUFDSjtBQUNKO0FBQ08sTUFBTUUsa0NBQWtDWjtJQUMzQ0ksWUFBWVMsVUFBVSxFQUFFQyxTQUFTLEVBQUVSLE1BQU0sQ0FBRTtRQUN2QyxJQUFJLENBQUNiLGlFQUFXQSxDQUFDb0IsWUFBWSxLQUFLO1lBQzlCZCxPQUFPUSxrQkFBa0IsQ0FBQyw0QkFBNEIsY0FBY007UUFDeEU7UUFDQSxJQUFJLENBQUNwQixpRUFBV0EsQ0FBQ3FCLFdBQVcsS0FBSztZQUM3QmYsT0FBT1Esa0JBQWtCLENBQUMsNEJBQTRCLGFBQWFPO1FBQ3ZFO1FBQ0EsS0FBSyxDQUFDO1lBQ0ZaLGNBQWM7WUFDZGEsOEJBQThCO1lBQzlCVCxRQUFTQSxVQUFVO1lBQ25CTyxZQUFZQTtZQUNaQyxXQUFXQTtRQUNmO0lBQ0o7QUFDSjtBQUNBLCtCQUErQjtBQUMvQixxQkFBcUI7QUFDZCxNQUFNRTtJQUNUWixhQUFjO1FBQ1ZMLE9BQU9rQixhQUFhLENBQUMsWUFBWUQ7UUFDakNyQix5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsZUFBZTtJQUN4QztJQUNBdUIsYUFBYTtRQUNULE9BQU83QyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLE1BQU0sRUFBRThDLEtBQUssRUFBRUMsUUFBUSxFQUFFLEdBQUcsTUFBTXhCLDRFQUFpQkEsQ0FBQztnQkFDaER1QixPQUFPLElBQUksQ0FBQ0UsUUFBUSxDQUFDO2dCQUNyQkQsVUFBVSxJQUFJLENBQUNFLFdBQVcsR0FBR0MsS0FBSyxDQUFDLENBQUNDO29CQUNoQywrQ0FBK0M7b0JBQy9DLHFCQUFxQjtvQkFDckIsT0FBTztnQkFDWDtZQUNKO1lBQ0EsSUFBSUMsb0JBQW9CLE1BQU1DLGVBQWUsTUFBTUMsdUJBQXVCO1lBQzFFLElBQUlSLFNBQVNBLE1BQU1TLGFBQWEsRUFBRTtnQkFDOUIsNkRBQTZEO2dCQUM3RCx3REFBd0Q7Z0JBQ3hELCtDQUErQztnQkFDL0NILG9CQUFvQk4sTUFBTVMsYUFBYTtnQkFDdkNELHVCQUF1Qm5DLCtEQUFTQSxDQUFDcUMsSUFBSSxDQUFDO2dCQUN0Q0gsZUFBZVAsTUFBTVMsYUFBYSxDQUFDRSxHQUFHLENBQUMsR0FBR0MsR0FBRyxDQUFDSjtZQUNsRDtZQUNBLE9BQU87Z0JBQUVGO2dCQUFtQkM7Z0JBQWNDO2dCQUFzQlA7WUFBUztRQUM3RTtJQUNKO0lBQ0EsaUJBQWlCO0lBQ2pCWSxZQUFZQyxTQUFTLEVBQUVDLFFBQVEsRUFBRTtRQUM3QixPQUFPLElBQUksQ0FBQ0MsRUFBRSxDQUFDRixXQUFXQztJQUM5QjtJQUNBLGtCQUFrQjtJQUNsQkUsZUFBZUgsU0FBUyxFQUFFQyxRQUFRLEVBQUU7UUFDaEMsT0FBTyxJQUFJLENBQUNHLEdBQUcsQ0FBQ0osV0FBV0M7SUFDL0I7SUFDQSxPQUFPSSxXQUFXM0QsS0FBSyxFQUFFO1FBQ3JCLE9BQU8sQ0FBQyxDQUFFQSxDQUFBQSxTQUFTQSxNQUFNNEQsV0FBVztJQUN4QztBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1zdGFydGVyLWtpdC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlci9saWIuZXNtL2luZGV4LmpzPzYxMWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBEZXNjcmlwdGlvbiwgZGVmaW5lUmVhZE9ubHksIHJlc29sdmVQcm9wZXJ0aWVzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbjtcbjtcbi8vZXhwb3J0IHR5cGUgQ2FsbFRyYW5zYWN0aW9uYWJsZSA9IHtcbi8vICAgIGNhbGwodHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uUmVxdWVzdCk6IFByb21pc2U8VHJhbnNhY3Rpb25SZXNwb25zZT47XG4vL307XG5leHBvcnQgY2xhc3MgRm9ya0V2ZW50IGV4dGVuZHMgRGVzY3JpcHRpb24ge1xuICAgIHN0YXRpYyBpc0ZvcmtFdmVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzRm9ya0V2ZW50KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQmxvY2tGb3JrRXZlbnQgZXh0ZW5kcyBGb3JrRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrSGFzaCwgZXhwaXJ5KSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcoYmxvY2tIYXNoLCAzMikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJsb2NrSGFzaFwiLCBcImJsb2NrSGFzaFwiLCBibG9ja0hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIF9pc0ZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIF9pc0Jsb2NrRm9ya0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZXhwaXJ5OiAoZXhwaXJ5IHx8IDApLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBibG9ja0hhc2hcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uRm9ya0V2ZW50IGV4dGVuZHMgRm9ya0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBleHBpcnkpIHtcbiAgICAgICAgaWYgKCFpc0hleFN0cmluZyhoYXNoLCAzMikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIiwgXCJoYXNoXCIsIGhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIF9pc0ZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIF9pc1RyYW5zYWN0aW9uRm9ya0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZXhwaXJ5OiAoZXhwaXJ5IHx8IDApLFxuICAgICAgICAgICAgaGFzaDogaGFzaFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudCBleHRlbmRzIEZvcmtFdmVudCB7XG4gICAgY29uc3RydWN0b3IoYmVmb3JlSGFzaCwgYWZ0ZXJIYXNoLCBleHBpcnkpIHtcbiAgICAgICAgaWYgKCFpc0hleFN0cmluZyhiZWZvcmVIYXNoLCAzMikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIiwgXCJiZWZvcmVIYXNoXCIsIGJlZm9yZUhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcoYWZ0ZXJIYXNoLCAzMikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIiwgXCJhZnRlckhhc2hcIiwgYWZ0ZXJIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBfaXNGb3JrRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBfaXNUcmFuc2FjdGlvbk9yZGVyRm9ya0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZXhwaXJ5OiAoZXhwaXJ5IHx8IDApLFxuICAgICAgICAgICAgYmVmb3JlSGFzaDogYmVmb3JlSGFzaCxcbiAgICAgICAgICAgIGFmdGVySGFzaDogYWZ0ZXJIYXNoXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEV4cG9ydGVkIEFic3RyYWN0c1xuZXhwb3J0IGNsYXNzIFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrQWJzdHJhY3QobmV3LnRhcmdldCwgUHJvdmlkZXIpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9pc1Byb3ZpZGVyXCIsIHRydWUpO1xuICAgIH1cbiAgICBnZXRGZWVEYXRhKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBibG9jaywgZ2FzUHJpY2UgfSA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBibG9jazogdGhpcy5nZXRCbG9jayhcImxhdGVzdFwiKSxcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogdGhpcy5nZXRHYXNQcmljZSgpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogV2h5IGlzIHRoaXMgbm93IGZhaWxpbmcgb24gQ2FsYXZlcmFzP1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGxhc3RCYXNlRmVlUGVyR2FzID0gbnVsbCwgbWF4RmVlUGVyR2FzID0gbnVsbCwgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGJsb2NrICYmIGJsb2NrLmJhc2VGZWVQZXJHYXMpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBtYXkgd2FudCB0byBjb21wdXRlIHRoaXMgbW9yZSBhY2N1cmF0ZWx5IGluIHRoZSBmdXR1cmUsXG4gICAgICAgICAgICAgICAgLy8gdXNpbmcgdGhlIGZvcm11bGEgXCJjaGVjayBpZiB0aGUgYmFzZSBmZWUgaXMgY29ycmVjdFwiLlxuICAgICAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xNTU5XG4gICAgICAgICAgICAgICAgbGFzdEJhc2VGZWVQZXJHYXMgPSBibG9jay5iYXNlRmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID0gQmlnTnVtYmVyLmZyb20oXCIxNTAwMDAwMDAwXCIpO1xuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhcyA9IGJsb2NrLmJhc2VGZWVQZXJHYXMubXVsKDIpLmFkZChtYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBsYXN0QmFzZUZlZVBlckdhcywgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcywgZ2FzUHJpY2UgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFsaWFzIGZvciBcIm9uXCJcbiAgICBhZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvLyBBbGlhcyBmb3IgXCJvZmZcIlxuICAgIHJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNQcm92aWRlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzUHJvdmlkZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJCaWdOdW1iZXIiLCJpc0hleFN0cmluZyIsIkRlc2NyaXB0aW9uIiwiZGVmaW5lUmVhZE9ubHkiLCJyZXNvbHZlUHJvcGVydGllcyIsIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJGb3JrRXZlbnQiLCJpc0ZvcmtFdmVudCIsIl9pc0ZvcmtFdmVudCIsIkJsb2NrRm9ya0V2ZW50IiwiY29uc3RydWN0b3IiLCJibG9ja0hhc2giLCJleHBpcnkiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJfaXNCbG9ja0ZvcmtFdmVudCIsIlRyYW5zYWN0aW9uRm9ya0V2ZW50IiwiaGFzaCIsIl9pc1RyYW5zYWN0aW9uRm9ya0V2ZW50IiwiVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudCIsImJlZm9yZUhhc2giLCJhZnRlckhhc2giLCJfaXNUcmFuc2FjdGlvbk9yZGVyRm9ya0V2ZW50IiwiUHJvdmlkZXIiLCJjaGVja0Fic3RyYWN0IiwiZ2V0RmVlRGF0YSIsImJsb2NrIiwiZ2FzUHJpY2UiLCJnZXRCbG9jayIsImdldEdhc1ByaWNlIiwiY2F0Y2giLCJlcnJvciIsImxhc3RCYXNlRmVlUGVyR2FzIiwibWF4RmVlUGVyR2FzIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJiYXNlRmVlUGVyR2FzIiwiZnJvbSIsIm11bCIsImFkZCIsImFkZExpc3RlbmVyIiwiZXZlbnROYW1lIiwibGlzdGVuZXIiLCJvbiIsInJlbW92ZUxpc3RlbmVyIiwib2ZmIiwiaXNQcm92aWRlciIsIl9pc1Byb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/abstract-provider/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/abstract-signer/lib.esm/_version.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@ethersproject/abstract-signer/lib.esm/_version.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"abstract-signer/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJzdHJhY3Qtc2lnbmVyL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFVBQVUsd0JBQXdCLENBQy9DLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJzdHJhY3Qtc2lnbmVyL2xpYi5lc20vX3ZlcnNpb24uanM/MTgwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiYWJzdHJhY3Qtc2lnbmVyLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/abstract-signer/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/abstract-signer/lib.esm/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ethersproject/abstract-signer/lib.esm/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Signer: () => (/* binding */ Signer),\n/* harmony export */   VoidSigner: () => (/* binding */ VoidSigner)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/abstract-signer/lib.esm/_version.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nconst allowedTransactionKeys = [\n    \"accessList\",\n    \"ccipReadEnabled\",\n    \"chainId\",\n    \"customData\",\n    \"data\",\n    \"from\",\n    \"gasLimit\",\n    \"gasPrice\",\n    \"maxFeePerGas\",\n    \"maxPriorityFeePerGas\",\n    \"nonce\",\n    \"to\",\n    \"type\",\n    \"value\"\n];\nconst forwardErrors = [\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INSUFFICIENT_FUNDS,\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NONCE_EXPIRED,\n    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.REPLACEMENT_UNDERPRICED\n];\n;\n;\nclass Signer {\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor(){\n        logger.checkAbstract(new.target, Signer);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"_isSigner\", true);\n    }\n    ///////////////////\n    // Sub-classes MAY override these\n    getBalance(blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._checkProvider(\"getBalance\");\n            return yield this.provider.getBalance(this.getAddress(), blockTag);\n        });\n    }\n    getTransactionCount(blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._checkProvider(\"getTransactionCount\");\n            return yield this.provider.getTransactionCount(this.getAddress(), blockTag);\n        });\n    }\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._checkProvider(\"estimateGas\");\n            const tx = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(this.checkTransaction(transaction));\n            return yield this.provider.estimateGas(tx);\n        });\n    }\n    // Populates \"from\" if unspecified, and calls with the transaction\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._checkProvider(\"call\");\n            const tx = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(this.checkTransaction(transaction));\n            return yield this.provider.call(tx, blockTag);\n        });\n    }\n    // Populates all fields in a transaction, signs it and sends it to the network\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._checkProvider(\"sendTransaction\");\n            const tx = yield this.populateTransaction(transaction);\n            const signedTx = yield this.signTransaction(tx);\n            return yield this.provider.sendTransaction(signedTx);\n        });\n    }\n    getChainId() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._checkProvider(\"getChainId\");\n            const network = yield this.provider.getNetwork();\n            return network.chainId;\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._checkProvider(\"getGasPrice\");\n            return yield this.provider.getGasPrice();\n        });\n    }\n    getFeeData() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._checkProvider(\"getFeeData\");\n            return yield this.provider.getFeeData();\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this._checkProvider(\"resolveName\");\n            return yield this.provider.resolveName(name);\n        });\n    }\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction) {\n        for(const key in transaction){\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n        const tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.shallowCopy)(transaction);\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n        } else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result)=>{\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n        return tx;\n    }\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    populateTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const tx = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(this.checkTransaction(transaction));\n            if (tx.to != null) {\n                tx.to = Promise.resolve(tx.to).then((to)=>__awaiter(this, void 0, void 0, function*() {\n                        if (to == null) {\n                            return null;\n                        }\n                        const address = yield this.resolveName(to);\n                        if (address == null) {\n                            logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                        }\n                        return address;\n                    }));\n                // Prevent this error from causing an UnhandledPromiseException\n                tx.to.catch((error)=>{});\n            }\n            // Do not allow mixing pre-eip-1559 and eip-1559 properties\n            const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;\n            if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n                logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n            } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n                logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n            }\n            if ((tx.type === 2 || tx.type == null) && tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null) {\n                // Fully-formed EIP-1559 transaction (skip getFeeData)\n                tx.type = 2;\n            } else if (tx.type === 0 || tx.type === 1) {\n                // Explicit Legacy or EIP-2930 transaction\n                // Populate missing gasPrice\n                if (tx.gasPrice == null) {\n                    tx.gasPrice = this.getGasPrice();\n                }\n            } else {\n                // We need to get fee data to determine things\n                const feeData = yield this.getFeeData();\n                if (tx.type == null) {\n                    // We need to auto-detect the intended type of this transaction...\n                    if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                        // The network supports EIP-1559!\n                        // Upgrade transaction from null to eip-1559\n                        tx.type = 2;\n                        if (tx.gasPrice != null) {\n                            // Using legacy gasPrice property on an eip-1559 network,\n                            // so use gasPrice as both fee properties\n                            const gasPrice = tx.gasPrice;\n                            delete tx.gasPrice;\n                            tx.maxFeePerGas = gasPrice;\n                            tx.maxPriorityFeePerGas = gasPrice;\n                        } else {\n                            // Populate missing fee data\n                            if (tx.maxFeePerGas == null) {\n                                tx.maxFeePerGas = feeData.maxFeePerGas;\n                            }\n                            if (tx.maxPriorityFeePerGas == null) {\n                                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                            }\n                        }\n                    } else if (feeData.gasPrice != null) {\n                        // Network doesn't support EIP-1559...\n                        // ...but they are trying to use EIP-1559 properties\n                        if (hasEip1559) {\n                            logger.throwError(\"network does not support EIP-1559\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                                operation: \"populateTransaction\"\n                            });\n                        }\n                        // Populate missing fee data\n                        if (tx.gasPrice == null) {\n                            tx.gasPrice = feeData.gasPrice;\n                        }\n                        // Explicitly set untyped transaction to legacy\n                        tx.type = 0;\n                    } else {\n                        // getFeeData has failed us.\n                        logger.throwError(\"failed to get consistent fee data\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"signer.getFeeData\"\n                        });\n                    }\n                } else if (tx.type === 2) {\n                    // Explicitly using EIP-1559\n                    // Populate missing fee data\n                    if (tx.maxFeePerGas == null) {\n                        tx.maxFeePerGas = feeData.maxFeePerGas;\n                    }\n                    if (tx.maxPriorityFeePerGas == null) {\n                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                    }\n                }\n            }\n            if (tx.nonce == null) {\n                tx.nonce = this.getTransactionCount(\"pending\");\n            }\n            if (tx.gasLimit == null) {\n                tx.gasLimit = this.estimateGas(tx).catch((error)=>{\n                    if (forwardErrors.indexOf(error.code) >= 0) {\n                        throw error;\n                    }\n                    return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                        error: error,\n                        tx: tx\n                    });\n                });\n            }\n            if (tx.chainId == null) {\n                tx.chainId = this.getChainId();\n            } else {\n                tx.chainId = Promise.all([\n                    Promise.resolve(tx.chainId),\n                    this.getChainId()\n                ]).then((results)=>{\n                    if (results[1] !== 0 && results[0] !== results[1]) {\n                        logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                    }\n                    return results[0];\n                });\n            }\n            return yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(tx);\n        });\n    }\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n    _checkProvider(operation) {\n        if (!this.provider) {\n            logger.throwError(\"missing provider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: operation || \"_checkProvider\"\n            });\n        }\n    }\n    static isSigner(value) {\n        return !!(value && value._isSigner);\n    }\n}\nclass VoidSigner extends Signer {\n    constructor(address, provider){\n        super();\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"address\", address);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"provider\", provider || null);\n    }\n    getAddress() {\n        return Promise.resolve(this.address);\n    }\n    _fail(message, operation) {\n        return Promise.resolve().then(()=>{\n            logger.throwError(message, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: operation\n            });\n        });\n    }\n    signMessage(message) {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n    signTransaction(transaction) {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n    _signTypedData(domain, types, value) {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n    connect(provider) {\n        return new VoidSigner(this.address, provider);\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJzdHJhY3Qtc2lnbmVyL2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBYTtBQUNiLElBQUlBLFlBQVksU0FBSyxJQUFJLFNBQUksQ0FBQ0EsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUMyRjtBQUM1QztBQUNWO0FBQ3JDLE1BQU1ZLFNBQVMsSUFBSUYseURBQU1BLENBQUNDLDZDQUFPQTtBQUNqQyxNQUFNRSx5QkFBeUI7SUFDM0I7SUFBYztJQUFtQjtJQUFXO0lBQWM7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LFdBQVlBLGFBQWE7WUFDN0I7UUFDSjtJQUNKO0lBQ0EsT0FBT00sU0FBUzNFLEtBQUssRUFBRTtRQUNuQixPQUFPLENBQUMsQ0FBRUEsQ0FBQUEsU0FBU0EsTUFBTTRFLFNBQVM7SUFDdEM7QUFDSjtBQUNPLE1BQU1DLG1CQUFtQnBEO0lBQzVCQyxZQUFZZ0MsT0FBTyxFQUFFM0IsUUFBUSxDQUFFO1FBQzNCLEtBQUs7UUFDTGxCLHlFQUFjQSxDQUFDLElBQUksRUFBRSxXQUFXNkM7UUFDaEM3Qyx5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsWUFBWWtCLFlBQVk7SUFDakQ7SUFDQUMsYUFBYTtRQUNULE9BQU85QixRQUFRRCxPQUFPLENBQUMsSUFBSSxDQUFDeUQsT0FBTztJQUN2QztJQUNBb0IsTUFBTUMsT0FBTyxFQUFFVixTQUFTLEVBQUU7UUFDdEIsT0FBT25FLFFBQVFELE9BQU8sR0FBR1UsSUFBSSxDQUFDO1lBQzFCTyxPQUFPaUQsVUFBVSxDQUFDWSxTQUFTL0QseURBQU1BLENBQUNLLE1BQU0sQ0FBQytDLHFCQUFxQixFQUFFO2dCQUFFQyxXQUFXQTtZQUFVO1FBQzNGO0lBQ0o7SUFDQVcsWUFBWUQsT0FBTyxFQUFFO1FBQ2pCLE9BQU8sSUFBSSxDQUFDRCxLQUFLLENBQUMsbUNBQW1DO0lBQ3pEO0lBQ0FwQyxnQkFBZ0JQLFdBQVcsRUFBRTtRQUN6QixPQUFPLElBQUksQ0FBQzJDLEtBQUssQ0FBQyx1Q0FBdUM7SUFDN0Q7SUFDQUcsZUFBZUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVuRixLQUFLLEVBQUU7UUFDakMsT0FBTyxJQUFJLENBQUM4RSxLQUFLLENBQUMscUNBQXFDO0lBQzNEO0lBQ0FNLFFBQVFyRCxRQUFRLEVBQUU7UUFDZCxPQUFPLElBQUk4QyxXQUFXLElBQUksQ0FBQ25CLE9BQU8sRUFBRTNCO0lBQ3hDO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXNpZ25lci9saWIuZXNtL2luZGV4LmpzPzViNTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5LCByZXNvbHZlUHJvcGVydGllcywgc2hhbGxvd0NvcHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuY29uc3QgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyA9IFtcbiAgICBcImFjY2Vzc0xpc3RcIiwgXCJjY2lwUmVhZEVuYWJsZWRcIiwgXCJjaGFpbklkXCIsIFwiY3VzdG9tRGF0YVwiLCBcImRhdGFcIiwgXCJmcm9tXCIsIFwiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcIm1heEZlZVBlckdhc1wiLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwibm9uY2VcIiwgXCJ0b1wiLCBcInR5cGVcIiwgXCJ2YWx1ZVwiXG5dO1xuY29uc3QgZm9yd2FyZEVycm9ycyA9IFtcbiAgICBMb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUyxcbiAgICBMb2dnZXIuZXJyb3JzLk5PTkNFX0VYUElSRUQsXG4gICAgTG9nZ2VyLmVycm9ycy5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCxcbl07XG47XG47XG5leHBvcnQgY2xhc3MgU2lnbmVyIHtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gU3ViLWNsYXNzZXMgTVVTVCBjYWxsIHN1cGVyXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja0Fic3RyYWN0KG5ldy50YXJnZXQsIFNpZ25lcik7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2lzU2lnbmVyXCIsIHRydWUpO1xuICAgIH1cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gU3ViLWNsYXNzZXMgTUFZIG92ZXJyaWRlIHRoZXNlXG4gICAgZ2V0QmFsYW5jZShibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImdldEJhbGFuY2VcIik7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5nZXRCYWxhbmNlKHRoaXMuZ2V0QWRkcmVzcygpLCBibG9ja1RhZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRUcmFuc2FjdGlvbkNvdW50KGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5nZXRBZGRyZXNzKCksIGJsb2NrVGFnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFBvcHVsYXRlcyBcImZyb21cIiBpZiB1bnNwZWNpZmllZCwgYW5kIGVzdGltYXRlcyB0aGUgZ2FzIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICBlc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImVzdGltYXRlR2FzXCIpO1xuICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh0aGlzLmNoZWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKHR4KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFBvcHVsYXRlcyBcImZyb21cIiBpZiB1bnNwZWNpZmllZCwgYW5kIGNhbGxzIHdpdGggdGhlIHRyYW5zYWN0aW9uXG4gICAgY2FsbCh0cmFuc2FjdGlvbiwgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJjYWxsXCIpO1xuICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh0aGlzLmNoZWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwodHgsIGJsb2NrVGFnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFBvcHVsYXRlcyBhbGwgZmllbGRzIGluIGEgdHJhbnNhY3Rpb24sIHNpZ25zIGl0IGFuZCBzZW5kcyBpdCB0byB0aGUgbmV0d29ya1xuICAgIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcInNlbmRUcmFuc2FjdGlvblwiKTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZFR4ID0geWllbGQgdGhpcy5zaWduVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFR4KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENoYWluSWQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0Q2hhaW5JZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXR3b3JrLmNoYWluSWQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRHYXNQcmljZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRHYXNQcmljZVwiKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLmdldEdhc1ByaWNlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRGZWVEYXRhKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImdldEZlZURhdGFcIik7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwicmVzb2x2ZU5hbWVcIik7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIENoZWNrcyBhIHRyYW5zYWN0aW9uIGRvZXMgbm90IGNvbnRhaW4gaW52YWxpZCBrZXlzIGFuZCBpZlxuICAgIC8vIG5vIFwiZnJvbVwiIGlzIHByb3ZpZGVkLCBwb3B1bGF0ZXMgaXQuXG4gICAgLy8gLSBkb2VzIE5PVCByZXF1aXJlIGEgcHJvdmlkZXJcbiAgICAvLyAtIGFkZHMgXCJmcm9tXCIgaXMgbm90IHByZXNlbnRcbiAgICAvLyAtIHJldHVybnMgYSBDT1BZIChzYWZlIHRvIG11dGF0ZSB0aGUgcmVzdWx0KVxuICAgIC8vIEJ5IGRlZmF1bHQgY2FsbGVkIGZyb206IChvdmVycmlkaW5nIHRoZXNlIHByZXZlbnRzIGl0KVxuICAgIC8vICAgLSBjYWxsXG4gICAgLy8gICAtIGVzdGltYXRlR2FzXG4gICAgLy8gICAtIHBvcHVsYXRlVHJhbnNhY3Rpb24gKGFuZCB0aGVyZWZvciBzZW5kVHJhbnNhY3Rpb24pXG4gICAgY2hlY2tUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgaWYgKGFsbG93ZWRUcmFuc2FjdGlvbktleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGtleTogXCIgKyBrZXksIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR4ID0gc2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO1xuICAgICAgICBpZiAodHguZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gdGhpcy5nZXRBZGRyZXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgYW55IHByb3ZpZGVkIGFkZHJlc3MgbWF0Y2hlcyB0aGlzIHNpZ25lclxuICAgICAgICAgICAgdHguZnJvbSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUodHguZnJvbSksXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRBZGRyZXNzKClcbiAgICAgICAgICAgIF0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbMF0udG9Mb3dlckNhc2UoKSAhPT0gcmVzdWx0WzFdLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLy8gUG9wdWxhdGVzIEFMTCBrZXlzIGZvciBhIHRyYW5zYWN0aW9uIGFuZCBjaGVja3MgdGhhdCBcImZyb21cIiBtYXRjaGVzXG4gICAgLy8gdGhpcyBTaWduZXIuIFNob3VsZCBiZSB1c2VkIGJ5IHNlbmRUcmFuc2FjdGlvbiBidXQgTk9UIGJ5IHNpZ25UcmFuc2FjdGlvbi5cbiAgICAvLyBCeSBkZWZhdWx0IGNhbGxlZCBmcm9tOiAob3ZlcnJpZGluZyB0aGVzZSBwcmV2ZW50cyBpdClcbiAgICAvLyAgIC0gc2VuZFRyYW5zYWN0aW9uXG4gICAgLy9cbiAgICAvLyBOb3RlczpcbiAgICAvLyAgLSBXZSBhbGxvdyBnYXNQcmljZSBmb3IgRUlQLTE1NTkgYXMgbG9uZyBhcyBpdCBtYXRjaGVzIG1heEZlZVBlckdhc1xuICAgIHBvcHVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXModGhpcy5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSk7XG4gICAgICAgICAgICBpZiAodHgudG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHR4LnRvID0gUHJvbWlzZS5yZXNvbHZlKHR4LnRvKS50aGVuKCh0bykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMucmVzb2x2ZU5hbWUodG8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicHJvdmlkZWQgRU5TIG5hbWUgcmVzb2x2ZXMgdG8gbnVsbFwiLCBcInR4LnRvXCIsIHRvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCB0aGlzIGVycm9yIGZyb20gY2F1c2luZyBhbiBVbmhhbmRsZWRQcm9taXNlRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgdHgudG8uY2F0Y2goKGVycm9yKSA9PiB7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IG1peGluZyBwcmUtZWlwLTE1NTkgYW5kIGVpcC0xNTU5IHByb3BlcnRpZXNcbiAgICAgICAgICAgIGNvbnN0IGhhc0VpcDE1NTkgPSAodHgubWF4RmVlUGVyR2FzICE9IG51bGwgfHwgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCk7XG4gICAgICAgICAgICBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCAmJiAodHgudHlwZSA9PT0gMiB8fCBoYXNFaXAxNTU5KSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJlaXAtMTU1OSB0cmFuc2FjdGlvbiBkbyBub3Qgc3VwcG9ydCBnYXNQcmljZVwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCh0eC50eXBlID09PSAwIHx8IHR4LnR5cGUgPT09IDEpICYmIGhhc0VpcDE1NTkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicHJlLWVpcC0xNTU5IHRyYW5zYWN0aW9uIGRvIG5vdCBzdXBwb3J0IG1heEZlZVBlckdhcy9tYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodHgudHlwZSA9PT0gMiB8fCB0eC50eXBlID09IG51bGwpICYmICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgIC8vIEZ1bGx5LWZvcm1lZCBFSVAtMTU1OSB0cmFuc2FjdGlvbiAoc2tpcCBnZXRGZWVEYXRhKVxuICAgICAgICAgICAgICAgIHR4LnR5cGUgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHgudHlwZSA9PT0gMCB8fCB0eC50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhwbGljaXQgTGVnYWN5IG9yIEVJUC0yOTMwIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBnYXNQcmljZVxuICAgICAgICAgICAgICAgIGlmICh0eC5nYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHR4Lmdhc1ByaWNlID0gdGhpcy5nZXRHYXNQcmljZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcbiAgICAgICAgICAgICAgICBjb25zdCBmZWVEYXRhID0geWllbGQgdGhpcy5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR4LnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGF1dG8tZGV0ZWN0IHRoZSBpbnRlbmRlZCB0eXBlIG9mIHRoaXMgdHJhbnNhY3Rpb24uLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlZURhdGEubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbmV0d29yayBzdXBwb3J0cyBFSVAtMTU1OSFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZ3JhZGUgdHJhbnNhY3Rpb24gZnJvbSBudWxsIHRvIGVpcC0xNTU5XG4gICAgICAgICAgICAgICAgICAgICAgICB0eC50eXBlID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNpbmcgbGVnYWN5IGdhc1ByaWNlIHByb3BlcnR5IG9uIGFuIGVpcC0xNTU5IG5ldHdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdXNlIGdhc1ByaWNlIGFzIGJvdGggZmVlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0eC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5tYXhGZWVQZXJHYXMgPSBnYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5tYXhGZWVQZXJHYXMgPSBmZWVEYXRhLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmZWVEYXRhLmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBzdXBwb3J0IEVJUC0xNTU5Li4uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5idXQgdGhleSBhcmUgdHJ5aW5nIHRvIHVzZSBFSVAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzRWlwMTU1OSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IEVJUC0xNTU5XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJwb3B1bGF0ZVRyYW5zYWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5nYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguZ2FzUHJpY2UgPSBmZWVEYXRhLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBzZXQgdW50eXBlZCB0cmFuc2FjdGlvbiB0byBsZWdhY3lcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4LnR5cGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0RmVlRGF0YSBoYXMgZmFpbGVkIHVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJmYWlsZWQgdG8gZ2V0IGNvbnNpc3RlbnQgZmVlIGRhdGFcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2lnbmVyLmdldEZlZURhdGFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHgudHlwZSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHVzaW5nIEVJUC0xNTU5XG4gICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eC5tYXhGZWVQZXJHYXMgPSBmZWVEYXRhLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR4Lm5vbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0eC5ub25jZSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25Db3VudChcInBlbmRpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHguZ2FzTGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHR4Lmdhc0xpbWl0ID0gdGhpcy5lc3RpbWF0ZUdhcyh0eCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkRXJyb3JzLmluZGV4T2YoZXJyb3IuY29kZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLCBMb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlULCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eDogdHhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHguY2hhaW5JZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHguY2hhaW5JZCA9IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHguY2hhaW5JZCA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHR4LmNoYWluSWQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENoYWluSWQoKVxuICAgICAgICAgICAgICAgIF0pLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdHNbMV0gIT09IDAgJiYgcmVzdWx0c1swXSAhPT0gcmVzdWx0c1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNoYWluSWQgYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0c1swXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh0eCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gU3ViLWNsYXNzZXMgU0hPVUxEIGxlYXZlIHRoZXNlIGFsb25lXG4gICAgX2NoZWNrUHJvdmlkZXIob3BlcmF0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIHByb3ZpZGVyXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiAob3BlcmF0aW9uIHx8IFwiX2NoZWNrUHJvdmlkZXJcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBpc1NpZ25lcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzU2lnbmVyKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVm9pZFNpZ25lciBleHRlbmRzIFNpZ25lciB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyIHx8IG51bGwpO1xuICAgIH1cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWRkcmVzcyk7XG4gICAgfVxuICAgIF9mYWlsKG1lc3NhZ2UsIG9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBvcGVyYXRpb246IG9wZXJhdGlvbiB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoXCJWb2lkU2lnbmVyIGNhbm5vdCBzaWduIG1lc3NhZ2VzXCIsIFwic2lnbk1lc3NhZ2VcIik7XG4gICAgfVxuICAgIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFpbChcIlZvaWRTaWduZXIgY2Fubm90IHNpZ24gdHJhbnNhY3Rpb25zXCIsIFwic2lnblRyYW5zYWN0aW9uXCIpO1xuICAgIH1cbiAgICBfc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFpbChcIlZvaWRTaWduZXIgY2Fubm90IHNpZ24gdHlwZWQgZGF0YVwiLCBcInNpZ25UeXBlZERhdGFcIik7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWb2lkU2lnbmVyKHRoaXMuYWRkcmVzcywgcHJvdmlkZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJkZWZpbmVSZWFkT25seSIsInJlc29sdmVQcm9wZXJ0aWVzIiwic2hhbGxvd0NvcHkiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyIsImZvcndhcmRFcnJvcnMiLCJlcnJvcnMiLCJJTlNVRkZJQ0lFTlRfRlVORFMiLCJOT05DRV9FWFBJUkVEIiwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQiLCJTaWduZXIiLCJjb25zdHJ1Y3RvciIsImNoZWNrQWJzdHJhY3QiLCJnZXRCYWxhbmNlIiwiYmxvY2tUYWciLCJfY2hlY2tQcm92aWRlciIsInByb3ZpZGVyIiwiZ2V0QWRkcmVzcyIsImdldFRyYW5zYWN0aW9uQ291bnQiLCJlc3RpbWF0ZUdhcyIsInRyYW5zYWN0aW9uIiwidHgiLCJjaGVja1RyYW5zYWN0aW9uIiwiY2FsbCIsInNlbmRUcmFuc2FjdGlvbiIsInBvcHVsYXRlVHJhbnNhY3Rpb24iLCJzaWduZWRUeCIsInNpZ25UcmFuc2FjdGlvbiIsImdldENoYWluSWQiLCJuZXR3b3JrIiwiZ2V0TmV0d29yayIsImNoYWluSWQiLCJnZXRHYXNQcmljZSIsImdldEZlZURhdGEiLCJyZXNvbHZlTmFtZSIsIm5hbWUiLCJrZXkiLCJpbmRleE9mIiwidGhyb3dBcmd1bWVudEVycm9yIiwiZnJvbSIsImFsbCIsInRvTG93ZXJDYXNlIiwidG8iLCJhZGRyZXNzIiwiY2F0Y2giLCJlcnJvciIsImhhc0VpcDE1NTkiLCJtYXhGZWVQZXJHYXMiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsImdhc1ByaWNlIiwidHlwZSIsImZlZURhdGEiLCJ0aHJvd0Vycm9yIiwiVU5TVVBQT1JURURfT1BFUkFUSU9OIiwib3BlcmF0aW9uIiwibm9uY2UiLCJnYXNMaW1pdCIsImNvZGUiLCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVCIsInJlc3VsdHMiLCJpc1NpZ25lciIsIl9pc1NpZ25lciIsIlZvaWRTaWduZXIiLCJfZmFpbCIsIm1lc3NhZ2UiLCJzaWduTWVzc2FnZSIsIl9zaWduVHlwZWREYXRhIiwiZG9tYWluIiwidHlwZXMiLCJjb25uZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/abstract-signer/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/address/lib.esm/_version.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersproject/address/lib.esm/_version.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"address/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWRkcmVzcy9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSxVQUFVLGdCQUFnQixDQUN2QyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FkZHJlc3MvbGliLmVzbS9fdmVyc2lvbi5qcz8wNmRjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJhZGRyZXNzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/address/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/address/lib.esm/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/address/lib.esm/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAddress: () => (/* binding */ getAddress),\n/* harmony export */   getContractAddress: () => (/* binding */ getContractAddress),\n/* harmony export */   getCreate2Address: () => (/* binding */ getCreate2Address),\n/* harmony export */   getIcapAddress: () => (/* binding */ getIcapAddress),\n/* harmony export */   isAddress: () => (/* binding */ isAddress)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/rlp */ \"(ssr)/./node_modules/@ethersproject/rlp/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/address/lib.esm/_version.js\");\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nfunction getChecksumAddress(address) {\n    if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isHexString)(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for(let i = 0; i < 40; i++){\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__.keccak256)(expanded));\n    for(let i = 0; i < 40; i += 2){\n        if (hashed[i >> 1] >> 4 >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER = 0x1fffffffffffff;\nfunction log10(x) {\n    if (Math.log10) {\n        return Math.log10(x);\n    }\n    return Math.log(x) / Math.LN10;\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor(let i = 0; i < 10; i++){\n    ibanLookup[String(i)] = String(i);\n}\nfor(let i = 0; i < 26; i++){\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c)=>{\n        return ibanLookup[c];\n    }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while(expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - parseInt(expanded, 10) % 97);\n    while(checksum.length < 2){\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nfunction getAddress(address) {\n    let result = null;\n    if (typeof address !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") {\n            address = \"0x\" + address;\n        }\n        result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n        result = (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__._base36To16)(address.substring(4));\n        while(result.length < 40){\n            result = \"0\" + result;\n        }\n        result = getChecksumAddress(\"0x\" + result);\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    return result;\n}\nfunction isAddress(address) {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) {}\n    return false;\n}\nfunction getIcapAddress(address) {\n    let base36 = (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__._base16To36)(getAddress(address).substring(2)).toUpperCase();\n    while(base36.length < 30){\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nfunction getContractAddress(transaction) {\n    let from = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n    const nonce = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.stripZeros)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.nonce).toHexString()));\n    return getAddress((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataSlice)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_ethersproject_rlp__WEBPACK_IMPORTED_MODULE_5__.encode)([\n        from,\n        nonce\n    ])), 12));\n}\nfunction getCreate2Address(from, salt, initCodeHash) {\n    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataLength)(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataLength)(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataSlice)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.concat)([\n        \"0xff\",\n        getAddress(from),\n        salt,\n        initCodeHash\n    ])), 12));\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWRkcmVzcy9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWE7QUFDaUc7QUFDL0I7QUFDMUI7QUFDVDtBQUNHO0FBQ1Y7QUFDckMsTUFBTWEsU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BO0FBQ2pDLFNBQVNFLG1CQUFtQkMsT0FBTztJQUMvQixJQUFJLENBQUNYLGlFQUFXQSxDQUFDVyxTQUFTLEtBQUs7UUFDM0JGLE9BQU9HLGtCQUFrQixDQUFDLG1CQUFtQixXQUFXRDtJQUM1RDtJQUNBQSxVQUFVQSxRQUFRRSxXQUFXO0lBQzdCLE1BQU1DLFFBQVFILFFBQVFJLFNBQVMsQ0FBQyxHQUFHQyxLQUFLLENBQUM7SUFDekMsTUFBTUMsV0FBVyxJQUFJQyxXQUFXO0lBQ2hDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7UUFDekJGLFFBQVEsQ0FBQ0UsRUFBRSxHQUFHTCxLQUFLLENBQUNLLEVBQUUsQ0FBQ0MsVUFBVSxDQUFDO0lBQ3RDO0lBQ0EsTUFBTUMsU0FBU3pCLDhEQUFRQSxDQUFDUyxtRUFBU0EsQ0FBQ1k7SUFDbEMsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUksSUFBSUEsS0FBSyxFQUFHO1FBQzVCLElBQUksTUFBTyxDQUFDQSxLQUFLLEVBQUUsSUFBSSxLQUFNLEdBQUc7WUFDNUJMLEtBQUssQ0FBQ0ssRUFBRSxHQUFHTCxLQUFLLENBQUNLLEVBQUUsQ0FBQ0csV0FBVztRQUNuQztRQUNBLElBQUksQ0FBQ0QsTUFBTSxDQUFDRixLQUFLLEVBQUUsR0FBRyxJQUFHLEtBQU0sR0FBRztZQUM5QkwsS0FBSyxDQUFDSyxJQUFJLEVBQUUsR0FBR0wsS0FBSyxDQUFDSyxJQUFJLEVBQUUsQ0FBQ0csV0FBVztRQUMzQztJQUNKO0lBQ0EsT0FBTyxPQUFPUixNQUFNUyxJQUFJLENBQUM7QUFDN0I7QUFDQSxnRkFBZ0Y7QUFD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QUFJcUMsU0FBUzdDLHFFQUFXQSxDQUFDdUMsV0FBVy9CLFNBQVNJLFNBQVMsQ0FBQyxJQUFJTyxXQUFXO0lBQ3RFLE1BQU8wQixPQUFPVixNQUFNLEdBQUcsR0FBSTtRQUN2QlUsU0FBUyxNQUFNQTtJQUNuQjtJQUNBLE9BQU8sT0FBT2IsYUFBYSxTQUFTYSxVQUFVQTtBQUNsRDtBQUNBLHNHQUFzRztBQUMvRixTQUFTQyxtQkFBbUJDLFdBQVc7SUFDMUMsSUFBSUMsT0FBTztJQUNYLElBQUk7UUFDQUEsT0FBT1QsV0FBV1EsWUFBWUMsSUFBSTtJQUN0QyxFQUNBLE9BQU9MLE9BQU87UUFDVnJDLE9BQU9HLGtCQUFrQixDQUFDLHdCQUF3QixlQUFlc0M7SUFDckU7SUFDQSxNQUFNRSxRQUFRbkQsZ0VBQVVBLENBQUNMLDhEQUFRQSxDQUFDTSwrREFBU0EsQ0FBQ2lELElBQUksQ0FBQ0QsWUFBWUUsS0FBSyxFQUFFQyxXQUFXO0lBQy9FLE9BQU9YLFdBQVczQyxrRUFBWUEsQ0FBQ00sbUVBQVNBLENBQUNDLDBEQUFNQSxDQUFDO1FBQUM2QztRQUFNQztLQUFNLElBQUk7QUFDckU7QUFDTyxTQUFTRSxrQkFBa0JILElBQUksRUFBRUksSUFBSSxFQUFFQyxZQUFZO0lBQ3RELElBQUkxRCxtRUFBYUEsQ0FBQ3lELFVBQVUsSUFBSTtRQUM1QjlDLE9BQU9HLGtCQUFrQixDQUFDLHlCQUF5QixRQUFRMkM7SUFDL0Q7SUFDQSxJQUFJekQsbUVBQWFBLENBQUMwRCxrQkFBa0IsSUFBSTtRQUNwQy9DLE9BQU9HLGtCQUFrQixDQUFDLGlDQUFpQyxnQkFBZ0I0QztJQUMvRTtJQUNBLE9BQU9kLFdBQVczQyxrRUFBWUEsQ0FBQ00sbUVBQVNBLENBQUNSLDREQUFNQSxDQUFDO1FBQUM7UUFBUTZDLFdBQVdTO1FBQU9JO1FBQU1DO0tBQWEsSUFBSTtBQUN0RyxFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWRkcmVzcy9saWIuZXNtL2luZGV4LmpzP2I0ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgY29uY2F0LCBoZXhEYXRhTGVuZ3RoLCBoZXhEYXRhU2xpY2UsIGlzSGV4U3RyaW5nLCBzdHJpcFplcm9zIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIsIF9iYXNlMTZUbzM2LCBfYmFzZTM2VG8xNiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIjtcbmltcG9ydCB7IGVuY29kZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ybHBcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmZ1bmN0aW9uIGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgaWYgKCFpc0hleFN0cmluZyhhZGRyZXNzLCAyMCkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgfVxuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgY2hhcnMgPSBhZGRyZXNzLnN1YnN0cmluZygyKS5zcGxpdChcIlwiKTtcbiAgICBjb25zdCBleHBhbmRlZCA9IG5ldyBVaW50OEFycmF5KDQwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpKyspIHtcbiAgICAgICAgZXhwYW5kZWRbaV0gPSBjaGFyc1tpXS5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZWQgPSBhcnJheWlmeShrZWNjYWsyNTYoZXhwYW5kZWQpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSA+PiA0KSA+PSA4KSB7XG4gICAgICAgICAgICBjaGFyc1tpXSA9IGNoYXJzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoYXNoZWRbaSA+PiAxXSAmIDB4MGYpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2kgKyAxXSA9IGNoYXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBjaGFycy5qb2luKFwiXCIpO1xufVxuLy8gU2hpbXMgZm9yIGVudmlyb25tZW50cyB0aGF0IGFyZSBtaXNzaW5nIHNvbWUgcmVxdWlyZWQgY29uc3RhbnRzIGFuZCBmdW5jdGlvbnNcbmNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmO1xuZnVuY3Rpb24gbG9nMTAoeCkge1xuICAgIGlmIChNYXRoLmxvZzEwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZzEwKHgpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMTA7XG59XG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVybmF0aW9uYWxfQmFua19BY2NvdW50X051bWJlclxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZVxuY29uc3QgaWJhbkxvb2t1cCA9IHt9O1xuZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgaWJhbkxvb2t1cFtTdHJpbmcoaSldID0gU3RyaW5nKGkpO1xufVxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNjsgaSsrKSB7XG4gICAgaWJhbkxvb2t1cFtTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgaSldID0gU3RyaW5nKDEwICsgaSk7XG59XG4vLyBIb3cgbWFueSBkZWNpbWFsIGRpZ2l0cyBjYW4gd2UgcHJvY2Vzcz8gKGZvciA2NC1iaXQgZmxvYXQsIHRoaXMgaXMgMTUpXG5jb25zdCBzYWZlRGlnaXRzID0gTWF0aC5mbG9vcihsb2cxMChNQVhfU0FGRV9JTlRFR0VSKSk7XG5mdW5jdGlvbiBpYmFuQ2hlY2tzdW0oYWRkcmVzcykge1xuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvVXBwZXJDYXNlKCk7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3Muc3Vic3RyaW5nKDQpICsgYWRkcmVzcy5zdWJzdHJpbmcoMCwgMikgKyBcIjAwXCI7XG4gICAgbGV0IGV4cGFuZGVkID0gYWRkcmVzcy5zcGxpdChcIlwiKS5tYXAoKGMpID0+IHsgcmV0dXJuIGliYW5Mb29rdXBbY107IH0pLmpvaW4oXCJcIik7XG4gICAgLy8gSmF2YXNjcmlwdCBjYW4gaGFuZGxlIGludGVnZXJzIHNhZmVseSB1cCB0byAxNSAoZGVjaW1hbCkgZGlnaXRzXG4gICAgd2hpbGUgKGV4cGFuZGVkLmxlbmd0aCA+PSBzYWZlRGlnaXRzKSB7XG4gICAgICAgIGxldCBibG9jayA9IGV4cGFuZGVkLnN1YnN0cmluZygwLCBzYWZlRGlnaXRzKTtcbiAgICAgICAgZXhwYW5kZWQgPSBwYXJzZUludChibG9jaywgMTApICUgOTcgKyBleHBhbmRlZC5zdWJzdHJpbmcoYmxvY2subGVuZ3RoKTtcbiAgICB9XG4gICAgbGV0IGNoZWNrc3VtID0gU3RyaW5nKDk4IC0gKHBhcnNlSW50KGV4cGFuZGVkLCAxMCkgJSA5NykpO1xuICAgIHdoaWxlIChjaGVja3N1bS5sZW5ndGggPCAyKSB7XG4gICAgICAgIGNoZWNrc3VtID0gXCIwXCIgKyBjaGVja3N1bTtcbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrc3VtO1xufVxuO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFkZHJlc3MoYWRkcmVzcykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgIH1cbiAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXigweCk/WzAtOWEtZkEtRl17NDB9JC8pKSB7XG4gICAgICAgIC8vIE1pc3NpbmcgdGhlIDB4IHByZWZpeFxuICAgICAgICBpZiAoYWRkcmVzcy5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICAgICAgYWRkcmVzcyA9IFwiMHhcIiArIGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAvLyBJdCBpcyBhIGNoZWNrc3VtbWVkIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuICAgICAgICBpZiAoYWRkcmVzcy5tYXRjaCgvKFtBLUZdLipbYS1mXSl8KFthLWZdLipbQS1GXSkvKSAmJiByZXN1bHQgIT09IGFkZHJlc3MpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJiYWQgYWRkcmVzcyBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWF5YmUgSUNBUD8gKHdlIG9ubHkgc3VwcG9ydCBkaXJlY3QgbW9kZSlcbiAgICB9XG4gICAgZWxzZSBpZiAoYWRkcmVzcy5tYXRjaCgvXlhFWzAtOV17Mn1bMC05QS1aYS16XXszMCwzMX0kLykpIHtcbiAgICAgICAgLy8gSXQgaXMgYW4gSUNBUCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgaWYgKGFkZHJlc3Muc3Vic3RyaW5nKDIsIDQpICE9PSBpYmFuQ2hlY2tzdW0oYWRkcmVzcykpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJiYWQgaWNhcCBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gX2Jhc2UzNlRvMTYoYWRkcmVzcy5zdWJzdHJpbmcoNCkpO1xuICAgICAgICB3aGlsZSAocmVzdWx0Lmxlbmd0aCA8IDQwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBnZXRDaGVja3N1bUFkZHJlc3MoXCIweFwiICsgcmVzdWx0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEljYXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBsZXQgYmFzZTM2ID0gX2Jhc2UxNlRvMzYoZ2V0QWRkcmVzcyhhZGRyZXNzKS5zdWJzdHJpbmcoMikpLnRvVXBwZXJDYXNlKCk7XG4gICAgd2hpbGUgKGJhc2UzNi5sZW5ndGggPCAzMCkge1xuICAgICAgICBiYXNlMzYgPSBcIjBcIiArIGJhc2UzNjtcbiAgICB9XG4gICAgcmV0dXJuIFwiWEVcIiArIGliYW5DaGVja3N1bShcIlhFMDBcIiArIGJhc2UzNikgKyBiYXNlMzY7XG59XG4vLyBodHRwOi8vZXRoZXJldW0uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzc2MC9ob3ctaXMtdGhlLWFkZHJlc3Mtb2YtYW4tZXRoZXJldW0tY29udHJhY3QtY29tcHV0ZWRcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250cmFjdEFkZHJlc3ModHJhbnNhY3Rpb24pIHtcbiAgICBsZXQgZnJvbSA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgICAgZnJvbSA9IGdldEFkZHJlc3ModHJhbnNhY3Rpb24uZnJvbSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyBmcm9tIGFkZHJlc3NcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IG5vbmNlID0gc3RyaXBaZXJvcyhhcnJheWlmeShCaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbi5ub25jZSkudG9IZXhTdHJpbmcoKSkpO1xuICAgIHJldHVybiBnZXRBZGRyZXNzKGhleERhdGFTbGljZShrZWNjYWsyNTYoZW5jb2RlKFtmcm9tLCBub25jZV0pKSwgMTIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcmVhdGUyQWRkcmVzcyhmcm9tLCBzYWx0LCBpbml0Q29kZUhhc2gpIHtcbiAgICBpZiAoaGV4RGF0YUxlbmd0aChzYWx0KSAhPT0gMzIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNhbHQgbXVzdCBiZSAzMiBieXRlc1wiLCBcInNhbHRcIiwgc2FsdCk7XG4gICAgfVxuICAgIGlmIChoZXhEYXRhTGVuZ3RoKGluaXRDb2RlSGFzaCkgIT09IDMyKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbml0Q29kZUhhc2ggbXVzdCBiZSAzMiBieXRlc1wiLCBcImluaXRDb2RlSGFzaFwiLCBpbml0Q29kZUhhc2gpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhoZXhEYXRhU2xpY2Uoa2VjY2FrMjU2KGNvbmNhdChbXCIweGZmXCIsIGdldEFkZHJlc3MoZnJvbSksIHNhbHQsIGluaXRDb2RlSGFzaF0pKSwgMTIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJhcnJheWlmeSIsImNvbmNhdCIsImhleERhdGFMZW5ndGgiLCJoZXhEYXRhU2xpY2UiLCJpc0hleFN0cmluZyIsInN0cmlwWmVyb3MiLCJCaWdOdW1iZXIiLCJfYmFzZTE2VG8zNiIsIl9iYXNlMzZUbzE2Iiwia2VjY2FrMjU2IiwiZW5jb2RlIiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsImdldENoZWNrc3VtQWRkcmVzcyIsImFkZHJlc3MiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJ0b0xvd2VyQ2FzZSIsImNoYXJzIiwic3Vic3RyaW5nIiwic3BsaXQiLCJleHBhbmRlZCIsIlVpbnQ4QXJyYXkiLCJpIiwiY2hhckNvZGVBdCIsImhhc2hlZCIsInRvVXBwZXJDYXNlIiwiam9pbiIsIk1BWF9TQUZFX0lOVEVHRVIiLCJsb2cxMCIsIngiLCJNYXRoIiwibG9nIiwiTE4xMCIsImliYW5Mb29rdXAiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzYWZlRGlnaXRzIiwiZmxvb3IiLCJpYmFuQ2hlY2tzdW0iLCJtYXAiLCJjIiwibGVuZ3RoIiwiYmxvY2siLCJwYXJzZUludCIsImNoZWNrc3VtIiwiZ2V0QWRkcmVzcyIsInJlc3VsdCIsIm1hdGNoIiwiaXNBZGRyZXNzIiwiZXJyb3IiLCJnZXRJY2FwQWRkcmVzcyIsImJhc2UzNiIsImdldENvbnRyYWN0QWRkcmVzcyIsInRyYW5zYWN0aW9uIiwiZnJvbSIsIm5vbmNlIiwidG9IZXhTdHJpbmciLCJnZXRDcmVhdGUyQWRkcmVzcyIsInNhbHQiLCJpbml0Q29kZUhhc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/address/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/base64/lib.esm/base64.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/base64/lib.esm/base64.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n\n\nfunction decode(textData) {\n    textData = atob(textData);\n    const data = [];\n    for(let i = 0; i < textData.length; i++){\n        data.push(textData.charCodeAt(i));\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(data);\n}\nfunction encode(data) {\n    data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(data);\n    let textData = \"\";\n    for(let i = 0; i < data.length; i++){\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n} //# sourceMappingURL=base64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmFzZTY0L2xpYi5lc20vYmFzZTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFhO0FBQ21DO0FBQ3pDLFNBQVNDLE9BQU9DLFFBQVE7SUFDM0JBLFdBQVdDLEtBQUtEO0lBQ2hCLE1BQU1FLE9BQU8sRUFBRTtJQUNmLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxTQUFTSSxNQUFNLEVBQUVELElBQUs7UUFDdENELEtBQUtHLElBQUksQ0FBQ0wsU0FBU00sVUFBVSxDQUFDSDtJQUNsQztJQUNBLE9BQU9MLDhEQUFRQSxDQUFDSTtBQUNwQjtBQUNPLFNBQVNLLE9BQU9MLElBQUk7SUFDdkJBLE9BQU9KLDhEQUFRQSxDQUFDSTtJQUNoQixJQUFJRixXQUFXO0lBQ2YsSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlELEtBQUtFLE1BQU0sRUFBRUQsSUFBSztRQUNsQ0gsWUFBWVEsT0FBT0MsWUFBWSxDQUFDUCxJQUFJLENBQUNDLEVBQUU7SUFDM0M7SUFDQSxPQUFPTyxLQUFLVjtBQUNoQixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmFzZTY0L2xpYi5lc20vYmFzZTY0LmpzPzEzNDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBhcnJheWlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZSh0ZXh0RGF0YSkge1xuICAgIHRleHREYXRhID0gYXRvYih0ZXh0RGF0YSk7XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YS5wdXNoKHRleHREYXRhLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlpZnkoZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgICBkYXRhID0gYXJyYXlpZnkoZGF0YSk7XG4gICAgbGV0IHRleHREYXRhID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGV4dERhdGEgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ0b2EodGV4dERhdGEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTY0LmpzLm1hcCJdLCJuYW1lcyI6WyJhcnJheWlmeSIsImRlY29kZSIsInRleHREYXRhIiwiYXRvYiIsImRhdGEiLCJpIiwibGVuZ3RoIiwicHVzaCIsImNoYXJDb2RlQXQiLCJlbmNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJidG9hIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/base64/lib.esm/base64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/basex/lib.esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@ethersproject/basex/lib.esm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Base32: () => (/* binding */ Base32),\n/* harmony export */   Base58: () => (/* binding */ Base58),\n/* harmony export */   BaseX: () => (/* binding */ BaseX)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/@ethersproject/properties/lib.esm/index.js\");\n/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */ \n\nclass BaseX {\n    constructor(alphabet){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, \"alphabet\", alphabet);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, \"base\", alphabet.length);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, \"_alphabetMap\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, \"_leader\", alphabet.charAt(0));\n        // pre-compute lookup table\n        for(let i = 0; i < alphabet.length; i++){\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n    encode(value) {\n        let source = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(value);\n        if (source.length === 0) {\n            return \"\";\n        }\n        let digits = [\n            0\n        ];\n        for(let i = 0; i < source.length; ++i){\n            let carry = source[i];\n            for(let j = 0; j < digits.length; ++j){\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = carry / this.base | 0;\n            }\n            while(carry > 0){\n                digits.push(carry % this.base);\n                carry = carry / this.base | 0;\n            }\n        }\n        let string = \"\";\n        // deal with leading zeros\n        for(let k = 0; source[k] === 0 && k < source.length - 1; ++k){\n            string += this._leader;\n        }\n        // convert digits to a string\n        for(let q = digits.length - 1; q >= 0; --q){\n            string += this.alphabet[digits[q]];\n        }\n        return string;\n    }\n    decode(value) {\n        if (typeof value !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        let bytes = [];\n        if (value.length === 0) {\n            return new Uint8Array(bytes);\n        }\n        bytes.push(0);\n        for(let i = 0; i < value.length; i++){\n            let byte = this._alphabetMap[value[i]];\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n            let carry = byte;\n            for(let j = 0; j < bytes.length; ++j){\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n            while(carry > 0){\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n        // deal with leading zeros\n        for(let k = 0; value[k] === this._leader && k < value.length - 1; ++k){\n            bytes.push(0);\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(new Uint8Array(bytes.reverse()));\n    }\n}\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n //console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n //console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmFzZXgvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXNDQyxHQUMrQztBQUNXO0FBQ3BELE1BQU1FO0lBQ1RDLFlBQVlDLFFBQVEsQ0FBRTtRQUNsQkgseUVBQWNBLENBQUMsSUFBSSxFQUFFLFlBQVlHO1FBQ2pDSCx5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsUUFBUUcsU0FBU0MsTUFBTTtRQUM1Q0oseUVBQWNBLENBQUMsSUFBSSxFQUFFLGdCQUFnQixDQUFDO1FBQ3RDQSx5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsV0FBV0csU0FBU0UsTUFBTSxDQUFDO1FBQ2hELDJCQUEyQjtRQUMzQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsU0FBU0MsTUFBTSxFQUFFRSxJQUFLO1lBQ3RDLElBQUksQ0FBQ0MsWUFBWSxDQUFDSixTQUFTRSxNQUFNLENBQUNDLEdBQUcsR0FBR0E7UUFDNUM7SUFDSjtJQUNBRSxPQUFPQyxLQUFLLEVBQUU7UUFDVixJQUFJQyxTQUFTWCw4REFBUUEsQ0FBQ1U7UUFDdEIsSUFBSUMsT0FBT04sTUFBTSxLQUFLLEdBQUc7WUFDckIsT0FBTztRQUNYO1FBQ0EsSUFBSU8sU0FBUztZQUFDO1NBQUU7UUFDaEIsSUFBSyxJQUFJTCxJQUFJLEdBQUdBLElBQUlJLE9BQU9OLE1BQU0sRUFBRSxFQUFFRSxFQUFHO1lBQ3BDLElBQUlNLFFBQVFGLE1BQU0sQ0FBQ0osRUFBRTtZQUNyQixJQUFLLElBQUlPLElBQUksR0FBR0EsSUFBSUYsT0FBT1AsTUFBTSxFQUFFLEVBQUVTLEVBQUc7Z0JBQ3BDRCxTQUFTRCxNQUFNLENBQUNFLEVBQUUsSUFBSTtnQkFDdEJGLE1BQU0sQ0FBQ0UsRUFBRSxHQUFHRCxRQUFRLElBQUksQ0FBQ0UsSUFBSTtnQkFDN0JGLFFBQVEsUUFBUyxJQUFJLENBQUNFLElBQUksR0FBSTtZQUNsQztZQUNBLE1BQU9GLFFBQVEsRUFBRztnQkFDZEQsT0FBT0ksSUFBSSxDQUFDSCxRQUFRLElBQUksQ0FBQ0UsSUFBSTtnQkFDN0JGLFFBQVEsUUFBUyxJQUFJLENBQUNFLElBQUksR0FBSTtZQUNsQztRQUNKO1FBQ0EsSUFBSUUsU0FBUztRQUNiLDBCQUEwQjtRQUMxQixJQUFLLElBQUlDLElBQUksR0FBR1AsTUFBTSxDQUFDTyxFQUFFLEtBQUssS0FBS0EsSUFBSVAsT0FBT04sTUFBTSxHQUFHLEdBQUcsRUFBRWEsRUFBRztZQUMzREQsVUFBVSxJQUFJLENBQUNFLE9BQU87UUFDMUI7UUFDQSw2QkFBNkI7UUFDN0IsSUFBSyxJQUFJQyxJQUFJUixPQUFPUCxNQUFNLEdBQUcsR0FBR2UsS0FBSyxHQUFHLEVBQUVBLEVBQUc7WUFDekNILFVBQVUsSUFBSSxDQUFDYixRQUFRLENBQUNRLE1BQU0sQ0FBQ1EsRUFBRSxDQUFDO1FBQ3RDO1FBQ0EsT0FBT0g7SUFDWDtJQUNBSSxPQUFPWCxLQUFLLEVBQUU7UUFDVixJQUFJLE9BQVFBLFVBQVcsVUFBVTtZQUM3QixNQUFNLElBQUlZLFVBQVU7UUFDeEI7UUFDQSxJQUFJQyxRQUFRLEVBQUU7UUFDZCxJQUFJYixNQUFNTCxNQUFNLEtBQUssR0FBRztZQUNwQixPQUFPLElBQUltQixXQUFXRDtRQUMxQjtRQUNBQSxNQUFNUCxJQUFJLENBQUM7UUFDWCxJQUFLLElBQUlULElBQUksR0FBR0EsSUFBSUcsTUFBTUwsTUFBTSxFQUFFRSxJQUFLO1lBQ25DLElBQUlrQixPQUFPLElBQUksQ0FBQ2pCLFlBQVksQ0FBQ0UsS0FBSyxDQUFDSCxFQUFFLENBQUM7WUFDdEMsSUFBSWtCLFNBQVNDLFdBQVc7Z0JBQ3BCLE1BQU0sSUFBSUMsTUFBTSxhQUFhLElBQUksQ0FBQ1osSUFBSSxHQUFHO1lBQzdDO1lBQ0EsSUFBSUYsUUFBUVk7WUFDWixJQUFLLElBQUlYLElBQUksR0FBR0EsSUFBSVMsTUFBTWxCLE1BQU0sRUFBRSxFQUFFUyxFQUFHO2dCQUNuQ0QsU0FBU1UsS0FBSyxDQUFDVCxFQUFFLEdBQUcsSUFBSSxDQUFDQyxJQUFJO2dCQUM3QlEsS0FBSyxDQUFDVCxFQUFFLEdBQUdELFFBQVE7Z0JBQ25CQSxVQUFVO1lBQ2Q7WUFDQSxNQUFPQSxRQUFRLEVBQUc7Z0JBQ2RVLE1BQU1QLElBQUksQ0FBQ0gsUUFBUTtnQkFDbkJBLFVBQVU7WUFDZDtRQUNKO1FBQ0EsMEJBQTBCO1FBQzFCLElBQUssSUFBSUssSUFBSSxHQUFHUixLQUFLLENBQUNRLEVBQUUsS0FBSyxJQUFJLENBQUNDLE9BQU8sSUFBSUQsSUFBSVIsTUFBTUwsTUFBTSxHQUFHLEdBQUcsRUFBRWEsRUFBRztZQUNwRUssTUFBTVAsSUFBSSxDQUFDO1FBQ2Y7UUFDQSxPQUFPaEIsOERBQVFBLENBQUMsSUFBSXdCLFdBQVdELE1BQU1LLE9BQU87SUFDaEQ7QUFDSjtBQUNBLE1BQU1DLFNBQVMsSUFBSTNCLE1BQU07QUFDekIsTUFBTTRCLFNBQVMsSUFBSTVCLE1BQU07QUFDQyxDQUMxQiw4RUFBOEU7Q0FDOUUsNkZBQTZGO0NBQzdGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmFzZXgvbGliLmVzbS9pbmRleC5qcz8xNzI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdmFyIGJhc2V4ID0gcmVxdWlyZShcImJhc2UteFwiKTtcbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGhlYXZpbHkgYmFzZWQgb24gYmFzZS14LiBUaGUgbWFpbiByZWFzb24gdG9cbiAqIGRldmlhdGUgd2FzIHRvIHByZXZlbnQgdGhlIGRlcGVuZGVuY3kgb2YgQnVmZmVyLlxuICpcbiAqIENvbnRyaWJ1dG9yczpcbiAqXG4gKiBiYXNlLXggZW5jb2RpbmdcbiAqIEZvcmtlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYnM1OFxuICogT3JpZ2luYWxseSB3cml0dGVuIGJ5IE1pa2UgSGVhcm4gZm9yIEJpdGNvaW5KXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEgR29vZ2xlIEluY1xuICogUG9ydGVkIHRvIEphdmFTY3JpcHQgYnkgU3RlZmFuIFRob21hc1xuICogTWVyZ2VkIEJ1ZmZlciByZWZhY3RvcmluZ3MgZnJvbSBiYXNlNTgtbmF0aXZlIGJ5IFN0ZXBoZW4gUGFpclxuICogQ29weXJpZ2h0IChjKSAyMDEzIEJpdFBheSBJbmNcbiAqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgYmFzZS14IGNvbnRyaWJ1dG9ycyAoYykgMjAxNlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xuICogSU4gVEhFIFNPRlRXQVJFLlxuICpcbiAqL1xuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmV4cG9ydCBjbGFzcyBCYXNlWCB7XG4gICAgY29uc3RydWN0b3IoYWxwaGFiZXQpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhbHBoYWJldFwiLCBhbHBoYWJldCk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYmFzZVwiLCBhbHBoYWJldC5sZW5ndGgpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9hbHBoYWJldE1hcFwiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2xlYWRlclwiLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xuICAgICAgICAvLyBwcmUtY29tcHV0ZSBsb29rdXAgdGFibGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbHBoYWJldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fYWxwaGFiZXRNYXBbYWxwaGFiZXQuY2hhckF0KGkpXSA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlnaXRzID0gWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IGNhcnJ5ID0gc291cmNlW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkaWdpdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjYXJyeSArPSBkaWdpdHNbal0gPDwgODtcbiAgICAgICAgICAgICAgICBkaWdpdHNbal0gPSBjYXJyeSAlIHRoaXMuYmFzZTtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IChjYXJyeSAvIHRoaXMuYmFzZSkgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xuICAgICAgICAgICAgICAgIGRpZ2l0cy5wdXNoKGNhcnJ5ICUgdGhpcy5iYXNlKTtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IChjYXJyeSAvIHRoaXMuYmFzZSkgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzdHJpbmcgPSBcIlwiO1xuICAgICAgICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgc291cmNlW2tdID09PSAwICYmIGsgPCBzb3VyY2UubGVuZ3RoIC0gMTsgKytrKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gdGhpcy5fbGVhZGVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnZlcnQgZGlnaXRzIHRvIGEgc3RyaW5nXG4gICAgICAgIGZvciAobGV0IHEgPSBkaWdpdHMubGVuZ3RoIC0gMTsgcSA+PSAwOyAtLXEpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSB0aGlzLmFscGhhYmV0W2RpZ2l0c1txXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG4gICAgZGVjb2RlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYnl0ZXMgPSBbXTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlcy5wdXNoKDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYnl0ZSA9IHRoaXMuX2FscGhhYmV0TWFwW3ZhbHVlW2ldXTtcbiAgICAgICAgICAgIGlmIChieXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb24tYmFzZVwiICsgdGhpcy5iYXNlICsgXCIgY2hhcmFjdGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNhcnJ5ID0gYnl0ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYnl0ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjYXJyeSArPSBieXRlc1tqXSAqIHRoaXMuYmFzZTtcbiAgICAgICAgICAgICAgICBieXRlc1tqXSA9IGNhcnJ5ICYgMHhmZjtcbiAgICAgICAgICAgICAgICBjYXJyeSA+Pj0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKGNhcnJ5ICYgMHhmZik7XG4gICAgICAgICAgICAgICAgY2FycnkgPj49IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IHZhbHVlW2tdID09PSB0aGlzLl9sZWFkZXIgJiYgayA8IHZhbHVlLmxlbmd0aCAtIDE7ICsraykge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlpZnkobmV3IFVpbnQ4QXJyYXkoYnl0ZXMucmV2ZXJzZSgpKSk7XG4gICAgfVxufVxuY29uc3QgQmFzZTMyID0gbmV3IEJhc2VYKFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjdcIik7XG5jb25zdCBCYXNlNTggPSBuZXcgQmFzZVgoXCIxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XCIpO1xuZXhwb3J0IHsgQmFzZTMyLCBCYXNlNTggfTtcbi8vY29uc29sZS5sb2coQmFzZTU4LmRlY29kZShcIlFtZDJWNzc3bzVYdkpiWU1lTWI4azJuVTVmOGQzY2lVUTVZcFl1V2h6djhpRGpcIikpXG4vL2NvbnNvbGUubG9nKEJhc2U1OC5lbmNvZGUoQmFzZTU4LmRlY29kZShcIlFtZDJWNzc3bzVYdkpiWU1lTWI4azJuVTVmOGQzY2lVUTVZcFl1V2h6djhpRGpcIikpKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbImFycmF5aWZ5IiwiZGVmaW5lUmVhZE9ubHkiLCJCYXNlWCIsImNvbnN0cnVjdG9yIiwiYWxwaGFiZXQiLCJsZW5ndGgiLCJjaGFyQXQiLCJpIiwiX2FscGhhYmV0TWFwIiwiZW5jb2RlIiwidmFsdWUiLCJzb3VyY2UiLCJkaWdpdHMiLCJjYXJyeSIsImoiLCJiYXNlIiwicHVzaCIsInN0cmluZyIsImsiLCJfbGVhZGVyIiwicSIsImRlY29kZSIsIlR5cGVFcnJvciIsImJ5dGVzIiwiVWludDhBcnJheSIsImJ5dGUiLCJ1bmRlZmluZWQiLCJFcnJvciIsInJldmVyc2UiLCJCYXNlMzIiLCJCYXNlNTgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/basex/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/_version.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/bignumber/lib.esm/_version.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"bignumber/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFVBQVUsa0JBQWtCLENBQ3pDLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyL2xpYi5lc20vX3ZlcnNpb24uanM/ZjU3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiYmlnbnVtYmVyLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BigNumber: () => (/* binding */ BigNumber),\n/* harmony export */   _base16To36: () => (/* binding */ _base16To36),\n/* harmony export */   _base36To16: () => (/* binding */ _base36To16),\n/* harmony export */   isBigNumberish: () => (/* binding */ isBigNumberish)\n/* harmony export */ });\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/_version.js\");\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */ \nvar BN = (bn_js__WEBPACK_IMPORTED_MODULE_0___default().BN);\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(_version__WEBPACK_IMPORTED_MODULE_2__.version);\nconst _constructorGuard = {};\nconst MAX_SAFE = 0x1fffffffffffff;\nfunction isBigNumberish(value) {\n    return value != null && (BigNumber.isBigNumber(value) || typeof value === \"number\" && value % 1 === 0 || typeof value === \"string\" && !!value.match(/^-?[0-9]+$/) || (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(value) || typeof value === \"bigint\" || (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isBytes)(value));\n}\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\nclass BigNumber {\n    constructor(constructorGuard, hex){\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n        this._hex = hex;\n        this._isBigNumber = true;\n        Object.freeze(this);\n    }\n    fromTwos(value) {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n    toTwos(value) {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n    abs() {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n    add(other) {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n    sub(other) {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n    div(other) {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n    mul(other) {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n    mod(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n    pow(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n    and(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n    or(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n    xor(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n    mask(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n    shl(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n    shr(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n    eq(other) {\n        return toBN(this).eq(toBN(other));\n    }\n    lt(other) {\n        return toBN(this).lt(toBN(other));\n    }\n    lte(other) {\n        return toBN(this).lte(toBN(other));\n    }\n    gt(other) {\n        return toBN(this).gt(toBN(other));\n    }\n    gte(other) {\n        return toBN(this).gte(toBN(other));\n    }\n    isNegative() {\n        return this._hex[0] === \"-\";\n    }\n    isZero() {\n        return toBN(this).isZero();\n    }\n    toNumber() {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n    toBigInt() {\n        try {\n            return BigInt(this.toString());\n        } catch (e) {}\n        return logger.throwError(\"this platform does not support BigInt\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n    toString() {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNEXPECTED_ARGUMENT, {});\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNEXPECTED_ARGUMENT, {});\n            }\n        }\n        return toBN(this).toString(10);\n    }\n    toHexString() {\n        return this._hex;\n    }\n    toJSON(key) {\n        return {\n            type: \"BigNumber\",\n            hex: this.toHexString()\n        };\n    }\n    static from(value) {\n        if (value instanceof BigNumber) {\n            return value;\n        }\n        if (typeof value === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n        if (typeof value === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n            return BigNumber.from(String(value));\n        }\n        const anyValue = value;\n        if (typeof anyValue === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isBytes)(anyValue)) {\n            return BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(anyValue));\n        }\n        if (anyValue) {\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof hex === \"string\") {\n                    return BigNumber.from(hex);\n                }\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n                if (typeof hex === \"string\") {\n                    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(hex) || hex[0] === \"-\" && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(hex.substring(1))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n    static isBigNumber(value) {\n        return !!(value && value._isBigNumber);\n    }\n}\n// Normalize the hex string\nfunction toHex(value) {\n    // For BN, call on the hex string\n    if (typeof value !== \"string\") {\n        return toHex(value.toString(16));\n    }\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") {\n            logger.throwArgumentError(\"invalid hex\", \"value\", value);\n        }\n        // Call toHex on the positive component\n        value = toHex(value);\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") {\n            return value;\n        }\n        // Negate the value\n        return \"-\" + value;\n    }\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    // Normalize zero\n    if (value === \"0x\") {\n        return \"0x00\";\n    }\n    // Make the string even length\n    if (value.length % 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    // Trim to smallest even-length string\n    while(value.length > 4 && value.substring(0, 4) === \"0x00\"){\n        value = \"0x\" + value.substring(4);\n    }\n    return value;\n}\nfunction toBigNumber(value) {\n    return BigNumber.from(toHex(value));\n}\nfunction toBN(value) {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return new BN(\"-\" + hex.substring(3), 16);\n    }\n    return new BN(hex.substring(2), 16);\n}\nfunction throwFault(fault, operation, value) {\n    const params = {\n        fault: fault,\n        operation: operation\n    };\n    if (value != null) {\n        params.value = value;\n    }\n    return logger.throwError(fault, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NUMERIC_FAULT, params);\n}\n// value should have no prefix\nfunction _base36To16(value) {\n    return new BN(value, 36).toString(16);\n}\n// value should have no prefix\nfunction _base16To36(value) {\n    return new BN(value, 16).toString(36);\n} //# sourceMappingURL=bignumber.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyL2xpYi5lc20vYmlnbnVtYmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFhO0FBQ2I7Ozs7OztDQU1DLEdBQ3VCO0FBQ3hCLElBQUlDLEtBQUtELGlEQUFNO0FBQ3NEO0FBQ3RCO0FBQ1Y7QUFDckMsTUFBTU8sU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BO0FBQ2pDLE1BQU1FLG9CQUFvQixDQUFDO0FBQzNCLE1BQU1DLFdBQVc7QUFDVixTQUFTQyxlQUFlQyxLQUFLO0lBQ2hDLE9BQU8sU0FBVSxRQUFVQyxDQUFBQSxVQUFVQyxXQUFXLENBQUNGLFVBQzVDLE9BQVFBLFVBQVcsWUFBWSxRQUFTLE1BQU8sS0FDL0MsT0FBUUEsVUFBVyxZQUFZLENBQUMsQ0FBQ0EsTUFBTUcsS0FBSyxDQUFDLGlCQUM5Q1YsaUVBQVdBLENBQUNPLFVBQ1gsT0FBUUEsVUFBVyxZQUNwQlIsNkRBQU9BLENBQUNRLE1BQUs7QUFDckI7QUFDQSw2Q0FBNkM7QUFDN0MsSUFBSUksdUJBQXVCO0FBQ3BCLE1BQU1IO0lBQ1RJLFlBQVlDLGdCQUFnQixFQUFFQyxHQUFHLENBQUU7UUFDL0IsSUFBSUQscUJBQXFCVCxtQkFBbUI7WUFDeENELE9BQU9ZLFVBQVUsQ0FBQyx3REFBd0RkLHlEQUFNQSxDQUFDZSxNQUFNLENBQUNDLHFCQUFxQixFQUFFO2dCQUMzR0MsV0FBVztZQUNmO1FBQ0o7UUFDQSxJQUFJLENBQUNDLElBQUksR0FBR0w7UUFDWixJQUFJLENBQUNNLFlBQVksR0FBRztRQUNwQkMsT0FBT0MsTUFBTSxDQUFDLElBQUk7SUFDdEI7SUFDQUMsU0FBU2hCLEtBQUssRUFBRTtRQUNaLE9BQU9pQixZQUFZQyxLQUFLLElBQUksRUFBRUYsUUFBUSxDQUFDaEI7SUFDM0M7SUFDQW1CLE9BQU9uQixLQUFLLEVBQUU7UUFDVixPQUFPaUIsWUFBWUMsS0FBSyxJQUFJLEVBQUVDLE1BQU0s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QUFVb0IsSUFBSSxDQUFDckIsT0FBTzRELFdBQVc7SUFDN0MsSUFBSXJELEdBQUcsQ0FBQyxFQUFFLEtBQUssS0FBSztRQUNoQixPQUFRLElBQUlqQixHQUFHLE1BQU1pQixJQUFJZSxTQUFTLENBQUMsSUFBSTtJQUMzQztJQUNBLE9BQU8sSUFBSWhDLEdBQUdpQixJQUFJZSxTQUFTLENBQUMsSUFBSTtBQUNwQztBQUNBLFNBQVNPLFdBQVd1QyxLQUFLLEVBQUV6RCxTQUFTLEVBQUVYLEtBQUs7SUFDdkMsTUFBTXFFLFNBQVM7UUFBRUQsT0FBT0E7UUFBT3pELFdBQVdBO0lBQVU7SUFDcEQsSUFBSVgsU0FBUyxNQUFNO1FBQ2ZxRSxPQUFPckUsS0FBSyxHQUFHQTtJQUNuQjtJQUNBLE9BQU9KLE9BQU9ZLFVBQVUsQ0FBQzRELE9BQU8xRSx5REFBTUEsQ0FBQ2UsTUFBTSxDQUFDNkQsYUFBYSxFQUFFRDtBQUNqRTtBQUNBLDhCQUE4QjtBQUN2QixTQUFTRSxZQUFZdkUsS0FBSztJQUM3QixPQUFPLElBQUtWLEdBQUdVLE9BQU8sSUFBS29ELFFBQVEsQ0FBQztBQUN4QztBQUNBLDhCQUE4QjtBQUN2QixTQUFTb0IsWUFBWXhFLEtBQUs7SUFDN0IsT0FBTyxJQUFLVixHQUFHVSxPQUFPLElBQUtvRCxRQUFRLENBQUM7QUFDeEMsRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIuZXNtL2JpZ251bWJlci5qcz8yNDhhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiAgQmlnTnVtYmVyXG4gKlxuICogIEEgd3JhcHBlciBhcm91bmQgdGhlIEJOLmpzIG9iamVjdC4gV2UgdXNlIHRoZSBCTi5qcyBsaWJyYXJ5XG4gKiAgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IGVsbGlwdGljLCBzbyBpdCBpcyByZXF1aXJlZCByZWdhcmRsZXNzLlxuICpcbiAqL1xuaW1wb3J0IF9CTiBmcm9tIFwiYm4uanNcIjtcbnZhciBCTiA9IF9CTi5CTjtcbmltcG9ydCB7IGhleGxpZnksIGlzQnl0ZXMsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5jb25zdCBfY29uc3RydWN0b3JHdWFyZCA9IHt9O1xuY29uc3QgTUFYX1NBRkUgPSAweDFmZmZmZmZmZmZmZmZmO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQmlnTnVtYmVyaXNoKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsKSAmJiAoQmlnTnVtYmVyLmlzQmlnTnVtYmVyKHZhbHVlKSB8fFxuICAgICAgICAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIgJiYgKHZhbHVlICUgMSkgPT09IDApIHx8XG4gICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiAhIXZhbHVlLm1hdGNoKC9eLT9bMC05XSskLykpIHx8XG4gICAgICAgIGlzSGV4U3RyaW5nKHZhbHVlKSB8fFxuICAgICAgICAodHlwZW9mICh2YWx1ZSkgPT09IFwiYmlnaW50XCIpIHx8XG4gICAgICAgIGlzQnl0ZXModmFsdWUpKTtcbn1cbi8vIE9ubHkgd2FybiBhYm91dCBwYXNzaW5nIDEwIGludG8gcmFkaXggb25jZVxubGV0IF93YXJuZWRUb1N0cmluZ1JhZGl4ID0gZmFsc2U7XG5leHBvcnQgY2xhc3MgQmlnTnVtYmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLCBoZXgpIHtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBjYWxsIGNvbnN0cnVjdG9yIGRpcmVjdGx5OyB1c2UgQmlnTnVtYmVyLmZyb21cIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IChCaWdOdW1iZXIpXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hleCA9IGhleDtcbiAgICAgICAgdGhpcy5faXNCaWdOdW1iZXIgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBmcm9tVHdvcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5mcm9tVHdvcyh2YWx1ZSkpO1xuICAgIH1cbiAgICB0b1R3b3ModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykudG9Ud29zKHZhbHVlKSk7XG4gICAgfVxuICAgIGFicygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hleFswXSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh0aGlzLl9oZXguc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmFkZCh0b0JOKG90aGVyKSkpO1xuICAgIH1cbiAgICBzdWIob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuc3ViKHRvQk4ob3RoZXIpKSk7XG4gICAgfVxuICAgIGRpdihvdGhlcikge1xuICAgICAgICBjb25zdCBvID0gQmlnTnVtYmVyLmZyb20ob3RoZXIpO1xuICAgICAgICBpZiAoby5pc1plcm8oKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcImRpdmlzaW9uLWJ5LXplcm9cIiwgXCJkaXZcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuZGl2KHRvQk4ob3RoZXIpKSk7XG4gICAgfVxuICAgIG11bChvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5tdWwodG9CTihvdGhlcikpKTtcbiAgICB9XG4gICAgbW9kKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9CTihvdGhlcik7XG4gICAgICAgIGlmICh2YWx1ZS5pc05lZygpKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwiZGl2aXNpb24tYnktemVyb1wiLCBcIm1vZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS51bW9kKHZhbHVlKSk7XG4gICAgfVxuICAgIHBvdyhvdGhlcikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuICAgICAgICBpZiAodmFsdWUuaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcIm5lZ2F0aXZlLXBvd2VyXCIsIFwicG93XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnBvdyh2YWx1ZSkpO1xuICAgIH1cbiAgICBhbmQob3RoZXIpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0b0JOKG90aGVyKTtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlLmlzTmVnKCkpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJ1bmJvdW5kLWJpdHdpc2UtcmVzdWx0XCIsIFwiYW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmFuZCh2YWx1ZSkpO1xuICAgIH1cbiAgICBvcihvdGhlcikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuYm91bmQtYml0d2lzZS1yZXN1bHRcIiwgXCJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5vcih2YWx1ZSkpO1xuICAgIH1cbiAgICB4b3Iob3RoZXIpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0b0JOKG90aGVyKTtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlLmlzTmVnKCkpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJ1bmJvdW5kLWJpdHdpc2UtcmVzdWx0XCIsIFwieG9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnhvcih2YWx1ZSkpO1xuICAgIH1cbiAgICBtYXNrKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJuZWdhdGl2ZS13aWR0aFwiLCBcIm1hc2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykubWFza24odmFsdWUpKTtcbiAgICB9XG4gICAgc2hsKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJuZWdhdGl2ZS13aWR0aFwiLCBcInNobFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5zaGxuKHZhbHVlKSk7XG4gICAgfVxuICAgIHNocih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwibmVnYXRpdmUtd2lkdGhcIiwgXCJzaHJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuc2hybih2YWx1ZSkpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5lcSh0b0JOKG90aGVyKSk7XG4gICAgfVxuICAgIGx0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmx0KHRvQk4ob3RoZXIpKTtcbiAgICB9XG4gICAgbHRlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmx0ZSh0b0JOKG90aGVyKSk7XG4gICAgfVxuICAgIGd0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmd0KHRvQk4ob3RoZXIpKTtcbiAgICB9XG4gICAgZ3RlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmd0ZSh0b0JOKG90aGVyKSk7XG4gICAgfVxuICAgIGlzTmVnYXRpdmUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5faGV4WzBdID09PSBcIi1cIik7XG4gICAgfVxuICAgIGlzWmVybygpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykuaXNaZXJvKCk7XG4gICAgfVxuICAgIHRvTnVtYmVyKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRvQk4odGhpcykudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJvdmVyZmxvd1wiLCBcInRvTnVtYmVyXCIsIHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRvQmlnSW50KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwidGhpcyBwbGF0Zm9ybSBkb2VzIG5vdCBzdXBwb3J0IEJpZ0ludFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMudG9TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIC8vIExvdHMgb2YgcGVvcGxlIGV4cGVjdCB0aGlzLCB3aGljaCB3ZSBkbyBub3Qgc3VwcG9ydCwgc28gY2hlY2sgKFNlZTogIzg4OSlcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzWzBdID09PSAxMCkge1xuICAgICAgICAgICAgICAgIGlmICghX3dhcm5lZFRvU3RyaW5nUmFkaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3dhcm5lZFRvU3RyaW5nUmFkaXggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIkJpZ051bWJlci50b1N0cmluZyBkb2VzIG5vdCBhY2NlcHQgYW55IHBhcmFtZXRlcnM7IGJhc2UtMTAgaXMgYXNzdW1lZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmd1bWVudHNbMF0gPT09IDE2KSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJCaWdOdW1iZXIudG9TdHJpbmcgZG9lcyBub3QgYWNjZXB0IGFueSBwYXJhbWV0ZXJzOyB1c2UgYmlnTnVtYmVyLnRvSGV4U3RyaW5nKClcIiwgTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkJpZ051bWJlci50b1N0cmluZyBkb2VzIG5vdCBhY2NlcHQgcGFyYW1ldGVyc1wiLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CTih0aGlzKS50b1N0cmluZygxMCk7XG4gICAgfVxuICAgIHRvSGV4U3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGV4O1xuICAgIH1cbiAgICB0b0pTT04oa2V5KSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiQmlnTnVtYmVyXCIsIGhleDogdGhpcy50b0hleFN0cmluZygpIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9eLT8weFswLTlhLWZdKyQvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihfY29uc3RydWN0b3JHdWFyZCwgdG9IZXgodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS5tYXRjaCgvXi0/WzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRvSGV4KG5ldyBCTih2YWx1ZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBCaWdOdW1iZXIgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKHZhbHVlICUgMSkge1xuICAgICAgICAgICAgICAgIHRocm93RmF1bHQoXCJ1bmRlcmZsb3dcIiwgXCJCaWdOdW1iZXIuZnJvbVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gTUFYX1NBRkUgfHwgdmFsdWUgPD0gLU1BWF9TQUZFKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dGYXVsdChcIm92ZXJmbG93XCIsIFwiQmlnTnVtYmVyLmZyb21cIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFueVZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgKGFueVZhbHVlKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKGFueVZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0J5dGVzKGFueVZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKGhleGxpZnkoYW55VmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55VmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEhleGFibGUgaW50ZXJmYWNlICh0YWtlcyBwcmlvcml0eSlcbiAgICAgICAgICAgIGlmIChhbnlWYWx1ZS50b0hleFN0cmluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhleCA9IGFueVZhbHVlLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaGV4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oaGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3Igbm93LCBoYW5kbGUgbGVnYWN5IEpTT04taWZpZWQgdmFsdWVzIChnb2VzIGF3YXkgaW4gdjYpXG4gICAgICAgICAgICAgICAgbGV0IGhleCA9IGFueVZhbHVlLl9oZXg7XG4gICAgICAgICAgICAgICAgLy8gTmV3LWZvcm0gSlNPTlxuICAgICAgICAgICAgICAgIGlmIChoZXggPT0gbnVsbCAmJiBhbnlWYWx1ZS50eXBlID09PSBcIkJpZ051bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGhleCA9IGFueVZhbHVlLmhleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaGV4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoaGV4KSB8fCAoaGV4WzBdID09PSBcIi1cIiAmJiBpc0hleFN0cmluZyhoZXguc3Vic3RyaW5nKDEpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShoZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBCaWdOdW1iZXIgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0JpZ051bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzQmlnTnVtYmVyKTtcbiAgICB9XG59XG4vLyBOb3JtYWxpemUgdGhlIGhleCBzdHJpbmdcbmZ1bmN0aW9uIHRvSGV4KHZhbHVlKSB7XG4gICAgLy8gRm9yIEJOLCBjYWxsIG9uIHRoZSBoZXggc3RyaW5nXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB0b0hleCh2YWx1ZS50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICAvLyBJZiBuZWdhdGl2ZSwgcHJlcGVuZCB0aGUgbmVnYXRpdmUgc2lnbiB0byB0aGUgbm9ybWFsaXplZCBwb3NpdGl2ZSB2YWx1ZVxuICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSBuZWdhdGl2ZSBzaWduXG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAvLyBDYW5ub3QgaGF2ZSBtdWx0aXBsZSBuZWdhdGl2ZSBzaWducyAoZS5nLiBcIi0tMHgwNFwiKVxuICAgICAgICBpZiAodmFsdWVbMF0gPT09IFwiLVwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsbCB0b0hleCBvbiB0aGUgcG9zaXRpdmUgY29tcG9uZW50XG4gICAgICAgIHZhbHVlID0gdG9IZXgodmFsdWUpO1xuICAgICAgICAvLyBEbyBub3QgYWxsb3cgXCItMHgwMFwiXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gXCIweDAwXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZWdhdGUgdGhlIHZhbHVlXG4gICAgICAgIHJldHVybiBcIi1cIiArIHZhbHVlO1xuICAgIH1cbiAgICAvLyBBZGQgYSBcIjB4XCIgcHJlZml4IGlmIG1pc3NpbmdcbiAgICBpZiAodmFsdWUuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcbiAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIHplcm9cbiAgICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gXCIweDAwXCI7XG4gICAgfVxuICAgIC8vIE1ha2UgdGhlIHN0cmluZyBldmVuIGxlbmd0aFxuICAgIGlmICh2YWx1ZS5sZW5ndGggJSAyKSB7XG4gICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgLy8gVHJpbSB0byBzbWFsbGVzdCBldmVuLWxlbmd0aCBzdHJpbmdcbiAgICB3aGlsZSAodmFsdWUubGVuZ3RoID4gNCAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgNCkgPT09IFwiMHgwMFwiKSB7XG4gICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWUuc3Vic3RyaW5nKDQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB0b0JpZ051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh0b0hleCh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gdG9CTih2YWx1ZSkge1xuICAgIGNvbnN0IGhleCA9IEJpZ051bWJlci5mcm9tKHZhbHVlKS50b0hleFN0cmluZygpO1xuICAgIGlmIChoZXhbMF0gPT09IFwiLVwiKSB7XG4gICAgICAgIHJldHVybiAobmV3IEJOKFwiLVwiICsgaGV4LnN1YnN0cmluZygzKSwgMTYpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCTihoZXguc3Vic3RyaW5nKDIpLCAxNik7XG59XG5mdW5jdGlvbiB0aHJvd0ZhdWx0KGZhdWx0LCBvcGVyYXRpb24sIHZhbHVlKSB7XG4gICAgY29uc3QgcGFyYW1zID0geyBmYXVsdDogZmF1bHQsIG9wZXJhdGlvbjogb3BlcmF0aW9uIH07XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcGFyYW1zLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihmYXVsdCwgTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULCBwYXJhbXMpO1xufVxuLy8gdmFsdWUgc2hvdWxkIGhhdmUgbm8gcHJlZml4XG5leHBvcnQgZnVuY3Rpb24gX2Jhc2UzNlRvMTYodmFsdWUpIHtcbiAgICByZXR1cm4gKG5ldyBCTih2YWx1ZSwgMzYpKS50b1N0cmluZygxNik7XG59XG4vLyB2YWx1ZSBzaG91bGQgaGF2ZSBubyBwcmVmaXhcbmV4cG9ydCBmdW5jdGlvbiBfYmFzZTE2VG8zNih2YWx1ZSkge1xuICAgIHJldHVybiAobmV3IEJOKHZhbHVlLCAxNikpLnRvU3RyaW5nKDM2KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpZ251bWJlci5qcy5tYXAiXSwibmFtZXMiOlsiX0JOIiwiQk4iLCJoZXhsaWZ5IiwiaXNCeXRlcyIsImlzSGV4U3RyaW5nIiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsIl9jb25zdHJ1Y3Rvckd1YXJkIiwiTUFYX1NBRkUiLCJpc0JpZ051bWJlcmlzaCIsInZhbHVlIiwiQmlnTnVtYmVyIiwiaXNCaWdOdW1iZXIiLCJtYXRjaCIsIl93YXJuZWRUb1N0cmluZ1JhZGl4IiwiY29uc3RydWN0b3IiLCJjb25zdHJ1Y3Rvckd1YXJkIiwiaGV4IiwidGhyb3dFcnJvciIsImVycm9ycyIsIlVOU1VQUE9SVEVEX09QRVJBVElPTiIsIm9wZXJhdGlvbiIsIl9oZXgiLCJfaXNCaWdOdW1iZXIiLCJPYmplY3QiLCJmcmVlemUiLCJmcm9tVHdvcyIsInRvQmlnTnVtYmVyIiwidG9CTiIsInRvVHdvcyIsImFicyIsImZyb20iLCJzdWJzdHJpbmciLCJhZGQiLCJvdGhlciIsInN1YiIsImRpdiIsIm8iLCJpc1plcm8iLCJ0aHJvd0ZhdWx0IiwibXVsIiwibW9kIiwiaXNOZWciLCJ1bW9kIiwicG93IiwiYW5kIiwiaXNOZWdhdGl2ZSIsIm9yIiwieG9yIiwibWFzayIsIm1hc2tuIiwic2hsIiwic2hsbiIsInNociIsInNocm4iLCJlcSIsImx0IiwibHRlIiwiZ3QiLCJndGUiLCJ0b051bWJlciIsImVycm9yIiwidG9TdHJpbmciLCJ0b0JpZ0ludCIsIkJpZ0ludCIsImUiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ3YXJuIiwiVU5FWFBFQ1RFRF9BUkdVTUVOVCIsInRvSGV4U3RyaW5nIiwidG9KU09OIiwia2V5IiwidHlwZSIsInRvSGV4IiwidGhyb3dBcmd1bWVudEVycm9yIiwiU3RyaW5nIiwiYW55VmFsdWUiLCJmYXVsdCIsInBhcmFtcyIsIk5VTUVSSUNfRkFVTFQiLCJfYmFzZTM2VG8xNiIsIl9iYXNlMTZUbzM2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedFormat: () => (/* binding */ FixedFormat),\n/* harmony export */   FixedNumber: () => (/* binding */ FixedNumber),\n/* harmony export */   formatFixed: () => (/* binding */ formatFixed),\n/* harmony export */   parseFixed: () => (/* binding */ parseFixed)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/_version.js\");\n/* harmony import */ var _bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst _constructorGuard = {};\nconst Zero = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(0);\nconst NegativeOne = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(-1);\nfunction throwFault(message, fault, operation, value) {\n    const params = {\n        fault: fault,\n        operation: operation\n    };\n    if (value !== undefined) {\n        params.value = value;\n    }\n    return logger.throwError(message, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NUMERIC_FAULT, params);\n}\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile(zeros.length < 256){\n    zeros += zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals) {\n    if (typeof decimals !== \"number\") {\n        try {\n            decimals = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(decimals).toNumber();\n        } catch (e) {}\n    }\n    if (typeof decimals === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return \"1\" + zeros.substring(0, decimals);\n    }\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\nfunction formatFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    // Make sure wei is a big number (convert as necessary)\n    value = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value);\n    const negative = value.lt(Zero);\n    if (negative) {\n        value = value.mul(NegativeOne);\n    }\n    let fraction = value.mod(multiplier).toString();\n    while(fraction.length < multiplier.length - 1){\n        fraction = \"0\" + fraction;\n    }\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n    const whole = value.div(multiplier).toString();\n    if (multiplier.length === 1) {\n        value = whole;\n    } else {\n        value = whole + \".\" + fraction;\n    }\n    if (negative) {\n        value = \"-\" + value;\n    }\n    return value;\n}\nfunction parseFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    if (typeof value !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n    // Is it negative?\n    const negative = value.substring(0, 1) === \"-\";\n    if (negative) {\n        value = value.substring(1);\n    }\n    if (value === \".\") {\n        logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n    // Split it into a whole and fractional part\n    const comps = value.split(\".\");\n    if (comps.length > 2) {\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n    let whole = comps[0], fraction = comps[1];\n    if (!whole) {\n        whole = \"0\";\n    }\n    if (!fraction) {\n        fraction = \"0\";\n    }\n    // Trim trailing zeros\n    while(fraction[fraction.length - 1] === \"0\"){\n        fraction = fraction.substring(0, fraction.length - 1);\n    }\n    // Check the fraction doesn't exceed our decimals size\n    if (fraction.length > multiplier.length - 1) {\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n    // If decimals is 0, we have an empty string for fraction\n    if (fraction === \"\") {\n        fraction = \"0\";\n    }\n    // Fully pad the string with zeros to get to wei\n    while(fraction.length < multiplier.length - 1){\n        fraction += \"0\";\n    }\n    const wholeValue = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(whole);\n    const fractionValue = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(fraction);\n    let wei = wholeValue.mul(multiplier).add(fractionValue);\n    if (negative) {\n        wei = wei.mul(NegativeOne);\n    }\n    return wei;\n}\nclass FixedFormat {\n    constructor(constructorGuard, signed, width, decimals){\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n        this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n        this._multiplier = getMultiplier(decimals);\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (value instanceof FixedFormat) {\n            return value;\n        }\n        if (typeof value === \"number\") {\n            value = `fixed128x${value}`;\n        }\n        let signed = true;\n        let width = 128;\n        let decimals = 18;\n        if (typeof value === \"string\") {\n            if (value === \"fixed\") {\n            // defaults...\n            } else if (value === \"ufixed\") {\n                signed = false;\n            } else {\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) {\n                    logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n                }\n                signed = match[1] !== \"u\";\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        } else if (value) {\n            const check = (key, type, defaultValue)=>{\n                if (value[key] == null) {\n                    return defaultValue;\n                }\n                if (typeof value[key] !== type) {\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            };\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n        if (decimals > 80) {\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n}\nclass FixedNumber {\n    constructor(constructorGuard, hex, value, format){\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n        this._isFixedNumber = true;\n        Object.freeze(this);\n    }\n    _checkFormat(other) {\n        if (this.format.name !== other.format.name) {\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    }\n    addUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n    subUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n    mulUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n    divUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n    floor() {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        let result = FixedNumber.from(comps[0], this.format);\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (this.isNegative() && hasFraction) {\n            result = result.subUnsafe(ONE.toFormat(result.format));\n        }\n        return result;\n    }\n    ceiling() {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        let result = FixedNumber.from(comps[0], this.format);\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (!this.isNegative() && hasFraction) {\n            result = result.addUnsafe(ONE.toFormat(result.format));\n        }\n        return result;\n    }\n    // @TODO: Support other rounding algorithms\n    round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // If we are already in range, we're done\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        if (decimals < 0 || decimals > 80 || decimals % 1) {\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n        if (comps[1].length <= decimals) {\n            return this;\n        }\n        const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n        const bump = BUMP.toFormat(this.format);\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n    }\n    isZero() {\n        return this._value === \"0.0\" || this._value === \"0\";\n    }\n    isNegative() {\n        return this._value[0] === \"-\";\n    }\n    toString() {\n        return this._value;\n    }\n    toHexString(width) {\n        if (width == null) {\n            return this._hex;\n        }\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n        }\n        const hex = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(hex, width / 8);\n    }\n    toUnsafeFloat() {\n        return parseFloat(this.toString());\n    }\n    toFormat(format) {\n        return FixedNumber.fromString(this._value, format);\n    }\n    static fromValue(value, decimals, format) {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !(0,_bignumber__WEBPACK_IMPORTED_MODULE_2__.isBigNumberish)(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n        if (decimals == null) {\n            decimals = 0;\n        }\n        if (format == null) {\n            format = \"fixed\";\n        }\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n    static fromString(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        const numeric = parseFixed(value, fixedFormat.decimals);\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n        let hex = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        } else {\n            hex = numeric.toHexString();\n            hex = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(hex, fixedFormat.width / 8);\n        }\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static fromBytes(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n        let numeric = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value);\n        if (fixedFormat.signed) {\n            numeric = numeric.fromTwos(fixedFormat.width);\n        }\n        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static from(value, format) {\n        if (typeof value === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isBytes)(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        } catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n    static isFixedNumber(value) {\n        return !!(value && value._isFixedNumber);\n    }\n}\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\"); //# sourceMappingURL=fixednumber.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyL2xpYi5lc20vZml4ZWRudW1iZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBYTtBQUN3RDtBQUN0QjtBQUNWO0FBQ3JDLE1BQU1LLFNBQVMsSUFBSUYseURBQU1BLENBQUNDLDZDQUFPQTtBQUN1QjtBQUN4RCxNQUFNSSxvQkFBb0IsQ0FBQztBQUMzQixNQUFNQyxPQUFPSCxpREFBU0EsQ0FBQ0ksSUFBSSxDQUFDO0FBQzVCLE1BQU1DLGNBQWNMLGlEQUFTQSxDQUFDSSxJQUFJLENBQUMsQ0FBQztBQUNwQyxTQUFTRSxXQUFXQyxPQUFPLEVBQUVDLEtBQUssRUFBRUMsU0FBUyxFQUFFQyxLQUFLO0lBQ2hELE1BQU1DLFNBQVM7UUFBRUgsT0FBT0E7UUFBT0MsV0FBV0E7SUFBVTtJQUNwRCxJQUFJQyxVQUFVRSxXQUFXO1FBQ3JCRCxPQUFPRCxLQUFLLEdBQUdBO0lBQ25CO0lBQ0EsT0FBT1gsT0FBT2MsVUFBVSxDQUFDTixTQUFTVix5REFBTUEsQ0FBQ2lCLE1BQU0sQ0FBQ0MsYUFBYSxFQUFFSjtBQUNuRTtBQUNBLDhDQUE4QztBQUM5QyxJQUFJSyxRQUFRO0FBQ1osTUFBT0EsTUFBTUMsTUFBTSxHQUFHLElBQUs7SUFDdkJELFNBQVNBO0FBQ2I7QUFDQSxnREFBZ0Q7QUFDaEQsU0FBU0UsY0FBY0MsUUFBUTtJQUMzQixJQUFJLE9BQVFBLGFBQWMsVUFBVTtRQUNoQyxJQUFJO1lBQ0FBLFdBQVduQixpREFBU0EsQ0FBQ0ksSUFBSSxDQUFDZSxVQUFVQyxRQUFRO1FBQ2hELEVBQ0EsT0FBT0MsR0FBRyxDQUFFO0lBQ2hCO0lBQ0EsSUFBSSxPQUFRRixhQUFjLFlBQVlBLFlBQVksS0FBS0EsWUFBWSxPQUFPLENBQUVBLENBQUFBLFdBQVcsSUFBSTtRQUN2RixPQUFRLE1BQU1ILE1BQU1NLFNBQVMsQ0FBQyxHQUFHSDtJQUNyQztJQUNBLE9BQU9wQixPQUFPd0Isa0JBQWtC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SjtBQUNBLE1BQU1nQixNQUFNckIsWUFBWXRELElBQUksQ0FBQztBQUM3QixNQUFNaUYsT0FBTzNCLFlBQVl0RCxJQUFJLENBQUMsUUFDOUIsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1zdGFydGVyLWtpdC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iaWdudW1iZXIvbGliLmVzbS9maXhlZG51bWJlci5qcz83NWRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleFplcm9QYWQsIGlzQnl0ZXMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IEJpZ051bWJlciwgaXNCaWdOdW1iZXJpc2ggfSBmcm9tIFwiLi9iaWdudW1iZXJcIjtcbmNvbnN0IF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5jb25zdCBaZXJvID0gQmlnTnVtYmVyLmZyb20oMCk7XG5jb25zdCBOZWdhdGl2ZU9uZSA9IEJpZ051bWJlci5mcm9tKC0xKTtcbmZ1bmN0aW9uIHRocm93RmF1bHQobWVzc2FnZSwgZmF1bHQsIG9wZXJhdGlvbiwgdmFsdWUpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7IGZhdWx0OiBmYXVsdCwgb3BlcmF0aW9uOiBvcGVyYXRpb24gfTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJhbXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwgcGFyYW1zKTtcbn1cbi8vIENvbnN0YW50IHRvIHB1bGwgemVyb3MgZnJvbSBmb3IgbXVsdGlwbGllcnNcbmxldCB6ZXJvcyA9IFwiMFwiO1xud2hpbGUgKHplcm9zLmxlbmd0aCA8IDI1Nikge1xuICAgIHplcm9zICs9IHplcm9zO1xufVxuLy8gUmV0dXJucyBhIHN0cmluZyBcIjFcIiBmb2xsb3dlZCBieSBkZWNpbWFsIFwiMFwic1xuZnVuY3Rpb24gZ2V0TXVsdGlwbGllcihkZWNpbWFscykge1xuICAgIGlmICh0eXBlb2YgKGRlY2ltYWxzKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVjaW1hbHMgPSBCaWdOdW1iZXIuZnJvbShkZWNpbWFscykudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKGRlY2ltYWxzKSA9PT0gXCJudW1iZXJcIiAmJiBkZWNpbWFscyA+PSAwICYmIGRlY2ltYWxzIDw9IDI1NiAmJiAhKGRlY2ltYWxzICUgMSkpIHtcbiAgICAgICAgcmV0dXJuIChcIjFcIiArIHplcm9zLnN1YnN0cmluZygwLCBkZWNpbWFscykpO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZGVjaW1hbCBzaXplXCIsIFwiZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEZpeGVkKHZhbHVlLCBkZWNpbWFscykge1xuICAgIGlmIChkZWNpbWFscyA9PSBudWxsKSB7XG4gICAgICAgIGRlY2ltYWxzID0gMDtcbiAgICB9XG4gICAgY29uc3QgbXVsdGlwbGllciA9IGdldE11bHRpcGxpZXIoZGVjaW1hbHMpO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZWkgaXMgYSBiaWcgbnVtYmVyIChjb252ZXJ0IGFzIG5lY2Vzc2FyeSlcbiAgICB2YWx1ZSA9IEJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICBjb25zdCBuZWdhdGl2ZSA9IHZhbHVlLmx0KFplcm8pO1xuICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLm11bChOZWdhdGl2ZU9uZSk7XG4gICAgfVxuICAgIGxldCBmcmFjdGlvbiA9IHZhbHVlLm1vZChtdWx0aXBsaWVyKS50b1N0cmluZygpO1xuICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCBtdWx0aXBsaWVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgZnJhY3Rpb24gPSBcIjBcIiArIGZyYWN0aW9uO1xuICAgIH1cbiAgICAvLyBTdHJpcCB0cmFpbmluZyAwXG4gICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5tYXRjaCgvXihbMC05XSpbMS05XXwwKSgwKikvKVsxXTtcbiAgICBjb25zdCB3aG9sZSA9IHZhbHVlLmRpdihtdWx0aXBsaWVyKS50b1N0cmluZygpO1xuICAgIGlmIChtdWx0aXBsaWVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YWx1ZSA9IHdob2xlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB3aG9sZSArIFwiLlwiICsgZnJhY3Rpb247XG4gICAgfVxuICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICB2YWx1ZSA9IFwiLVwiICsgdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZpeGVkKHZhbHVlLCBkZWNpbWFscykge1xuICAgIGlmIChkZWNpbWFscyA9PSBudWxsKSB7XG4gICAgICAgIGRlY2ltYWxzID0gMDtcbiAgICB9XG4gICAgY29uc3QgbXVsdGlwbGllciA9IGdldE11bHRpcGxpZXIoZGVjaW1hbHMpO1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUubWF0Y2goL14tP1swLTkuXSskLykpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZGVjaW1hbCB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gSXMgaXQgbmVnYXRpdmU/XG4gICAgY29uc3QgbmVnYXRpdmUgPSAodmFsdWUuc3Vic3RyaW5nKDAsIDEpID09PSBcIi1cIik7XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IFwiLlwiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBTcGxpdCBpdCBpbnRvIGEgd2hvbGUgYW5kIGZyYWN0aW9uYWwgcGFydFxuICAgIGNvbnN0IGNvbXBzID0gdmFsdWUuc3BsaXQoXCIuXCIpO1xuICAgIGlmIChjb21wcy5sZW5ndGggPiAyKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0b28gbWFueSBkZWNpbWFsIHBvaW50c1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgbGV0IHdob2xlID0gY29tcHNbMF0sIGZyYWN0aW9uID0gY29tcHNbMV07XG4gICAgaWYgKCF3aG9sZSkge1xuICAgICAgICB3aG9sZSA9IFwiMFwiO1xuICAgIH1cbiAgICBpZiAoIWZyYWN0aW9uKSB7XG4gICAgICAgIGZyYWN0aW9uID0gXCIwXCI7XG4gICAgfVxuICAgIC8vIFRyaW0gdHJhaWxpbmcgemVyb3NcbiAgICB3aGlsZSAoZnJhY3Rpb25bZnJhY3Rpb24ubGVuZ3RoIC0gMV0gPT09IFwiMFwiKSB7XG4gICAgICAgIGZyYWN0aW9uID0gZnJhY3Rpb24uc3Vic3RyaW5nKDAsIGZyYWN0aW9uLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICAvLyBDaGVjayB0aGUgZnJhY3Rpb24gZG9lc24ndCBleGNlZWQgb3VyIGRlY2ltYWxzIHNpemVcbiAgICBpZiAoZnJhY3Rpb24ubGVuZ3RoID4gbXVsdGlwbGllci5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRocm93RmF1bHQoXCJmcmFjdGlvbmFsIGNvbXBvbmVudCBleGNlZWRzIGRlY2ltYWxzXCIsIFwidW5kZXJmbG93XCIsIFwicGFyc2VGaXhlZFwiKTtcbiAgICB9XG4gICAgLy8gSWYgZGVjaW1hbHMgaXMgMCwgd2UgaGF2ZSBhbiBlbXB0eSBzdHJpbmcgZm9yIGZyYWN0aW9uXG4gICAgaWYgKGZyYWN0aW9uID09PSBcIlwiKSB7XG4gICAgICAgIGZyYWN0aW9uID0gXCIwXCI7XG4gICAgfVxuICAgIC8vIEZ1bGx5IHBhZCB0aGUgc3RyaW5nIHdpdGggemVyb3MgdG8gZ2V0IHRvIHdlaVxuICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPCBtdWx0aXBsaWVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgZnJhY3Rpb24gKz0gXCIwXCI7XG4gICAgfVxuICAgIGNvbnN0IHdob2xlVmFsdWUgPSBCaWdOdW1iZXIuZnJvbSh3aG9sZSk7XG4gICAgY29uc3QgZnJhY3Rpb25WYWx1ZSA9IEJpZ051bWJlci5mcm9tKGZyYWN0aW9uKTtcbiAgICBsZXQgd2VpID0gKHdob2xlVmFsdWUubXVsKG11bHRpcGxpZXIpKS5hZGQoZnJhY3Rpb25WYWx1ZSk7XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIHdlaSA9IHdlaS5tdWwoTmVnYXRpdmVPbmUpO1xuICAgIH1cbiAgICByZXR1cm4gd2VpO1xufVxuZXhwb3J0IGNsYXNzIEZpeGVkRm9ybWF0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLCBzaWduZWQsIHdpZHRoLCBkZWNpbWFscykge1xuICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHVzZSBGaXhlZEZvcm1hdCBjb25zdHJ1Y3RvcjsgdXNlIEZpeGVkRm9ybWF0LmZyb21cIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IEZpeGVkRm9ybWF0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2lnbmVkID0gc2lnbmVkO1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuZGVjaW1hbHMgPSBkZWNpbWFscztcbiAgICAgICAgdGhpcy5uYW1lID0gKHNpZ25lZCA/IFwiXCIgOiBcInVcIikgKyBcImZpeGVkXCIgKyBTdHJpbmcod2lkdGgpICsgXCJ4XCIgKyBTdHJpbmcoZGVjaW1hbHMpO1xuICAgICAgICB0aGlzLl9tdWx0aXBsaWVyID0gZ2V0TXVsdGlwbGllcihkZWNpbWFscyk7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZpeGVkRm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGBmaXhlZDEyOHgke3ZhbHVlfWA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZ25lZCA9IHRydWU7XG4gICAgICAgIGxldCB3aWR0aCA9IDEyODtcbiAgICAgICAgbGV0IGRlY2ltYWxzID0gMTg7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcImZpeGVkXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0cy4uLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IFwidWZpeGVkXCIpIHtcbiAgICAgICAgICAgICAgICBzaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdmFsdWUubWF0Y2goL14odT8pZml4ZWQoWzAtOV0rKXgoWzAtOV0rKSQvKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZpeGVkIGZvcm1hdFwiLCBcImZvcm1hdFwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpZ25lZCA9IChtYXRjaFsxXSAhPT0gXCJ1XCIpO1xuICAgICAgICAgICAgICAgIHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgICAgIGRlY2ltYWxzID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGVjayA9IChrZXksIHR5cGUsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWVba2V5XSkgIT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0IChcIiArIGtleSArIFwiIG5vdCBcIiArIHR5cGUgKyBcIilcIiwgXCJmb3JtYXQuXCIgKyBrZXksIHZhbHVlW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVba2V5XTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzaWduZWQgPSBjaGVjayhcInNpZ25lZFwiLCBcImJvb2xlYW5cIiwgc2lnbmVkKTtcbiAgICAgICAgICAgIHdpZHRoID0gY2hlY2soXCJ3aWR0aFwiLCBcIm51bWJlclwiLCB3aWR0aCk7XG4gICAgICAgICAgICBkZWNpbWFscyA9IGNoZWNrKFwiZGVjaW1hbHNcIiwgXCJudW1iZXJcIiwgZGVjaW1hbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aWR0aCAlIDgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZpeGVkIGZvcm1hdCB3aWR0aCAobm90IGJ5dGUgYWxpZ25lZClcIiwgXCJmb3JtYXQud2lkdGhcIiwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWNpbWFscyA+IDgwKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmaXhlZCBmb3JtYXQgKGRlY2ltYWxzIHRvbyBsYXJnZSlcIiwgXCJmb3JtYXQuZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWRGb3JtYXQoX2NvbnN0cnVjdG9yR3VhcmQsIHNpZ25lZCwgd2lkdGgsIGRlY2ltYWxzKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRml4ZWROdW1iZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsIGhleCwgdmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHVzZSBGaXhlZE51bWJlciBjb25zdHJ1Y3RvcjsgdXNlIEZpeGVkTnVtYmVyLmZyb21cIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IEZpeGVkRm9ybWF0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgICB0aGlzLl9oZXggPSBoZXg7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2lzRml4ZWROdW1iZXIgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBfY2hlY2tGb3JtYXQob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0Lm5hbWUgIT09IG90aGVyLmZvcm1hdC5uYW1lKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW5jb21wYXRpYmxlIGZvcm1hdDsgdXNlIGZpeGVkTnVtYmVyLnRvRm9ybWF0XCIsIFwib3RoZXJcIiwgb3RoZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFVuc2FmZShvdGhlcikge1xuICAgICAgICB0aGlzLl9jaGVja0Zvcm1hdChvdGhlcik7XG4gICAgICAgIGNvbnN0IGEgPSBwYXJzZUZpeGVkKHRoaXMuX3ZhbHVlLCB0aGlzLmZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIGNvbnN0IGIgPSBwYXJzZUZpeGVkKG90aGVyLl92YWx1ZSwgb3RoZXIuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZShhLmFkZChiKSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMsIHRoaXMuZm9ybWF0KTtcbiAgICB9XG4gICAgc3ViVW5zYWZlKG90aGVyKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrRm9ybWF0KG90aGVyKTtcbiAgICAgICAgY29uc3QgYSA9IHBhcnNlRml4ZWQodGhpcy5fdmFsdWUsIHRoaXMuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgY29uc3QgYiA9IHBhcnNlRml4ZWQob3RoZXIuX3ZhbHVlLCBvdGhlci5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKGEuc3ViKGIpLCB0aGlzLmZvcm1hdC5kZWNpbWFscywgdGhpcy5mb3JtYXQpO1xuICAgIH1cbiAgICBtdWxVbnNhZmUob3RoZXIpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICBjb25zdCBhID0gcGFyc2VGaXhlZCh0aGlzLl92YWx1ZSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCBiID0gcGFyc2VGaXhlZChvdGhlci5fdmFsdWUsIG90aGVyLmZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUoYS5tdWwoYikuZGl2KHRoaXMuZm9ybWF0Ll9tdWx0aXBsaWVyKSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMsIHRoaXMuZm9ybWF0KTtcbiAgICB9XG4gICAgZGl2VW5zYWZlKG90aGVyKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrRm9ybWF0KG90aGVyKTtcbiAgICAgICAgY29uc3QgYSA9IHBhcnNlRml4ZWQodGhpcy5fdmFsdWUsIHRoaXMuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgY29uc3QgYiA9IHBhcnNlRml4ZWQob3RoZXIuX3ZhbHVlLCBvdGhlci5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKGEubXVsKHRoaXMuZm9ybWF0Ll9tdWx0aXBsaWVyKS5kaXYoYiksIHRoaXMuZm9ybWF0LmRlY2ltYWxzLCB0aGlzLmZvcm1hdCk7XG4gICAgfVxuICAgIGZsb29yKCkge1xuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudG9TdHJpbmcoKS5zcGxpdChcIi5cIik7XG4gICAgICAgIGlmIChjb21wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbXBzLnB1c2goXCIwXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBGaXhlZE51bWJlci5mcm9tKGNvbXBzWzBdLCB0aGlzLmZvcm1hdCk7XG4gICAgICAgIGNvbnN0IGhhc0ZyYWN0aW9uID0gIWNvbXBzWzFdLm1hdGNoKC9eKDAqKSQvKTtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpICYmIGhhc0ZyYWN0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc3ViVW5zYWZlKE9ORS50b0Zvcm1hdChyZXN1bHQuZm9ybWF0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2VpbGluZygpIHtcbiAgICAgICAgY29uc3QgY29tcHMgPSB0aGlzLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpO1xuICAgICAgICBpZiAoY29tcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb21wcy5wdXNoKFwiMFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gRml4ZWROdW1iZXIuZnJvbShjb21wc1swXSwgdGhpcy5mb3JtYXQpO1xuICAgICAgICBjb25zdCBoYXNGcmFjdGlvbiA9ICFjb21wc1sxXS5tYXRjaCgvXigwKikkLyk7XG4gICAgICAgIGlmICghdGhpcy5pc05lZ2F0aXZlKCkgJiYgaGFzRnJhY3Rpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGRVbnNhZmUoT05FLnRvRm9ybWF0KHJlc3VsdC5mb3JtYXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBAVE9ETzogU3VwcG9ydCBvdGhlciByb3VuZGluZyBhbGdvcml0aG1zXG4gICAgcm91bmQoZGVjaW1hbHMpIHtcbiAgICAgICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBpbiByYW5nZSwgd2UncmUgZG9uZVxuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudG9TdHJpbmcoKS5zcGxpdChcIi5cIik7XG4gICAgICAgIGlmIChjb21wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbXBzLnB1c2goXCIwXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWNpbWFscyA8IDAgfHwgZGVjaW1hbHMgPiA4MCB8fCAoZGVjaW1hbHMgJSAxKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZGVjaW1hbCBjb3VudFwiLCBcImRlY2ltYWxzXCIsIGRlY2ltYWxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHNbMV0ubGVuZ3RoIDw9IGRlY2ltYWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWN0b3IgPSBGaXhlZE51bWJlci5mcm9tKFwiMVwiICsgemVyb3Muc3Vic3RyaW5nKDAsIGRlY2ltYWxzKSwgdGhpcy5mb3JtYXQpO1xuICAgICAgICBjb25zdCBidW1wID0gQlVNUC50b0Zvcm1hdCh0aGlzLmZvcm1hdCk7XG4gICAgICAgIHJldHVybiB0aGlzLm11bFVuc2FmZShmYWN0b3IpLmFkZFVuc2FmZShidW1wKS5mbG9vcigpLmRpdlVuc2FmZShmYWN0b3IpO1xuICAgIH1cbiAgICBpc1plcm8oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fdmFsdWUgPT09IFwiMC4wXCIgfHwgdGhpcy5fdmFsdWUgPT09IFwiMFwiKTtcbiAgICB9XG4gICAgaXNOZWdhdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl92YWx1ZVswXSA9PT0gXCItXCIpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9XG4gICAgdG9IZXhTdHJpbmcod2lkdGgpIHtcbiAgICAgICAgaWYgKHdpZHRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZHRoICUgOCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYnl0ZSB3aWR0aFwiLCBcIndpZHRoXCIsIHdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZXggPSBCaWdOdW1iZXIuZnJvbSh0aGlzLl9oZXgpLmZyb21Ud29zKHRoaXMuZm9ybWF0LndpZHRoKS50b1R3b3Mod2lkdGgpLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBoZXhaZXJvUGFkKGhleCwgd2lkdGggLyA4KTtcbiAgICB9XG4gICAgdG9VbnNhZmVGbG9hdCgpIHsgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy50b1N0cmluZygpKTsgfVxuICAgIHRvRm9ybWF0KGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyh0aGlzLl92YWx1ZSwgZm9ybWF0KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21WYWx1ZSh2YWx1ZSwgZGVjaW1hbHMsIGZvcm1hdCkge1xuICAgICAgICAvLyBJZiBkZWNpbWFscyBsb29rcyBtb3JlIGxpa2UgYSBmb3JtYXQsIGFuZCB0aGVyZSBpcyBubyBmb3JtYXQsIHNoaWZ0IHRoZSBwYXJhbWV0ZXJzXG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCAmJiBkZWNpbWFscyAhPSBudWxsICYmICFpc0JpZ051bWJlcmlzaChkZWNpbWFscykpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGRlY2ltYWxzO1xuICAgICAgICAgICAgZGVjaW1hbHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWNpbWFscyA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWNpbWFscyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcImZpeGVkXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcoZm9ybWF0Rml4ZWQodmFsdWUsIGRlY2ltYWxzKSwgRml4ZWRGb3JtYXQuZnJvbShmb3JtYXQpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiZml4ZWRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXhlZEZvcm1hdCA9IEZpeGVkRm9ybWF0LmZyb20oZm9ybWF0KTtcbiAgICAgICAgY29uc3QgbnVtZXJpYyA9IHBhcnNlRml4ZWQodmFsdWUsIGZpeGVkRm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgaWYgKCFmaXhlZEZvcm1hdC5zaWduZWQgJiYgbnVtZXJpYy5sdChaZXJvKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuc2lnbmVkIHZhbHVlIGNhbm5vdCBiZSBuZWdhdGl2ZVwiLCBcIm92ZXJmbG93XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBoZXggPSBudWxsO1xuICAgICAgICBpZiAoZml4ZWRGb3JtYXQuc2lnbmVkKSB7XG4gICAgICAgICAgICBoZXggPSBudW1lcmljLnRvVHdvcyhmaXhlZEZvcm1hdC53aWR0aCkudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhleCA9IG51bWVyaWMudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgICAgIGhleCA9IGhleFplcm9QYWQoaGV4LCBmaXhlZEZvcm1hdC53aWR0aCAvIDgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlY2ltYWwgPSBmb3JtYXRGaXhlZChudW1lcmljLCBmaXhlZEZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2NvbnN0cnVjdG9yR3VhcmQsIGhleCwgZGVjaW1hbCwgZml4ZWRGb3JtYXQpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKHZhbHVlLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcImZpeGVkXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZml4ZWRGb3JtYXQgPSBGaXhlZEZvcm1hdC5mcm9tKGZvcm1hdCk7XG4gICAgICAgIGlmIChhcnJheWlmeSh2YWx1ZSkubGVuZ3RoID4gZml4ZWRGb3JtYXQud2lkdGggLyA4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdmVyZmxvd1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtZXJpYyA9IEJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICAgICAgaWYgKGZpeGVkRm9ybWF0LnNpZ25lZCkge1xuICAgICAgICAgICAgbnVtZXJpYyA9IG51bWVyaWMuZnJvbVR3b3MoZml4ZWRGb3JtYXQud2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhleCA9IG51bWVyaWMudG9Ud29zKChmaXhlZEZvcm1hdC5zaWduZWQgPyAwIDogMSkgKyBmaXhlZEZvcm1hdC53aWR0aCkudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgY29uc3QgZGVjaW1hbCA9IGZvcm1hdEZpeGVkKG51bWVyaWMsIGZpeGVkRm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfY29uc3RydWN0b3JHdWFyZCwgaGV4LCBkZWNpbWFsLCBmaXhlZEZvcm1hdCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZhbHVlLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyh2YWx1ZSwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCeXRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tQnl0ZXModmFsdWUsIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUodmFsdWUsIDAsIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBBbGxvdyBOVU1FUklDX0ZBVUxUIHRvIGJ1YmJsZSB1cFxuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgIT09IExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBGaXhlZE51bWJlciB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGlzRml4ZWROdW1iZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0ZpeGVkTnVtYmVyKTtcbiAgICB9XG59XG5jb25zdCBPTkUgPSBGaXhlZE51bWJlci5mcm9tKDEpO1xuY29uc3QgQlVNUCA9IEZpeGVkTnVtYmVyLmZyb20oXCIwLjVcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXhlZG51bWJlci5qcy5tYXAiXSwibmFtZXMiOlsiYXJyYXlpZnkiLCJoZXhaZXJvUGFkIiwiaXNCeXRlcyIsIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJCaWdOdW1iZXIiLCJpc0JpZ051bWJlcmlzaCIsIl9jb25zdHJ1Y3Rvckd1YXJkIiwiWmVybyIsImZyb20iLCJOZWdhdGl2ZU9uZSIsInRocm93RmF1bHQiLCJtZXNzYWdlIiwiZmF1bHQiLCJvcGVyYXRpb24iLCJ2YWx1ZSIsInBhcmFtcyIsInVuZGVmaW5lZCIsInRocm93RXJyb3IiLCJlcnJvcnMiLCJOVU1FUklDX0ZBVUxUIiwiemVyb3MiLCJsZW5ndGgiLCJnZXRNdWx0aXBsaWVyIiwiZGVjaW1hbHMiLCJ0b051bWJlciIsImUiLCJzdWJzdHJpbmciLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJmb3JtYXRGaXhlZCIsIm11bHRpcGxpZXIiLCJuZWdhdGl2ZSIsImx0IiwibXVsIiwiZnJhY3Rpb24iLCJtb2QiLCJ0b1N0cmluZyIsIm1hdGNoIiwid2hvbGUiLCJkaXYiLCJwYXJzZUZpeGVkIiwiY29tcHMiLCJzcGxpdCIsIndob2xlVmFsdWUiLCJmcmFjdGlvblZhbHVlIiwid2VpIiwiYWRkIiwiRml4ZWRGb3JtYXQiLCJjb25zdHJ1Y3RvciIsImNvbnN0cnVjdG9yR3VhcmQiLCJzaWduZWQiLCJ3aWR0aCIsIlVOU1VQUE9SVEVEX09QRVJBVElPTiIsIm5hbWUiLCJTdHJpbmciLCJfbXVsdGlwbGllciIsIk9iamVjdCIsImZyZWV6ZSIsInBhcnNlSW50IiwiY2hlY2siLCJrZXkiLCJ0eXBlIiwiZGVmYXVsdFZhbHVlIiwiRml4ZWROdW1iZXIiLCJoZXgiLCJmb3JtYXQiLCJfaGV4IiwiX3ZhbHVlIiwiX2lzRml4ZWROdW1iZXIiLCJfY2hlY2tGb3JtYXQiLCJvdGhlciIsImFkZFVuc2FmZSIsImEiLCJiIiwiZnJvbVZhbHVlIiwic3ViVW5zYWZlIiwic3ViIiwibXVsVW5zYWZlIiwiZGl2VW5zYWZlIiwiZmxvb3IiLCJwdXNoIiwicmVzdWx0IiwiaGFzRnJhY3Rpb24iLCJpc05lZ2F0aXZlIiwiT05FIiwidG9Gb3JtYXQiLCJjZWlsaW5nIiwicm91bmQiLCJmYWN0b3IiLCJidW1wIiwiQlVNUCIsImlzWmVybyIsInRvSGV4U3RyaW5nIiwiZnJvbVR3b3MiLCJ0b1R3b3MiLCJ0b1Vuc2FmZUZsb2F0IiwicGFyc2VGbG9hdCIsImZyb21TdHJpbmciLCJmaXhlZEZvcm1hdCIsIm51bWVyaWMiLCJkZWNpbWFsIiwiZnJvbUJ5dGVzIiwiRXJyb3IiLCJlcnJvciIsImNvZGUiLCJJTlZBTElEX0FSR1VNRU5UIiwiaXNGaXhlZE51bWJlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/bytes/lib.esm/_version.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ethersproject/bytes/lib.esm/_version.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"bytes/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYnl0ZXMvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSxjQUFjLENBQ3JDLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYnl0ZXMvbGliLmVzbS9fdmVyc2lvbi5qcz82OTkwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJieXRlcy81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/bytes/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@ethersproject/bytes/lib.esm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayify: () => (/* binding */ arrayify),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   hexConcat: () => (/* binding */ hexConcat),\n/* harmony export */   hexDataLength: () => (/* binding */ hexDataLength),\n/* harmony export */   hexDataSlice: () => (/* binding */ hexDataSlice),\n/* harmony export */   hexStripZeros: () => (/* binding */ hexStripZeros),\n/* harmony export */   hexValue: () => (/* binding */ hexValue),\n/* harmony export */   hexZeroPad: () => (/* binding */ hexZeroPad),\n/* harmony export */   hexlify: () => (/* binding */ hexlify),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isBytesLike: () => (/* binding */ isBytesLike),\n/* harmony export */   isHexString: () => (/* binding */ isHexString),\n/* harmony export */   joinSignature: () => (/* binding */ joinSignature),\n/* harmony export */   splitSignature: () => (/* binding */ splitSignature),\n/* harmony export */   stripZeros: () => (/* binding */ stripZeros),\n/* harmony export */   zeroPad: () => (/* binding */ zeroPad)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/_version.js\");\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n///////////////////////////////\nfunction isHexable(value) {\n    return !!value.toHexString;\n}\nfunction addSlice(array) {\n    if (array.slice) {\n        return array;\n    }\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    };\n    return array;\n}\nfunction isBytesLike(value) {\n    return isHexString(value) && !(value.length % 2) || isBytes(value);\n}\nfunction isInteger(value) {\n    return typeof value === \"number\" && value == value && value % 1 === 0;\n}\nfunction isBytes(value) {\n    if (value == null) {\n        return false;\n    }\n    if (value.constructor === Uint8Array) {\n        return true;\n    }\n    if (typeof value === \"string\") {\n        return false;\n    }\n    if (!isInteger(value.length) || value.length < 0) {\n        return false;\n    }\n    for(let i = 0; i < value.length; i++){\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction arrayify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof value === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n        const result = [];\n        while(value){\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) {\n            result.push(0);\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (options.allowMissingPrefix && typeof value === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        value = value.toHexString();\n    }\n    if (isHexString(value)) {\n        let hex = value.substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        const result = [];\n        for(let i = 0; i < hex.length; i += 2){\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\nfunction concat(items) {\n    const objects = items.map((item)=>arrayify(item));\n    const length = objects.reduce((accum, item)=>accum + item.length, 0);\n    const result = new Uint8Array(length);\n    objects.reduce((offset, object)=>{\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n    return addSlice(result);\n}\nfunction stripZeros(value) {\n    let result = arrayify(value);\n    if (result.length === 0) {\n        return result;\n    }\n    // Find the first non-zero entry\n    let start = 0;\n    while(start < result.length && result[start] === 0){\n        start++;\n    }\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n    return result;\n}\nfunction zeroPad(value, length) {\n    value = arrayify(value);\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\nfunction isHexString(value, length) {\n    if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nconst HexCharacters = \"0123456789abcdef\";\nfunction hexlify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof value === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n        let hex = \"\";\n        while(value){\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n        if (hex.length) {\n            if (hex.length % 2) {\n                hex = \"0\" + hex;\n            }\n            return \"0x\" + hex;\n        }\n        return \"0x00\";\n    }\n    if (typeof value === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) {\n            return \"0x0\" + value;\n        }\n        return \"0x\" + value;\n    }\n    if (options.allowMissingPrefix && typeof value === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        return value.toHexString();\n    }\n    if (isHexString(value)) {\n        if (value.length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + value.substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return value.toLowerCase();\n    }\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for(let i = 0; i < value.length; i++){\n            let v = value[i];\n            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/ function hexDataLength(data) {\n    if (typeof data !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || data.length % 2) {\n        return null;\n    }\n    return (data.length - 2) / 2;\n}\nfunction hexDataSlice(data, offset, endOffset) {\n    if (typeof data !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || data.length % 2) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data);\n    }\n    offset = 2 + 2 * offset;\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n    return \"0x\" + data.substring(offset);\n}\nfunction hexConcat(items) {\n    let result = \"0x\";\n    items.forEach((item)=>{\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\nfunction hexValue(value) {\n    const trimmed = hexStripZeros(hexlify(value, {\n        hexPad: \"left\"\n    }));\n    if (trimmed === \"0x\") {\n        return \"0x0\";\n    }\n    return trimmed;\n}\nfunction hexStripZeros(value) {\n    if (typeof value !== \"string\") {\n        value = hexlify(value);\n    }\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while(offset < value.length && value[offset] === \"0\"){\n        offset++;\n    }\n    return \"0x\" + value.substring(offset);\n}\nfunction hexZeroPad(value, length) {\n    if (typeof value !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n    while(value.length < 2 * length + 2){\n        value = \"0x0\" + value.substring(2);\n    }\n    return value;\n}\nfunction splitSignature(signature) {\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n    if (isBytesLike(signature)) {\n        let bytes = arrayify(signature);\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - result.v % 2;\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) {\n            bytes[32] |= 0x80;\n        }\n        result._vs = hexlify(bytes.slice(32, 64));\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n            // Set or check the recid\n            const recoveryParam = vs[0] >= 128 ? 1 : 0;\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - result.v % 2;\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) {\n            vs[0] |= 0x80;\n        }\n        const _vs = hexlify(vs);\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n    return result;\n}\nfunction joinSignature(signature) {\n    signature = splitSignature(signature);\n    return hexlify(concat([\n        signature.r,\n        signature.s,\n        signature.recoveryParam ? \"0x1c\" : \"0x1b\"\n    ]));\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYnl0ZXMvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUNrQztBQUNWO0FBQ3JDLE1BQU1FLFNBQVMsSUFBSUYseURBQU1BLENBQUNDLDZDQUFPQTtBQUNqQywrQkFBK0I7QUFDL0IsU0FBU0UsVUFBVUMsS0FBSztJQUNwQixPQUFPLENBQUMsQ0FBRUEsTUFBTUMsV0FBVztBQUMvQjtBQUNBLFNBQVNDLFNBQVNDLEtBQUs7SUFDbkIsSUFBSUEsTUFBTUMsS0FBSyxFQUFFO1FBQ2IsT0FBT0Q7SUFDWDtJQUNBQSxNQUFNQyxLQUFLLEdBQUc7UUFDVixNQUFNQyxPQUFPQyxNQUFNQyxTQUFTLENBQUNILEtBQUssQ0FBQ0ksSUFBSSxDQUFDQztRQUN4QyxPQUFPUCxTQUFTLElBQUlRLFdBQVdKLE1BQU1DLFNBQVMsQ0FBQ0gsS0FBSyxDQUFDTyxLQUFLLENBQUNSLE9BQU9FO0lBQ3RFO0lBQ0EsT0FBT0Y7QUFDWDtBQUNPLFNBQVNTLFlBQVlaLEtBQUs7SUFDN0IsT0FBUSxZQUFhQSxVQUFVLENBQUVBLENBQUFBLE1BQU1jLE1BQU0sR0FBRyxNQUFPQyxRQUFRZjtBQUNuRTtBQUNBLFNBQVNnQixVQUFVaEIsS0FBSztJQUNwQixPQUFRLE9BQVFBLFVBQVcsWUFBWUEsU0FBU0EsU0FBUyxRQUFTLE1BQU87QUFDN0U7QUFDTyxTQUFTZSxRQUFRZixLQUFLO0lBQ3pCLElBQUlBLFNBQVMsTUFBTTtRQUNmLE9BQU87SUFDWDtJQUNBLElBQUlBLE1BQU1pQixXQUFXLEtBQUtQLFlBQVk7UUFDbEMsT0FBTztJQUNYO0lBQ0EsSUFBSSxPQUFRVixVQUFXLFVBQVU7UUFDN0IsT0FBTztJQUNYO0lBQ0EsSUFBSSxDQUFDZ0IsVUFBVWhCLE1BQU1jLE1BQU0sS0FBS2QsTUFBTWMsTUFBTSxHQUFHLEdBQUc7UUFDOUMsT0FBTztJQUNYO0lBQ0EsSUFBSyxJQUFJ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LEdBQUcsRUFBRTtRQUN4QztRQUNBLHVCQUF1QjtRQUN2QixJQUFJNUMsT0FBTzRDLEdBQUcsSUFBSSxNQUFNO1lBQ3BCNUMsT0FBTzRDLEdBQUcsR0FBR0E7UUFDakIsT0FDSyxJQUFJNUMsT0FBTzRDLEdBQUcsS0FBS0EsS0FBSztZQUN6QnJFLE9BQU9rQyxrQkFBa0IsQ0FBQyxrQ0FBa0MsYUFBYWdDO1FBQzdFO0lBQ0o7SUFDQXpDLE9BQU84QyxXQUFXLEdBQUc5QyxPQUFPNEMsR0FBRztJQUMvQjVDLE9BQU8rQyxPQUFPLEdBQUcvQyxPQUFPMEMsQ0FBQyxHQUFHMUMsT0FBTzhDLFdBQVcsQ0FBQ3hDLFNBQVMsQ0FBQztJQUN6RCxPQUFPTjtBQUNYO0FBQ08sU0FBU21ELGNBQWNWLFNBQVM7SUFDbkNBLFlBQVlELGVBQWVDO0lBQzNCLE9BQU9oQixRQUFRZixPQUFPO1FBQ2xCK0IsVUFBVUMsQ0FBQztRQUNYRCxVQUFVRSxDQUFDO1FBQ1ZGLFVBQVVJLGFBQWEsR0FBRyxTQUFTO0tBQ3ZDO0FBQ0wsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2J5dGVzL2xpYi5lc20vaW5kZXguanM/NjliYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGlzSGV4YWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAhISh2YWx1ZS50b0hleFN0cmluZyk7XG59XG5mdW5jdGlvbiBhZGRTbGljZShhcnJheSkge1xuICAgIGlmIChhcnJheS5zbGljZSkge1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIGFycmF5LnNsaWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGFkZFNsaWNlKG5ldyBVaW50OEFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcnJheSwgYXJncykpKTtcbiAgICB9O1xuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzTGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiAoKGlzSGV4U3RyaW5nKHZhbHVlKSAmJiAhKHZhbHVlLmxlbmd0aCAlIDIpKSB8fCBpc0J5dGVzKHZhbHVlKSk7XG59XG5mdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiICYmIHZhbHVlID09IHZhbHVlICYmICh2YWx1ZSAlIDEpID09PSAwKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgPT09IFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNJbnRlZ2VyKHZhbHVlLmxlbmd0aCkgfHwgdmFsdWUubGVuZ3RoIDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdiA9IHZhbHVlW2ldO1xuICAgICAgICBpZiAoIWlzSW50ZWdlcih2KSB8fCB2IDwgMCB8fCB2ID49IDI1Nikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5aWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja1NhZmVVaW50NTModmFsdWUsIFwiaW52YWxpZCBhcnJheWlmeSB2YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAweGZmKTtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoU3RyaW5nKHZhbHVlIC8gMjU2KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShyZXN1bHQpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dNaXNzaW5nUHJlZml4ICYmIHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG4gICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG4gICAgfVxuICAgIGlmIChpc0hleGFibGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBsZXQgaGV4ID0gdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICAgICAgICBoZXggPSBcIjBcIiArIGhleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICBoZXggKz0gXCIwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaGV4IGRhdGEgaXMgb2RkLWxlbmd0aFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KGhleC5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShyZXN1bHQpKTtcbiAgICB9XG4gICAgaWYgKGlzQnl0ZXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYXJyYXlpZnkgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KGl0ZW1zKSB7XG4gICAgY29uc3Qgb2JqZWN0cyA9IGl0ZW1zLm1hcChpdGVtID0+IGFycmF5aWZ5KGl0ZW0pKTtcbiAgICBjb25zdCBsZW5ndGggPSBvYmplY3RzLnJlZHVjZSgoYWNjdW0sIGl0ZW0pID0+IChhY2N1bSArIGl0ZW0ubGVuZ3RoKSwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBvYmplY3RzLnJlZHVjZSgob2Zmc2V0LCBvYmplY3QpID0+IHtcbiAgICAgICAgcmVzdWx0LnNldChvYmplY3QsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyBvYmplY3QubGVuZ3RoO1xuICAgIH0sIDApO1xuICAgIHJldHVybiBhZGRTbGljZShyZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwWmVyb3ModmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gYXJyYXlpZnkodmFsdWUpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGZpcnN0IG5vbi16ZXJvIGVudHJ5XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICB3aGlsZSAoc3RhcnQgPCByZXN1bHQubGVuZ3RoICYmIHJlc3VsdFtzdGFydF0gPT09IDApIHtcbiAgICAgICAgc3RhcnQrKztcbiAgICB9XG4gICAgLy8gSWYgd2Ugc3RhcnRlZCB3aXRoIHplcm9zLCBzdHJpcCB0aGVtXG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZShzdGFydCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gemVyb1BhZCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgdmFsdWUgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA+IGxlbmd0aCkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgb3V0IG9mIHJhbmdlXCIsIFwidmFsdWVcIiwgYXJndW1lbnRzWzBdKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICByZXN1bHQuc2V0KHZhbHVlLCBsZW5ndGggLSB2YWx1ZS5sZW5ndGgpO1xuICAgIHJldHVybiBhZGRTbGljZShyZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IEhleENoYXJhY3RlcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbmV4cG9ydCBmdW5jdGlvbiBoZXhsaWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja1NhZmVVaW50NTModmFsdWUsIFwiaW52YWxpZCBoZXhsaWZ5IHZhbHVlXCIpO1xuICAgICAgICBsZXQgaGV4ID0gXCJcIjtcbiAgICAgICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgICAgICBoZXggPSBIZXhDaGFyYWN0ZXJzW3ZhbHVlICYgMHhmXSArIGhleDtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIDE2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGV4Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCIweFwiICsgaGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIjB4MDBcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgcmV0dXJuIChcIjB4MFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dNaXNzaW5nUHJlZml4ICYmIHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG4gICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG4gICAgfVxuICAgIGlmIChpc0hleGFibGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0hleFN0cmluZygpO1xuICAgIH1cbiAgICBpZiAoaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oZXhQYWQgPT09IFwibGVmdFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIjB4MFwiICsgdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5oZXhQYWQgPT09IFwicmlnaHRcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IFwiMFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImhleCBkYXRhIGlzIG9kZC1sZW5ndGhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdiA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgcmVzdWx0ICs9IEhleENoYXJhY3RlcnNbKHYgJiAweGYwKSA+PiA0XSArIEhleENoYXJhY3RlcnNbdiAmIDB4MGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhsaWZ5IHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xufVxuLypcbmZ1bmN0aW9uIHVub2RkaWZ5KHZhbHVlOiBCeXRlc0xpa2UgfCBIZXhhYmxlIHwgbnVtYmVyKTogQnl0ZXNMaWtlIHwgSGV4YWJsZSB8IG51bWJlciB7XG4gICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubGVuZ3RoICUgMiAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhEYXRhTGVuZ3RoKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIChkYXRhKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKGRhdGEpIHx8IChkYXRhLmxlbmd0aCAlIDIpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGRhdGEubGVuZ3RoIC0gMikgLyAyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleERhdGFTbGljZShkYXRhLCBvZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIGlmICh0eXBlb2YgKGRhdGEpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNIZXhTdHJpbmcoZGF0YSkgfHwgKGRhdGEubGVuZ3RoICUgMikpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4RGF0YVwiLCBcInZhbHVlXCIsIGRhdGEpO1xuICAgIH1cbiAgICBvZmZzZXQgPSAyICsgMiAqIG9mZnNldDtcbiAgICBpZiAoZW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIGRhdGEuc3Vic3RyaW5nKG9mZnNldCwgMiArIDIgKiBlbmRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgZGF0YS5zdWJzdHJpbmcob2Zmc2V0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhDb25jYXQoaXRlbXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgcmVzdWx0ICs9IGhleGxpZnkoaXRlbSkuc3Vic3RyaW5nKDIpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4VmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCB0cmltbWVkID0gaGV4U3RyaXBaZXJvcyhoZXhsaWZ5KHZhbHVlLCB7IGhleFBhZDogXCJsZWZ0XCIgfSkpO1xuICAgIGlmICh0cmltbWVkID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiMHgwXCI7XG4gICAgfVxuICAgIHJldHVybiB0cmltbWVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFN0cmlwWmVyb3ModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSBoZXhsaWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4IHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgd2hpbGUgKG9mZnNldCA8IHZhbHVlLmxlbmd0aCAmJiB2YWx1ZVtvZmZzZXRdID09PSBcIjBcIikge1xuICAgICAgICBvZmZzZXQrKztcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHZhbHVlLnN1YnN0cmluZyhvZmZzZXQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFplcm9QYWQodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IGhleGxpZnkodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5sZW5ndGggPiAyICogbGVuZ3RoICsgMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgb3V0IG9mIHJhbmdlXCIsIFwidmFsdWVcIiwgYXJndW1lbnRzWzFdKTtcbiAgICB9XG4gICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IDIgKiBsZW5ndGggKyAyKSB7XG4gICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgcjogXCIweFwiLFxuICAgICAgICBzOiBcIjB4XCIsXG4gICAgICAgIF92czogXCIweFwiLFxuICAgICAgICByZWNvdmVyeVBhcmFtOiAwLFxuICAgICAgICB2OiAwLFxuICAgICAgICB5UGFyaXR5QW5kUzogXCIweFwiLFxuICAgICAgICBjb21wYWN0OiBcIjB4XCJcbiAgICB9O1xuICAgIGlmIChpc0J5dGVzTGlrZShzaWduYXR1cmUpKSB7XG4gICAgICAgIGxldCBieXRlcyA9IGFycmF5aWZ5KHNpZ25hdHVyZSk7XG4gICAgICAgIC8vIEdldCB0aGUgciwgcyBhbmQgdlxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgLy8gRUlQLTIwOTg7IHB1bGwgdGhlIHYgZnJvbSB0aGUgdG9wIGJpdCBvZiBzIGFuZCBjbGVhciBpdFxuICAgICAgICAgICAgcmVzdWx0LnYgPSAyNyArIChieXRlc1szMl0gPj4gNyk7XG4gICAgICAgICAgICBieXRlc1szMl0gJj0gMHg3ZjtcbiAgICAgICAgICAgIHJlc3VsdC5yID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICAgICAgcmVzdWx0LnMgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDMyLCA2NCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5yID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICAgICAgcmVzdWx0LnMgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDMyLCA2NCkpO1xuICAgICAgICAgICAgcmVzdWx0LnYgPSBieXRlc1s2NF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBzaWduYXR1cmUgc3RyaW5nXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxsb3cgYSByZWNpZCB0byBiZSB1c2VkIGFzIHRoZSB2XG4gICAgICAgIGlmIChyZXN1bHQudiA8IDI3KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnYgPT09IDAgfHwgcmVzdWx0LnYgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudiArPSAyNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgaW52YWxpZCB2IGJ5dGVcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHJlY292ZXJ5UGFyYW0gZnJvbSB2XG4gICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gMSAtIChyZXN1bHQudiAlIDIpO1xuICAgICAgICAvLyBDb21wdXRlIF92cyBmcm9tIHJlY292ZXJ5UGFyYW0gYW5kIHNcbiAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtKSB7XG4gICAgICAgICAgICBieXRlc1szMl0gfD0gMHg4MDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuX3ZzID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5yID0gc2lnbmF0dXJlLnI7XG4gICAgICAgIHJlc3VsdC5zID0gc2lnbmF0dXJlLnM7XG4gICAgICAgIHJlc3VsdC52ID0gc2lnbmF0dXJlLnY7XG4gICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW07XG4gICAgICAgIHJlc3VsdC5fdnMgPSBzaWduYXR1cmUuX3ZzO1xuICAgICAgICAvLyBJZiB0aGUgX3ZzIGlzIGF2YWlsYWJsZSwgdXNlIGl0IHRvIHBvcHVsYXRlIG1pc3NpbmcgcywgdiBhbmQgcmVjb3ZlcnlQYXJhbVxuICAgICAgICAvLyBhbmQgdmVyaWZ5IG5vbi1taXNzaW5nIHMsIHYgYW5kIHJlY292ZXJ5UGFyYW1cbiAgICAgICAgaWYgKHJlc3VsdC5fdnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdnMgPSB6ZXJvUGFkKGFycmF5aWZ5KHJlc3VsdC5fdnMpLCAzMik7XG4gICAgICAgICAgICByZXN1bHQuX3ZzID0gaGV4bGlmeSh2cyk7XG4gICAgICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIHJlY2lkXG4gICAgICAgICAgICBjb25zdCByZWNvdmVyeVBhcmFtID0gKCh2c1swXSA+PSAxMjgpID8gMSA6IDApO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IHJlY292ZXJ5UGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSAhPT0gcmVjb3ZlcnlQYXJhbSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcmVjb3ZlcnlQYXJhbSBtaXNtYXRjaCBfdnNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCBvciBjaGVjayB0aGUgc1xuICAgICAgICAgICAgdnNbMF0gJj0gMHg3ZjtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBoZXhsaWZ5KHZzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnMgPSBzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnMgIT09IHMpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHYgbWlzbWF0Y2ggX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIHJlY2lkIGFuZCB2IHRvIHBvcHVsYXRlIGVhY2ggb3RoZXJcbiAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIHYgYW5kIHJlY292ZXJ5UGFyYW1cIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC52ID09PSAwIHx8IHJlc3VsdC52ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSByZXN1bHQudjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gMSAtIChyZXN1bHQudiAlIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudiA9IDI3ICsgcmVzdWx0LnJlY292ZXJ5UGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNJZCA9IChyZXN1bHQudiA9PT0gMCB8fCByZXN1bHQudiA9PT0gMSkgPyByZXN1bHQudiA6ICgxIC0gKHJlc3VsdC52ICUgMikpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSAhPT0gcmVjSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSByZWNvdmVyeVBhcmFtIG1pc21hdGNoIHZcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5yID09IG51bGwgfHwgIWlzSGV4U3RyaW5nKHJlc3VsdC5yKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIG9yIGludmFsaWQgclwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnIgPSBoZXhaZXJvUGFkKHJlc3VsdC5yLCAzMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5zID09IG51bGwgfHwgIWlzSGV4U3RyaW5nKHJlc3VsdC5zKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIG9yIGludmFsaWQgc1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnMgPSBoZXhaZXJvUGFkKHJlc3VsdC5zLCAzMik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdnMgPSBhcnJheWlmeShyZXN1bHQucyk7XG4gICAgICAgIGlmICh2c1swXSA+PSAxMjgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcyBvdXQgb2YgcmFuZ2VcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0pIHtcbiAgICAgICAgICAgIHZzWzBdIHw9IDB4ODA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX3ZzID0gaGV4bGlmeSh2cyk7XG4gICAgICAgIGlmIChyZXN1bHQuX3ZzKSB7XG4gICAgICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKHJlc3VsdC5fdnMpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBpbnZhbGlkIF92c1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0Ll92cyA9IGhleFplcm9QYWQocmVzdWx0Ll92cywgMzIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBvciBjaGVjayB0aGUgX3ZzXG4gICAgICAgIGlmIChyZXN1bHQuX3ZzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5fdnMgPSBfdnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0Ll92cyAhPT0gX3ZzKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIF92cyBtaXNtYXRjaCB2IGFuZCBzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnlQYXJpdHlBbmRTID0gcmVzdWx0Ll92cztcbiAgICByZXN1bHQuY29tcGFjdCA9IHJlc3VsdC5yICsgcmVzdWx0LnlQYXJpdHlBbmRTLnN1YnN0cmluZygyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGpvaW5TaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgc2lnbmF0dXJlID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoW1xuICAgICAgICBzaWduYXR1cmUucixcbiAgICAgICAgc2lnbmF0dXJlLnMsXG4gICAgICAgIChzaWduYXR1cmUucmVjb3ZlcnlQYXJhbSA/IFwiMHgxY1wiIDogXCIweDFiXCIpXG4gICAgXSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJpc0hleGFibGUiLCJ2YWx1ZSIsInRvSGV4U3RyaW5nIiwiYWRkU2xpY2UiLCJhcnJheSIsInNsaWNlIiwiYXJncyIsIkFycmF5IiwicHJvdG90eXBlIiwiY2FsbCIsImFyZ3VtZW50cyIsIlVpbnQ4QXJyYXkiLCJhcHBseSIsImlzQnl0ZXNMaWtlIiwiaXNIZXhTdHJpbmciLCJsZW5ndGgiLCJpc0J5dGVzIiwiaXNJbnRlZ2VyIiwiY29uc3RydWN0b3IiLCJpIiwidiIsImFycmF5aWZ5Iiwib3B0aW9ucyIsImNoZWNrU2FmZVVpbnQ1MyIsInJlc3VsdCIsInVuc2hpZnQiLCJwYXJzZUludCIsIlN0cmluZyIsInB1c2giLCJhbGxvd01pc3NpbmdQcmVmaXgiLCJzdWJzdHJpbmciLCJoZXgiLCJoZXhQYWQiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJjb25jYXQiLCJpdGVtcyIsIm9iamVjdHMiLCJtYXAiLCJpdGVtIiwicmVkdWNlIiwiYWNjdW0iLCJvZmZzZXQiLCJvYmplY3QiLCJzZXQiLCJzdHJpcFplcm9zIiwic3RhcnQiLCJ6ZXJvUGFkIiwibWF0Y2giLCJIZXhDaGFyYWN0ZXJzIiwiaGV4bGlmeSIsIk1hdGgiLCJmbG9vciIsInRvU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJoZXhEYXRhTGVuZ3RoIiwiZGF0YSIsImhleERhdGFTbGljZSIsImVuZE9mZnNldCIsImhleENvbmNhdCIsImZvckVhY2giLCJoZXhWYWx1ZSIsInRyaW1tZWQiLCJoZXhTdHJpcFplcm9zIiwiaGV4WmVyb1BhZCIsInNwbGl0U2lnbmF0dXJlIiwic2lnbmF0dXJlIiwiciIsInMiLCJfdnMiLCJyZWNvdmVyeVBhcmFtIiwieVBhcml0eUFuZFMiLCJjb21wYWN0IiwiYnl0ZXMiLCJ2cyIsInJlY0lkIiwiam9pblNpZ25hdHVyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/constants/lib.esm/addresses.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ethersproject/constants/lib.esm/addresses.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressZero: () => (/* binding */ AddressZero)\n/* harmony export */ });\nconst AddressZero = \"0x0000000000000000000000000000000000000000\"; //# sourceMappingURL=addresses.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzL2xpYi5lc20vYWRkcmVzc2VzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSxjQUFjLDZDQUE2QyxDQUN4RSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIuZXNtL2FkZHJlc3Nlcy5qcz9jMzJmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBBZGRyZXNzWmVybyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzZXMuanMubWFwIl0sIm5hbWVzIjpbIkFkZHJlc3NaZXJvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/constants/lib.esm/addresses.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/constants/lib.esm/bignumbers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ethersproject/constants/lib.esm/bignumbers.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MaxInt256: () => (/* binding */ MaxInt256),\n/* harmony export */   MaxUint256: () => (/* binding */ MaxUint256),\n/* harmony export */   MinInt256: () => (/* binding */ MinInt256),\n/* harmony export */   NegativeOne: () => (/* binding */ NegativeOne),\n/* harmony export */   One: () => (/* binding */ One),\n/* harmony export */   Two: () => (/* binding */ Two),\n/* harmony export */   WeiPerEther: () => (/* binding */ WeiPerEther),\n/* harmony export */   Zero: () => (/* binding */ Zero)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n\nconst NegativeOne = /*#__PURE__*/ _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(-1);\nconst Zero = /*#__PURE__*/ _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(0);\nconst One = /*#__PURE__*/ _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(1);\nconst Two = /*#__PURE__*/ _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(2);\nconst WeiPerEther = /*#__PURE__*/ _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(\"1000000000000000000\");\nconst MaxUint256 = /*#__PURE__*/ _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst MinInt256 = /*#__PURE__*/ _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\");\nconst MaxInt256 = /*#__PURE__*/ _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n //# sourceMappingURL=bignumbers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzL2xpYi5lc20vYmlnbnVtYmVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBcUQ7QUFDckQsTUFBTUMsY0FBZ0IsV0FBVyxHQUFFRCwrREFBU0EsQ0FBQ0UsSUFBSSxDQUFDLENBQUM7QUFDbkQsTUFBTUMsT0FBUyxXQUFXLEdBQUVILCtEQUFTQSxDQUFDRSxJQUFJLENBQUM7QUFDM0MsTUFBTUUsTUFBUSxXQUFXLEdBQUVKLCtEQUFTQSxDQUFDRSxJQUFJLENBQUM7QUFDMUMsTUFBTUcsTUFBUSxXQUFXLEdBQUVMLCtEQUFTQSxDQUFDRSxJQUFJLENBQUM7QUFDMUMsTUFBTUksY0FBZ0IsV0FBVyxHQUFFTiwrREFBU0EsQ0FBQ0UsSUFBSSxDQUFDO0FBQ2xELE1BQU1LLGFBQWUsV0FBVyxHQUFFUCwrREFBU0EsQ0FBQ0UsSUFBSSxDQUFDO0FBQ2pELE1BQU1NLFlBQWMsV0FBVyxHQUFFUiwrREFBU0EsQ0FBQ0UsSUFBSSxDQUFDO0FBQ2hELE1BQU1PLFlBQWMsV0FBVyxHQUFFVCwrREFBU0EsQ0FBQ0UsSUFBSSxDQUFDO0FBQ3VDLENBQ3ZGLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzL2xpYi5lc20vYmlnbnVtYmVycy5qcz8wMWRiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmNvbnN0IE5lZ2F0aXZlT25lID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oLTEpKTtcbmNvbnN0IFplcm8gPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbSgwKSk7XG5jb25zdCBPbmUgPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbSgxKSk7XG5jb25zdCBUd28gPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbSgyKSk7XG5jb25zdCBXZWlQZXJFdGhlciA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKFwiMTAwMDAwMDAwMDAwMDAwMDAwMFwiKSk7XG5jb25zdCBNYXhVaW50MjU2ID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIikpO1xuY29uc3QgTWluSW50MjU2ID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oXCItMHg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpKTtcbmNvbnN0IE1heEludDI1NiA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKFwiMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpKTtcbmV4cG9ydCB7IE5lZ2F0aXZlT25lLCBaZXJvLCBPbmUsIFR3bywgV2VpUGVyRXRoZXIsIE1heFVpbnQyNTYsIE1pbkludDI1NiwgTWF4SW50MjU2LCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmlnbnVtYmVycy5qcy5tYXAiXSwibmFtZXMiOlsiQmlnTnVtYmVyIiwiTmVnYXRpdmVPbmUiLCJmcm9tIiwiWmVybyIsIk9uZSIsIlR3byIsIldlaVBlckV0aGVyIiwiTWF4VWludDI1NiIsIk1pbkludDI1NiIsIk1heEludDI1NiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/constants/lib.esm/bignumbers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/constants/lib.esm/hashes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersproject/constants/lib.esm/hashes.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HashZero: () => (/* binding */ HashZero)\n/* harmony export */ });\nconst HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\"; //# sourceMappingURL=hashes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzL2xpYi5lc20vaGFzaGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSxXQUFXLHFFQUFxRSxDQUM3RixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIuZXNtL2hhc2hlcy5qcz82M2YwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBIYXNoWmVybyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoZXMuanMubWFwIl0sIm5hbWVzIjpbIkhhc2haZXJvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/constants/lib.esm/hashes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/hash/lib.esm/_version.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/_version.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"hash/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSxVQUFVLGFBQWEsQ0FDcEMsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1zdGFydGVyLWtpdC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vX3ZlcnNpb24uanM/OTRhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiaGFzaC81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/hash/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode_arithmetic: () => (/* binding */ decode_arithmetic),\n/* harmony export */   read_compressed_payload: () => (/* binding */ read_compressed_payload),\n/* harmony export */   read_emoji_trie: () => (/* binding */ read_emoji_trie),\n/* harmony export */   read_mapped_map: () => (/* binding */ read_mapped_map),\n/* harmony export */   read_member_array: () => (/* binding */ read_member_array),\n/* harmony export */   read_payload: () => (/* binding */ read_payload),\n/* harmony export */   read_zero_terminated_array: () => (/* binding */ read_zero_terminated_array),\n/* harmony export */   signed: () => (/* binding */ signed)\n/* harmony export */ });\n/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */ // https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js\nfunction flat(array, depth) {\n    if (depth == null) {\n        depth = 1;\n    }\n    const result = [];\n    const forEach = result.forEach;\n    const flatDeep = function(arr, depth) {\n        forEach.call(arr, function(val) {\n            if (depth > 0 && Array.isArray(val)) {\n                flatDeep(val, depth - 1);\n            } else {\n                result.push(val);\n            }\n        });\n    };\n    flatDeep(array, depth);\n    return result;\n}\nfunction fromEntries(array) {\n    const result = {};\n    for(let i = 0; i < array.length; i++){\n        const value = array[i];\n        result[value[0]] = value[1];\n    }\n    return result;\n}\nfunction decode_arithmetic(bytes) {\n    let pos = 0;\n    function u16() {\n        return bytes[pos++] << 8 | bytes[pos++];\n    }\n    // decode the frequency table\n    let symbol_count = u16();\n    let total = 1;\n    let acc = [\n        0,\n        1\n    ]; // first symbol has frequency 1\n    for(let i = 1; i < symbol_count; i++){\n        acc.push(total += u16());\n    }\n    // skip the sized-payload that the last 3 symbols index into\n    let skip = u16();\n    let pos_payload = pos;\n    pos += skip;\n    let read_width = 0;\n    let read_buffer = 0;\n    function read_bit() {\n        if (read_width == 0) {\n            // this will read beyond end of buffer\n            // but (undefined|0) => zero pad\n            read_buffer = read_buffer << 8 | bytes[pos++];\n            read_width = 8;\n        }\n        return read_buffer >> --read_width & 1;\n    }\n    const N = 31;\n    const FULL = Math.pow(2, N);\n    const HALF = FULL >>> 1;\n    const QRTR = HALF >> 1;\n    const MASK = FULL - 1;\n    // fill register\n    let register = 0;\n    for(let i = 0; i < N; i++)register = register << 1 | read_bit();\n    let symbols = [];\n    let low = 0;\n    let range = FULL; // treat like a float\n    while(true){\n        let value = Math.floor(((register - low + 1) * total - 1) / range);\n        let start = 0;\n        let end = symbol_count;\n        while(end - start > 1){\n            let mid = start + end >>> 1;\n            if (value < acc[mid]) {\n                end = mid;\n            } else {\n                start = mid;\n            }\n        }\n        if (start == 0) break; // first symbol is end mark\n        symbols.push(start);\n        let a = low + Math.floor(range * acc[start] / total);\n        let b = low + Math.floor(range * acc[start + 1] / total) - 1;\n        while(((a ^ b) & HALF) == 0){\n            register = register << 1 & MASK | read_bit();\n            a = a << 1 & MASK;\n            b = b << 1 & MASK | 1;\n        }\n        while(a & ~b & QRTR){\n            register = register & HALF | register << 1 & MASK >>> 1 | read_bit();\n            a = a << 1 ^ HALF;\n            b = (b ^ HALF) << 1 | HALF | 1;\n        }\n        low = a;\n        range = 1 + b - a;\n    }\n    let offset = symbol_count - 4;\n    return symbols.map((x)=>{\n        switch(x - offset){\n            case 3:\n                return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n            case 2:\n                return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n            case 1:\n                return offset + bytes[pos_payload++];\n            default:\n                return x - 1;\n        }\n    });\n}\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n    let pos = 0;\n    return ()=>v[pos++];\n}\nfunction read_compressed_payload(bytes) {\n    return read_payload(decode_arithmetic(bytes));\n}\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n    return i & 1 ? ~i >> 1 : i >> 1;\n}\nfunction read_counts(n, next) {\n    let v = Array(n);\n    for(let i = 0; i < n; i++)v[i] = 1 + next();\n    return v;\n}\nfunction read_ascending(n, next) {\n    let v = Array(n);\n    for(let i = 0, x = -1; i < n; i++)v[i] = x += 1 + next();\n    return v;\n}\nfunction read_deltas(n, next) {\n    let v = Array(n);\n    for(let i = 0, x = 0; i < n; i++)v[i] = x += signed(next());\n    return v;\n}\nfunction read_member_array(next, lookup) {\n    let v = read_ascending(next(), next);\n    let n = next();\n    let vX = read_ascending(n, next);\n    let vN = read_counts(n, next);\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < vN[i]; j++){\n            v.push(vX[i] + j);\n        }\n    }\n    return lookup ? v.map((x)=>lookup[x]) : v;\n}\n// returns array of \n// [x, ys] => single replacement rule\n// [x, ys, n, dx, dx] => linear map\nfunction read_mapped_map(next) {\n    let ret = [];\n    while(true){\n        let w = next();\n        if (w == 0) break;\n        ret.push(read_linear_table(w, next));\n    }\n    while(true){\n        let w = next() - 1;\n        if (w < 0) break;\n        ret.push(read_replacement_table(w, next));\n    }\n    return fromEntries(flat(ret));\n}\nfunction read_zero_terminated_array(next) {\n    let v = [];\n    while(true){\n        let i = next();\n        if (i == 0) break;\n        v.push(i);\n    }\n    return v;\n}\nfunction read_transposed(n, w, next) {\n    let m = Array(n).fill(undefined).map(()=>[]);\n    for(let i = 0; i < w; i++){\n        read_deltas(n, next).forEach((x, j)=>m[j].push(x));\n    }\n    return m;\n}\nfunction read_linear_table(w, next) {\n    let dx = 1 + next();\n    let dy = next();\n    let vN = read_zero_terminated_array(next);\n    let m = read_transposed(vN.length, 1 + w, next);\n    return flat(m.map((v, i)=>{\n        const x = v[0], ys = v.slice(1);\n        //let [x, ...ys] = v;\n        //return Array(vN[i]).fill().map((_, j) => {\n        return Array(vN[i]).fill(undefined).map((_, j)=>{\n            let j_dy = j * dy;\n            return [\n                x + j * dx,\n                ys.map((y)=>y + j_dy)\n            ];\n        });\n    }));\n}\nfunction read_replacement_table(w, next) {\n    let n = 1 + next();\n    let m = read_transposed(n, 1 + w, next);\n    return m.map((v)=>[\n            v[0],\n            v.slice(1)\n        ]);\n}\nfunction read_emoji_trie(next) {\n    let sorted = read_member_array(next).sort((a, b)=>a - b);\n    return read();\n    function read() {\n        let branches = [];\n        while(true){\n            let keys = read_member_array(next, sorted);\n            if (keys.length == 0) break;\n            branches.push({\n                set: new Set(keys),\n                node: read()\n            });\n        }\n        branches.sort((a, b)=>b.set.size - a.set.size); // sort by likelihood\n        let temp = next();\n        let valid = temp % 3;\n        temp = temp / 3 | 0;\n        let fe0f = !!(temp & 1);\n        temp >>= 1;\n        let save = temp == 1;\n        let check = temp == 2;\n        return {\n            branches,\n            valid,\n            fe0f,\n            save,\n            check\n        };\n    }\n} //# sourceMappingURL=decoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL2Vucy1ub3JtYWxpemUvZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EyQkMsR0FDRCx1RUFBdUU7QUFDdkUsU0FBU0EsS0FBS0MsS0FBSyxFQUFFQyxLQUFLO0lBQ3RCLElBQUlBLFNBQVMsTUFBTTtRQUNmQSxRQUFRO0lBQ1o7SUFDQSxNQUFNQyxTQUFTLEVBQUU7SUFDakIsTUFBTUMsVUFBVUQsT0FBT0MsT0FBTztJQUM5QixNQUFNQyxXQUFXLFNBQVVDLEdBQUcsRUFBRUosS0FBSztRQUNqQ0UsUUFBUUcsSUFBSSxDQUFDRCxLQUFLLFNBQVVFLEdBQUc7WUFDM0IsSUFBSU4sUUFBUSxLQUFLTyxNQUFNQyxPQUFPLENBQUNGLE1BQU07Z0JBQ2pDSCxTQUFTRyxLQUFLTixRQUFRO1lBQzFCLE9BQ0s7Z0JBQ0RDLE9BQU9RLElBQUksQ0FBQ0g7WUFDaEI7UUFDSjtJQUNKO0lBQ0FILFNBQVNKLE9BQU9DO0lBQ2hCLE9BQU9DO0FBQ1g7QUFDQSxTQUFTUyxZQUFZWCxLQUFLO0lBQ3RCLE1BQU1FLFNBQVMsQ0FBQztJQUNoQixJQUFLLElBQUlVLElBQUksR0FBR0EsSUFBSVosTUFBTWEsTUFBTSxFQUFFRCxJQUFLO1FBQ25DLE1BQU1FLFFBQVFkLEtBQUssQ0FBQ1ksRUFBRTtRQUN0QlYsTUFBTSxDQUFDWSxLQUFLLENBQUMsRUFBRSxDQUFDLEdBQUdBLEtBQUssQ0FBQyxFQUFFO0lBQy9CO0lBQ0EsT0FBT1o7QUFDWDtBQUNPLFNBQVNhLGtCQUFrQkMsS0FBSztJQUNuQyxJQUFJQyxNQUFNO0lBQ1YsU0FBU0M7UUFBUSxPQUFPLEtBQU0sQ0FBQ0QsTUFBTSxJQUFJLElBQUtELEtBQUssQ0FBQ0MsTUFBTTtJQUFFO0lBQzVELDZCQUE2QjtJQUM3QixJQUFJRSxlQUFlRDtJQUNuQixJQUFJRSxRQUFRO0lB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T0FBT3NDO0lBQ1AsU0FBU0E7UUFDTCxJQUFJQyxXQUFXLEVBQUU7UUFDakIsTUFBTyxLQUFNO1lBQ1QsSUFBSUMsT0FBTzNCLGtCQUFrQkgsTUFBTTBCO1lBQ25DLElBQUlJLEtBQUt0RSxNQUFNLElBQUksR0FDZjtZQUNKcUUsU0FBU3hFLElBQUksQ0FBQztnQkFBRTBFLEtBQUssSUFBSUMsSUFBSUY7Z0JBQU9HLE1BQU1MO1lBQU87UUFDckQ7UUFDQUMsU0FBU0YsSUFBSSxDQUFDLENBQUN0QyxHQUFHQyxJQUFNQSxFQUFFeUMsR0FBRyxDQUFDRyxJQUFJLEdBQUc3QyxFQUFFMEMsR0FBRyxDQUFDRyxJQUFJLEdBQUcscUJBQXFCO1FBQ3ZFLElBQUlDLE9BQU9uQztRQUNYLElBQUlvQyxRQUFRRCxPQUFPO1FBQ25CQSxPQUFPLE9BQVEsSUFBSztRQUNwQixJQUFJRSxPQUFPLENBQUMsQ0FBRUYsQ0FBQUEsT0FBTztRQUNyQkEsU0FBUztRQUNULElBQUlHLE9BQU9ILFFBQVE7UUFDbkIsSUFBSUksUUFBUUosUUFBUTtRQUNwQixPQUFPO1lBQUVOO1lBQVVPO1lBQU9DO1lBQU1DO1lBQU1DO1FBQU07SUFDaEQ7QUFDSixFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL2Vucy1ub3JtYWxpemUvZGVjb2Rlci5qcz83NDQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTUlUIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEgQW5kcmV3IFJhZmZlbnNwZXJnZXJcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICpcbiAqIFRoaXMgaXMgYSBuZWFyIGNhcmJvbi1jb3B5IG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgKGxpbmsgYmVsb3cpIHdpdGggdGhlXG4gKiBUeXBlU2NyaXB0IHR5cGluZ3MgYWRkZWQgYW5kIGEgZmV3IHR3ZWFrcyB0byBtYWtlIGl0IEVTMy1jb21wYXRpYmxlLlxuICpcbiAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qc1xuICovXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVobmFtbW9kaS9wb2x5ZmlsbC9ibG9iL21hc3Rlci9hcnJheS5wb2x5ZmlsbC5qc1xuZnVuY3Rpb24gZmxhdChhcnJheSwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT0gbnVsbCkge1xuICAgICAgICBkZXB0aCA9IDE7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IGZvckVhY2ggPSByZXN1bHQuZm9yRWFjaDtcbiAgICBjb25zdCBmbGF0RGVlcCA9IGZ1bmN0aW9uIChhcnIsIGRlcHRoKSB7XG4gICAgICAgIGZvckVhY2guY2FsbChhcnIsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGlmIChkZXB0aCA+IDAgJiYgQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgZmxhdERlZXAodmFsLCBkZXB0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBmbGF0RGVlcChhcnJheSwgZGVwdGgpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmcm9tRW50cmllcyhhcnJheSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhcnJheVtpXTtcbiAgICAgICAgcmVzdWx0W3ZhbHVlWzBdXSA9IHZhbHVlWzFdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZV9hcml0aG1ldGljKGJ5dGVzKSB7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgZnVuY3Rpb24gdTE2KCkgeyByZXR1cm4gKGJ5dGVzW3BvcysrXSA8PCA4KSB8IGJ5dGVzW3BvcysrXTsgfVxuICAgIC8vIGRlY29kZSB0aGUgZnJlcXVlbmN5IHRhYmxlXG4gICAgbGV0IHN5bWJvbF9jb3VudCA9IHUxNigpO1xuICAgIGxldCB0b3RhbCA9IDE7XG4gICAgbGV0IGFjYyA9IFswLCAxXTsgLy8gZmlyc3Qgc3ltYm9sIGhhcyBmcmVxdWVuY3kgMVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3ltYm9sX2NvdW50OyBpKyspIHtcbiAgICAgICAgYWNjLnB1c2godG90YWwgKz0gdTE2KCkpO1xuICAgIH1cbiAgICAvLyBza2lwIHRoZSBzaXplZC1wYXlsb2FkIHRoYXQgdGhlIGxhc3QgMyBzeW1ib2xzIGluZGV4IGludG9cbiAgICBsZXQgc2tpcCA9IHUxNigpO1xuICAgIGxldCBwb3NfcGF5bG9hZCA9IHBvcztcbiAgICBwb3MgKz0gc2tpcDtcbiAgICBsZXQgcmVhZF93aWR0aCA9IDA7XG4gICAgbGV0IHJlYWRfYnVmZmVyID0gMDtcbiAgICBmdW5jdGlvbiByZWFkX2JpdCgpIHtcbiAgICAgICAgaWYgKHJlYWRfd2lkdGggPT0gMCkge1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHJlYWQgYmV5b25kIGVuZCBvZiBidWZmZXJcbiAgICAgICAgICAgIC8vIGJ1dCAodW5kZWZpbmVkfDApID0+IHplcm8gcGFkXG4gICAgICAgICAgICByZWFkX2J1ZmZlciA9IChyZWFkX2J1ZmZlciA8PCA4KSB8IGJ5dGVzW3BvcysrXTtcbiAgICAgICAgICAgIHJlYWRfd2lkdGggPSA4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAocmVhZF9idWZmZXIgPj4gLS1yZWFkX3dpZHRoKSAmIDE7XG4gICAgfVxuICAgIGNvbnN0IE4gPSAzMTtcbiAgICBjb25zdCBGVUxMID0gTWF0aC5wb3coMiwgTik7XG4gICAgY29uc3QgSEFMRiA9IEZVTEwgPj4+IDE7XG4gICAgY29uc3QgUVJUUiA9IEhBTEYgPj4gMTtcbiAgICBjb25zdCBNQVNLID0gRlVMTCAtIDE7XG4gICAgLy8gZmlsbCByZWdpc3RlclxuICAgIGxldCByZWdpc3RlciA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpKyspXG4gICAgICAgIHJlZ2lzdGVyID0gKHJlZ2lzdGVyIDw8IDEpIHwgcmVhZF9iaXQoKTtcbiAgICBsZXQgc3ltYm9scyA9IFtdO1xuICAgIGxldCBsb3cgPSAwO1xuICAgIGxldCByYW5nZSA9IEZVTEw7IC8vIHRyZWF0IGxpa2UgYSBmbG9hdFxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IE1hdGguZmxvb3IoKCgocmVnaXN0ZXIgLSBsb3cgKyAxKSAqIHRvdGFsKSAtIDEpIC8gcmFuZ2UpO1xuICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICBsZXQgZW5kID0gc3ltYm9sX2NvdW50O1xuICAgICAgICB3aGlsZSAoZW5kIC0gc3RhcnQgPiAxKSB7IC8vIGJpbmFyeSBzZWFyY2hcbiAgICAgICAgICAgIGxldCBtaWQgPSAoc3RhcnQgKyBlbmQpID4+PiAxO1xuICAgICAgICAgICAgaWYgKHZhbHVlIDwgYWNjW21pZF0pIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPT0gMClcbiAgICAgICAgICAgIGJyZWFrOyAvLyBmaXJzdCBzeW1ib2wgaXMgZW5kIG1hcmtcbiAgICAgICAgc3ltYm9scy5wdXNoKHN0YXJ0KTtcbiAgICAgICAgbGV0IGEgPSBsb3cgKyBNYXRoLmZsb29yKHJhbmdlICogYWNjW3N0YXJ0XSAvIHRvdGFsKTtcbiAgICAgICAgbGV0IGIgPSBsb3cgKyBNYXRoLmZsb29yKHJhbmdlICogYWNjW3N0YXJ0ICsgMV0gLyB0b3RhbCkgLSAxO1xuICAgICAgICB3aGlsZSAoKChhIF4gYikgJiBIQUxGKSA9PSAwKSB7XG4gICAgICAgICAgICByZWdpc3RlciA9IChyZWdpc3RlciA8PCAxKSAmIE1BU0sgfCByZWFkX2JpdCgpO1xuICAgICAgICAgICAgYSA9IChhIDw8IDEpICYgTUFTSztcbiAgICAgICAgICAgIGIgPSAoYiA8PCAxKSAmIE1BU0sgfCAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChhICYgfmIgJiBRUlRSKSB7XG4gICAgICAgICAgICByZWdpc3RlciA9IChyZWdpc3RlciAmIEhBTEYpIHwgKChyZWdpc3RlciA8PCAxKSAmIChNQVNLID4+PiAxKSkgfCByZWFkX2JpdCgpO1xuICAgICAgICAgICAgYSA9IChhIDw8IDEpIF4gSEFMRjtcbiAgICAgICAgICAgIGIgPSAoKGIgXiBIQUxGKSA8PCAxKSB8IEhBTEYgfCAxO1xuICAgICAgICB9XG4gICAgICAgIGxvdyA9IGE7XG4gICAgICAgIHJhbmdlID0gMSArIGIgLSBhO1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0ID0gc3ltYm9sX2NvdW50IC0gNDtcbiAgICByZXR1cm4gc3ltYm9scy5tYXAoeCA9PiB7XG4gICAgICAgIHN3aXRjaCAoeCAtIG9mZnNldCkge1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gb2Zmc2V0ICsgMHgxMDEwMCArICgoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgMTYpIHwgKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDgpIHwgYnl0ZXNbcG9zX3BheWxvYWQrK10pO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gb2Zmc2V0ICsgMHgxMDAgKyAoKGJ5dGVzW3Bvc19wYXlsb2FkKytdIDw8IDgpIHwgYnl0ZXNbcG9zX3BheWxvYWQrK10pO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gb2Zmc2V0ICsgYnl0ZXNbcG9zX3BheWxvYWQrK107XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4geCAtIDE7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIHJldHVybnMgYW4gaXRlcmF0b3Igd2hpY2ggcmV0dXJucyB0aGUgbmV4dCBzeW1ib2xcbmV4cG9ydCBmdW5jdGlvbiByZWFkX3BheWxvYWQodikge1xuICAgIGxldCBwb3MgPSAwO1xuICAgIHJldHVybiAoKSA9PiB2W3BvcysrXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChieXRlcykge1xuICAgIHJldHVybiByZWFkX3BheWxvYWQoZGVjb2RlX2FyaXRobWV0aWMoYnl0ZXMpKTtcbn1cbi8vIGVnLiBbMCwxLDIsMy4uLl0gPT4gWzAsLTEsMSwtMiwuLi5dXG5leHBvcnQgZnVuY3Rpb24gc2lnbmVkKGkpIHtcbiAgICByZXR1cm4gKGkgJiAxKSA/ICh+aSA+PiAxKSA6IChpID4+IDEpO1xufVxuZnVuY3Rpb24gcmVhZF9jb3VudHMobiwgbmV4dCkge1xuICAgIGxldCB2ID0gQXJyYXkobik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgICAgIHZbaV0gPSAxICsgbmV4dCgpO1xuICAgIHJldHVybiB2O1xufVxuZnVuY3Rpb24gcmVhZF9hc2NlbmRpbmcobiwgbmV4dCkge1xuICAgIGxldCB2ID0gQXJyYXkobik7XG4gICAgZm9yIChsZXQgaSA9IDAsIHggPSAtMTsgaSA8IG47IGkrKylcbiAgICAgICAgdltpXSA9IHggKz0gMSArIG5leHQoKTtcbiAgICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIHJlYWRfZGVsdGFzKG4sIG5leHQpIHtcbiAgICBsZXQgdiA9IEFycmF5KG4pO1xuICAgIGZvciAobGV0IGkgPSAwLCB4ID0gMDsgaSA8IG47IGkrKylcbiAgICAgICAgdltpXSA9IHggKz0gc2lnbmVkKG5leHQoKSk7XG4gICAgcmV0dXJuIHY7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZF9tZW1iZXJfYXJyYXkobmV4dCwgbG9va3VwKSB7XG4gICAgbGV0IHYgPSByZWFkX2FzY2VuZGluZyhuZXh0KCksIG5leHQpO1xuICAgIGxldCBuID0gbmV4dCgpO1xuICAgIGxldCB2WCA9IHJlYWRfYXNjZW5kaW5nKG4sIG5leHQpO1xuICAgIGxldCB2TiA9IHJlYWRfY291bnRzKG4sIG5leHQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdk5baV07IGorKykge1xuICAgICAgICAgICAgdi5wdXNoKHZYW2ldICsgaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvb2t1cCA/IHYubWFwKHggPT4gbG9va3VwW3hdKSA6IHY7XG59XG4vLyByZXR1cm5zIGFycmF5IG9mIFxuLy8gW3gsIHlzXSA9PiBzaW5nbGUgcmVwbGFjZW1lbnQgcnVsZVxuLy8gW3gsIHlzLCBuLCBkeCwgZHhdID0+IGxpbmVhciBtYXBcbmV4cG9ydCBmdW5jdGlvbiByZWFkX21hcHBlZF9tYXAobmV4dCkge1xuICAgIGxldCByZXQgPSBbXTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgdyA9IG5leHQoKTtcbiAgICAgICAgaWYgKHcgPT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICByZXQucHVzaChyZWFkX2xpbmVhcl90YWJsZSh3LCBuZXh0KSk7XG4gICAgfVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCB3ID0gbmV4dCgpIC0gMTtcbiAgICAgICAgaWYgKHcgPCAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHJldC5wdXNoKHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkpO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbUVudHJpZXMoZmxhdChyZXQpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWFkX3plcm9fdGVybWluYXRlZF9hcnJheShuZXh0KSB7XG4gICAgbGV0IHYgPSBbXTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgaSA9IG5leHQoKTtcbiAgICAgICAgaWYgKGkgPT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB2LnB1c2goaSk7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuZnVuY3Rpb24gcmVhZF90cmFuc3Bvc2VkKG4sIHcsIG5leHQpIHtcbiAgICBsZXQgbSA9IEFycmF5KG4pLmZpbGwodW5kZWZpbmVkKS5tYXAoKCkgPT4gW10pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdzsgaSsrKSB7XG4gICAgICAgIHJlYWRfZGVsdGFzKG4sIG5leHQpLmZvckVhY2goKHgsIGopID0+IG1bal0ucHVzaCh4KSk7XG4gICAgfVxuICAgIHJldHVybiBtO1xufVxuZnVuY3Rpb24gcmVhZF9saW5lYXJfdGFibGUodywgbmV4dCkge1xuICAgIGxldCBkeCA9IDEgKyBuZXh0KCk7XG4gICAgbGV0IGR5ID0gbmV4dCgpO1xuICAgIGxldCB2TiA9IHJlYWRfemVyb190ZXJtaW5hdGVkX2FycmF5KG5leHQpO1xuICAgIGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKHZOLmxlbmd0aCwgMSArIHcsIG5leHQpO1xuICAgIHJldHVybiBmbGF0KG0ubWFwKCh2LCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHggPSB2WzBdLCB5cyA9IHYuc2xpY2UoMSk7XG4gICAgICAgIC8vbGV0IFt4LCAuLi55c10gPSB2O1xuICAgICAgICAvL3JldHVybiBBcnJheSh2TltpXSkuZmlsbCgpLm1hcCgoXywgaikgPT4ge1xuICAgICAgICByZXR1cm4gQXJyYXkodk5baV0pLmZpbGwodW5kZWZpbmVkKS5tYXAoKF8sIGopID0+IHtcbiAgICAgICAgICAgIGxldCBqX2R5ID0gaiAqIGR5O1xuICAgICAgICAgICAgcmV0dXJuIFt4ICsgaiAqIGR4LCB5cy5tYXAoeSA9PiB5ICsgal9keSldO1xuICAgICAgICB9KTtcbiAgICB9KSk7XG59XG5mdW5jdGlvbiByZWFkX3JlcGxhY2VtZW50X3RhYmxlKHcsIG5leHQpIHtcbiAgICBsZXQgbiA9IDEgKyBuZXh0KCk7XG4gICAgbGV0IG0gPSByZWFkX3RyYW5zcG9zZWQobiwgMSArIHcsIG5leHQpO1xuICAgIHJldHVybiBtLm1hcCh2ID0+IFt2WzBdLCB2LnNsaWNlKDEpXSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZF9lbW9qaV90cmllKG5leHQpIHtcbiAgICBsZXQgc29ydGVkID0gcmVhZF9tZW1iZXJfYXJyYXkobmV4dCkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIHJldHVybiByZWFkKCk7XG4gICAgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgICAgbGV0IGJyYW5jaGVzID0gW107XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBsZXQga2V5cyA9IHJlYWRfbWVtYmVyX2FycmF5KG5leHQsIHNvcnRlZCk7XG4gICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGJyYW5jaGVzLnB1c2goeyBzZXQ6IG5ldyBTZXQoa2V5cyksIG5vZGU6IHJlYWQoKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmFuY2hlcy5zb3J0KChhLCBiKSA9PiBiLnNldC5zaXplIC0gYS5zZXQuc2l6ZSk7IC8vIHNvcnQgYnkgbGlrZWxpaG9vZFxuICAgICAgICBsZXQgdGVtcCA9IG5leHQoKTtcbiAgICAgICAgbGV0IHZhbGlkID0gdGVtcCAlIDM7XG4gICAgICAgIHRlbXAgPSAodGVtcCAvIDMpIHwgMDtcbiAgICAgICAgbGV0IGZlMGYgPSAhISh0ZW1wICYgMSk7XG4gICAgICAgIHRlbXAgPj49IDE7XG4gICAgICAgIGxldCBzYXZlID0gdGVtcCA9PSAxO1xuICAgICAgICBsZXQgY2hlY2sgPSB0ZW1wID09IDI7XG4gICAgICAgIHJldHVybiB7IGJyYW5jaGVzLCB2YWxpZCwgZmUwZiwgc2F2ZSwgY2hlY2sgfTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWNvZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJmbGF0IiwiYXJyYXkiLCJkZXB0aCIsInJlc3VsdCIsImZvckVhY2giLCJmbGF0RGVlcCIsImFyciIsImNhbGwiLCJ2YWwiLCJBcnJheSIsImlzQXJyYXkiLCJwdXNoIiwiZnJvbUVudHJpZXMiLCJpIiwibGVuZ3RoIiwidmFsdWUiLCJkZWNvZGVfYXJpdGhtZXRpYyIsImJ5dGVzIiwicG9zIiwidTE2Iiwic3ltYm9sX2NvdW50IiwidG90YWwiLCJhY2MiLCJza2lwIiwicG9zX3BheWxvYWQiLCJyZWFkX3dpZHRoIiwicmVhZF9idWZmZXIiLCJyZWFkX2JpdCIsIk4iLCJGVUxMIiwiTWF0aCIsInBvdyIsIkhBTEYiLCJRUlRSIiwiTUFTSyIsInJlZ2lzdGVyIiwic3ltYm9scyIsImxvdyIsInJhbmdlIiwiZmxvb3IiLCJzdGFydCIsImVuZCIsIm1pZCIsImEiLCJiIiwib2Zmc2V0IiwibWFwIiwieCIsInJlYWRfcGF5bG9hZCIsInYiLCJyZWFkX2NvbXByZXNzZWRfcGF5bG9hZCIsInNpZ25lZCIsInJlYWRfY291bnRzIiwibiIsIm5leHQiLCJyZWFkX2FzY2VuZGluZyIsInJlYWRfZGVsdGFzIiwicmVhZF9tZW1iZXJfYXJyYXkiLCJsb29rdXAiLCJ2WCIsInZOIiwiaiIsInJlYWRfbWFwcGVkX21hcCIsInJldCIsInciLCJyZWFkX2xpbmVhcl90YWJsZSIsInJlYWRfcmVwbGFjZW1lbnRfdGFibGUiLCJyZWFkX3plcm9fdGVybWluYXRlZF9hcnJheSIsInJlYWRfdHJhbnNwb3NlZCIsIm0iLCJmaWxsIiwidW5kZWZpbmVkIiwiZHgiLCJkeSIsInlzIiwic2xpY2UiLCJfIiwial9keSIsInkiLCJyZWFkX2Vtb2ppX3RyaWUiLCJzb3J0ZWQiLCJzb3J0IiwicmVhZCIsImJyYW5jaGVzIiwia2V5cyIsInNldCIsIlNldCIsIm5vZGUiLCJzaXplIiwidGVtcCIsInZhbGlkIiwiZmUwZiIsInNhdmUiLCJjaGVjayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getData: () => (/* binding */ getData)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/base64 */ \"(ssr)/./node_modules/@ethersproject/base64/lib.esm/base64.js\");\n/* harmony import */ var _decoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decoder.js */ \"(ssr)/./node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js\");\n/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */ \n\nfunction getData() {\n    return (0,_decoder_js__WEBPACK_IMPORTED_MODULE_0__.read_compressed_payload)((0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_1__.decode)(\"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\"));\n} //# sourceMappingURL=include.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL2Vucy1ub3JtYWxpemUvaW5jbHVkZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMkJDLEdBQzhDO0FBQ1E7QUFDaEQsU0FBU0U7SUFDWixPQUFPRCxvRUFBdUJBLENBQUNELDZEQUFNQSxDQUFDO0FBQzFDLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1zdGFydGVyLWtpdC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vZW5zLW5vcm1hbGl6ZS9pbmNsdWRlLmpzP2E0NWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNSVQgTGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAyMSBBbmRyZXcgUmFmZmVuc3BlcmdlclxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKlxuICogVGhpcyBpcyBhIG5lYXIgY2FyYm9uLWNvcHkgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSAobGluayBiZWxvdykgd2l0aCB0aGVcbiAqIFR5cGVTY3JpcHQgdHlwaW5ncyBhZGRlZCBhbmQgYSBmZXcgdHdlYWtzIHRvIG1ha2UgaXQgRVMzLWNvbXBhdGlibGUuXG4gKlxuICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzXG4gKi9cbmltcG9ydCB7IGRlY29kZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iYXNlNjRcIjtcbmltcG9ydCB7IHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkIH0gZnJvbSAnLi9kZWNvZGVyLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhKCkge1xuICAgIHJldHVybiByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChkZWNvZGUoJ0FFUUYyQU8yREVzQTJ3SXJBR3NCUkFCeEFOOEFad0NjQUV3QXFnQTBBR3dBVWdCeUFEY0FUQUFWQUZZQUlRQXlBQ0VBS0FBWUFGZ0FHd0FqQUJRQU1BQW1BRElBRkFBZkFCUUFLd0FUQUNvQURnQWJBQThBSFFBWUFCb0FHUUF4QURnQUxBQW9BRHdBRXdBOUFCTUFHZ0FSQUE0QUR3QVdBQk1BRmdBSUFBOEFIZ1FYQllNQTVCSEpBUzhKdEFZb0FlNEFFeG96aTBVQUgyMXRBYU1uQlQ4Q3JuSXlock1EaFJnRHlnSUJVQUVIY29GSFVQZThBWEJqQWV3Q2pnRFFSOElJQ0ljRWNRTHdBVFhDRGd6dkh3Qm1Cb0hOQXFzQmRCY1VBeWtnRGhBTVNoc2tNZ284QVk4anFBUWZBVUFmSHc4QkR3ODdNaW9HbENJUEJ3WkNhNEVMYXRNQUFNc3BKVmdzRGw4QUloY2tTZzhYQUhkdlR3QmNJUUVpRFQ0T1BoVXFieUVDQUVvQVMzNEFlajhZYng4M0pnVC9YdzhnSHhaLzd3OFJJQ3hQSEE5dkJ3K1BmdzhQSHdBUEZ2K2ZBc0F2Q2M4dkVyOGl2d0QvRVE4Qm9sOE9FQmEvQTc4aHJ3QVBDVTh2RVNOdnZ3V2ZId05mQVZvREhyK1pBQUVEMzRZYUFkSlBBSzdQTHdTRWdETEhBR28xUHo4UHZ4OWZVd01ycGI4Ty81OFZUekFQSUJvWEl5UUpORjhocHdJVkFUOFlHQVVBREROQmFYM1JBTW9tSkNnOUVoVWVBMjlNQUJzWkJUTU5KaXBqT2hjMTlnY0lEUjhiQndRSEVnZ0NXaTZESWdMdUFRWUErQkFGQ2hhM0E1WGlBRXNxTTdVRkZnRkxoQU1qRlRNWUUxS2xudzc0blJWQkcvQVNDbTBCWVJOL0Jyc1UzVm9XeStTMHZWOExReCt2TjhnRjJBQzJBSzVFQVd3QXBnWURLbUFBcm9RME5EUTBBVCtPQ2c3d0FBSUhSQWJwTmdWY0JWMEFQVEE1QmZiUEZnTUx6Y1lML1FxcUE4MmVCQUxLQ2pRQ2pxWUNodDAvazIrT0FzWFFBb1AzQVNUS0RnRHc2QUNLQVVZQ01wSUtKcFJhQUU0QTV3b21BQnpadnMwUkVFS2lBQ0lRQWQ1UWRBRUNBajRZd2cvd0dxWTJBVmdBWUFEWXZBb0NHQUV1YkEwZ3ZBWTJBTEFBYnBidnFweUVBR0FFcGdRQUpnQUc3Z0FnQUVBQ21naFVGd0NxQU1wQUlOUUl3QzREdGhSQUFQY3ljS2dBcG9JZEFCd0JmQ2lzQUJvQVR3QnFBU0lBdmhuU0JQOGFIL0VDZUFLWEFxNDBOamdEQlR3RllRVTZBWHMzb0FCZ0FENFhOZ21jQ1kxZUNsNXRJRlplVXFHZ3lvTkhBQmdBRVFBYUFCTndXUUFtQUJNQVRQTWEzVDM0QURsZHlwcm1NMU0yWG9jaVVRZ0x6dndBWFQzeEFCZ0FFUUFhQUJOd0lHRkFuQUREOEFBZ0FENEJCSld6YUNjSUFJRUJGTUFXd0tvQUFkcTlCV0FGNXdMUXBBTEV0UUFLVVNHa2FoUjRHbkpNK2dzQXdDZ2VGQWlVQUVDUTBCUXVMOEFBSUFBQUFES2VJaGVjbHZGcVFBQUVUcjRpQU14SUFSTWdBTUlvSGhRSUFuMEUwcERRRkM0SGh6bm9BQUFBSUFJMkMwLzRsdkZxUUFBRVRnQkpKd1lDQXk0QUJnWUFGQUE4TUJLWUVINGVSaFRrQWpZZUZjZ0FDQVlBZUFCc09xeVE1Z1J3RGF5cXVnRWdhSUlBdGdvQUNnRG1FQUJtQkFXR21lNU9CSkpBMm00Y0Rlb0FtSVRXQVh3ck1nT2dBR3dCQ2g2Q0JYWUYxVHpnMXdLQUFGZGl1QUJSQUZ3QVhRQnNBRzhBZGdCckFIWUFid0NFQUhFd2Z4UUJWRTVURVFBRFZGaFRCd0JEQU5JTEFxY0N6Z0xUQXBRQ3JRTDZ2QUFNQUw4QVBMaE5CS2tFNmdsR0tUQVU0RHI0TjJFWUV3QkNrQUJLazhySEFiWUJtd0lvQWlVNEFqZi9BcTRDb3dDQUFOSUNoemdhTkJzQ3NUZ2VPRGNGWHJnQ2xRS2RBcVFCaVFHWUFxc0NzalRzTkhzZk5QQTBpeHNBV1RXaU9BTUZQRFFTTkNrMkJEWkhOb3cyVFRaVU5oazI4Sms5VnpJM1FrRW9Bb0lDb1FLd0FxY0FRQUF4QlY0RlhiUzlCVzQ3WWtJWFAxY2lVcXMwNURTL0Z3QUJVd0pXMTFlNm5IdVlabVNoL1JBWUE4b01Ldlo4S0FTb1VBSllXQUo2SUxBc0FaU29xanBnQTBvY0JJaG1EZ0RXQUFhd1JEUW9BQWN1QWo1aUFIQUJaaVIyQUlnaUhnQ2FBVTY4QUN4dUhBRzB5Z004TWlaSUFsZ0JkRjRHYWdKcUFQWk9IQU11QmdvQVRrWUFzQUJpQUhnQU1Mb0dEUGowSHBLRUJBQU9KZ0F1QUxnZ1RBSFdBZUFNRURiZDIwVWVnZTBBRHdBV0FEa0FRZ0E5T0hkKzJNVVFaQkJoQmdOTkRreHhQeFVRQXJFUHF3dnFFUm9NMWlyUTA5MEFOSzRIOEFOWUIvQURXQU5ZQi9BSDhBTllCL0FEV0FOWUExZ0RXQndQOEIvWXhSQmtEMDBFY2dXVEJaQUUyd2lJSms0UmhnY3RDTmRVRW5RakhFd0RTZ0VCSXlwSklUdVlNeEFsUjB3UlRRZ0lBVFpIYkt4OVBRTk1NYkJVK3BDbkE5QXlWRGx4QmdNZWRoS2xBQzhQZUNFMXVrNkRla3h4cFFwUVQ3Tlg5d0JGQmdBU3F3QVM1Z0JKRFNnQVVDd0dQUUJJNHpUWUFCTkdBRTJiQUUzS0FFeGRHQUJLYUFiZ0FGQlhBRkNPQUZCSkFCSTJTV2RPYkFMRE9xMC8vUW9tQ1podndIZFRCa0lRSENlbUVQZ01OQUcyQVR3TjdrdlpCUElHUEFUS0gzNFpHZy9PbFowSXBpM2VETzRtNUM2aWdGc2o5aXFFQmU1TDlUemVDMDVSYVE5YUMyWUo1RHBrZ1U4RElnRU9Jb3dLM2cwNkNHNFE5QXJLYkEzbUVVWUhPZ1BXU1pzQXBnY0NDeElkTmhXMkpoRmlyUXNLT1hnRy9CcjNDNUFtc0JNcWV2MEYxQm9pQms0Qktoc0FBTkF1NklXeFdqSmNIVTlnQmdRTEppUElGS2xRSVEwbVFMaDRTUm9jQnhZbHFnS1NRM0ZLaUZFM0hwUWg5encrRFdjdUZGRjlCL1k4QmhsUUM0SThuMGFzUlE4UjB6Nk9QVWtpU2t3dEJEYUFMREFuakFuUUQ0WU11bnh6QVZvSklnbXlESElUTWhFWU44WUlPZ2NhTHBjbEp4WUlJa2FXWUpzRStLQUQ5QlBTQXd3RlFBbENCeFFEdGh3dUV5OFZLZ1VPZ1NYWUF2UTIxaTYwQXBCV2dRRVlCY3dQSmgvZ0VGRkg0UTdxQ0p3Q1pnT0VKZXdBTGhVaUFCZ2luQWhFWkFCZ2o5bFRCaTdNQ01ocWJTTjFBMmdVNkdJUmRBZVNEbGdIcUJ3MEZjQWM0bkRKWGd5R0NTaWtzQWxjQVhZSm1nRmdCT1FJQ2pWY2pLRWdRbWRVaTFrWW5DQmlRVUJkL1FJeURHWVZvRVMraDNrQ2pBOXNFaHdCTmdGMEJ6b05BZ0o0RWU0UmJCQ1dDT3lHQlRXMk0vazZKZ1JRSVlRZ0Vnb29BMUJzendzb0p2b00rV29CcEJKakF3MDBQbmZ2WjZ4Z3R5VVgvZ2NhTXNaQllTSHlDNU5Qemd5ZEdzSVlRMVF2R2VVSHdBUDBHdlFuNjBGWUJnQURwQVFVT2s0ejd3UytDMm9JakFsQUFFb09wQmdIMkJockNuS00wUUV5akFHNG1nTllrb1FDY0pBR09BY01BR2dNaUFWNjVnQWVBcWdJcEFBR0FOQURXQUE2QXE0SG5nQWFBSVpDQVQ0REtEQUJJdVlDa0FPVUNETE1BWll3QWZRcUJCekVEQllBK0RodVN3TERzZ0tBYTJhakJkNVpBbzhDU2pZQlRpWUVCazlJVWdPd2N1SUEzQUJNQmhUZ1NBRVdyRXZNRytSRUFlQndMQURJQVB3QUJqWUhCa0lCemdIMGJnQzRBV0FMTWdtanRMWUJUdW9xQUlRQUZtd0IyQUtLQU40QU5nQ0E4Z0ZVQUU0Rld2b0YxQUpRU2dFU01oa3NXR0lCdkFNZ0FUUUJEZ0I2QnN5T3Bzb0lJQVJ1QjlRQ0VCd1Y0Z0x2THdlMkFnTWk0QlBPUXNZQ3ZkOVdBRElYVXU1ZVp3cW9DcWRlYUFDMFlUUUhNbk05VVFBUEg2ayt5QWR5L0JaSWlRSW1Td0JRNWdCUVF6U2FOVEZXU1RZQnB3R3FLUUszOEFGdHF3Qkkvd0szN2dLM3JRSzNzQUs2MjgwQzBnSzMzQUszenhBQVVFSUFVRDlTa2xLREFyZWtBcnc1QUVRQXpBSENPMTQ3V1R0ZU8xazdYanRaTzE0N1dUdGVPMWtEbUNoWUkwM0FWVTBvSnFrS2JWOUdZZXdNcHczVlJNazZTaFBjWUZKZ014UEpMYmdVd2hYUEpWY1pQaHE5SndZbDVWVUtEd1V0MUdZeENDMDBkaGU5QUVBcGFZTkNZNGNlTVFwTUhPaFRrbFQ1TFJ3QXNrdWpNN0FOclJzV1JFRUZTSFh1WWlzV0R3b2pBbVNDQW1KRFhFNndYRGNoQXFINEFtaVpBbVlLQXArRk9Cd01BbVk4QW1ZbkJHOEVnQU4vRkFOK2t6a0hPWGdZT1lNNkpDUUNiQjRDTWpjNEN3SnR5QUp0ci9DTEFEUm9SaXdCYUFEZkFPSUFTd1lIbVF5T0FQOE13d0FPdGdKM01BSjJvMEFDZVV4RUFuaTdIbDNjUmE5RzlBSjhRQUo2eVFKOUNnSjg4VWdCU0g1a0pRQXNGa2xaU2x3V0dFck5BdEVDQXRETlN5Z0RpRkFEaCtkRXhwRXpBdktpWFFRREE2OUx6MHd1SmdUUVRVMU5zQUtMUUFLSzJjSWNDQjVFYUFhNEFvNDRBbzVkUVppQ0FvN2FBbzVkZVZHMVV6WUxVdFZVaGdLVC9BS1REUURxQUIxVkgxV3dWZEVITEJ3cGxvY3k0bmhuUlR3NkFwZWdBdSt6V0NLcEFGb21BcGFRQXBaOW5RQ3FXYTFhQ29KT0FEd0NscllDbGs5Y1JWelNBcG5NQXBsbFhNdGRDQm9Dbkp3NXd6cWVBcHdYQXArY0FwNjVpd0FlRURJckVBS2Q4Z0tla3dDMlBtRTFZZkFDbnRRQ29HOEJxZ0tlb0NBQ25rK21ZOGxrS0NZc0FpZXdBaVovQXFEOEFxQk4yQUttTUFLbHp3S29BQUIrQXFmemFIMW9zZ0FFU21vZGF0SUNyT1FDcks4Q3JXZ0NyUU1DVng0Q1ZkMENzZUxZQXg5UGJKZ0NzcjRPQXJMcEdHemhiV1J0U1dBREpjNEN0bDA4UUc2UkF5bEdBcmhmQXJsSUZnSzVLM2h3TjNEaUFyMGFBeTJ6QXpJU0FyNkpjZ01ETTNJQ3ZodHpJM05RQXNQTUFzTUZjNE4wVERaR2RPRURQS2dEUEpzRFBjQUN4WDBDeGtnQ3hoR0tBc2hxVWdMSVJRTEpVQUxKTHdKa25nTGQwM2g2WW5pdmVTWkwwUU1ZcEdjREFtSDFHZlNWSlhzTVhwTmV2QklDejJ3Q3oyMHdURlRUOUJTZ0FNZXVBczkwQVNyckEwNFRma3dHQXR3b0F0dUxBdEpRQTFKZEExTmdBUUlEVlkyQWlrQUJ6QmZ1WVVaMkFJTFBnNDRDMnNnQzJkK0VFWVJLcHowRGhxWUFNQU5rRDRaeVd2b0FWZ0xmWmdMZXVYUjRBdUl3N1JVQjh6RW9BZlNjQWZMVGlBTHI5QUxwY1hvQUF1cjZBdXJsQVBwSUFib0M3b29DNjUyV3E1Y0VBdTVBQTRYaG1IcHc0WEdpQXZNRUFHb0RqaGVabEFMM0ZBT1Jid09TaUFMM21RTDUyZ0w0WjVvZG1xeThPSnNmQTUyRUF2NzdBUndBT3A4ZG43UURCWTREcG1zRHB0b0Ewc1lEQm11aGlhSUdDZ01NU2dGZ0FTQUN0Z05HQUp3RWdMcG9CZ0M4Qkd6QUVvd2NnZ0NFREM2a2Rqb0FKQU0wQzVJS1JvQUJaQ2dpQUl6dzNBWUJMQUNrZm5nOW9naWdrZ05tV0FONkFFUUN2cmtFVnFUR0F3Q3NCUmJBQSs0aVFrTUNIUjA3MmpJMlBUYlVOc2syUmpZNU52QTIzVFpLTmlVM0VEY1pONUkrUlR4RFJUQkNKa0s1VkJZS0ZoWmZ3UUNXeWdVM0FKQlJIcHUrT3l0Z054YTYxQTQwR01zWWpzbjdCVndGWFFWY0JWMEZhQVZkQlZ3RlhRVmNCVjBGWEFWZEJWd0ZYVXNhQ055S0FLNEFBUVVIQndLVTdvSUNvVzFlN2pBRXpnUHhBK1lEd2dDa0JGREF3QURBQkt6QUFPeEZMaGl0QTFVRlREZXlQa00rYmo1MVFrUkN1d1RRV1dROFgrMEFXQll6c0FDTkE4eHd6QUdtN0VaL1Fpc29DVEFiTERzNmZuTGZiOEgyR2Njc2JnRncxM00xSEFWa0JXL0p4c205Q05STzhFOEZERDBGQlF3OUZrY0NsT1lDb01GZWdwRGZBRGdjTWlBMkFKUUFDQjhBc2lnS0FJeklFQUpLZUJJQXBZNXlQWlFJQUtRaUhiNGZ2ajVCS1NSUFFyWkNPejBvWHl4Z095d2ZLQW5HYmdNQ2xRYUNBa0lMWGdkZUNEOUlJR1VnUWo1ZlBvWStkVDUyQW81Q00wZEFYOUJUVkc5U0R6RndXVFFBYnhCekpGL2xPRUlRUWdsQ0NrS0pJQWxzNUFjQ2xRSUNvS1BNT0RFRnhoaTZLU0FiaXlmSVJyTWp0Q2dkV0NBa1BsRkJJaXRDc0VKUnpBYk1BVi9PRXlRekRnME9BUVFFSjM2aTMyOC9NazlBeWJESnNRbHEzdERSQXBVS0FrRnpYZjFkL2o5dUFMWVA2aENvRmdDVEdEOGtQc0ZLUWlvYnJtMCt6ajBLU0Q4a1BuVkNSQndNRHlKUlRIRmdNVEphNXJ3WFFpUTJZZkkvSkQ3Qk1FSkVIR0lOVHc0VE9GbElSendKTzBpY01RcHlQeVErd3pKQ1JCdjZEVmduS0IwMU5nVUtqMmJ3WXpNcUNvQmt6bkJnRUYrellESW9jd1JJWCtOZ0hqNEhJQ05maDJDNEN3ZHdGV3BURy9sZ1VoWUdBd1JmdjJUczhtQWFYelZnbWwvWFlJSmZ1V0M0SEkxZ1VGOXBZSlpnTVI2aWxRSE1BT3dMQWxEUmVmQzBpbjRBWEFFSkE2UGpDd2MwSWFtT0FOTU1DQUVDUlFERk5SVFpCZ2QrQ3dRbFJBK3I2K2dMQkRFRkJud1VCWGdLQVRJQXJ3QUdSQUFIQTNjRGRBTjJBM2tEZHdOOUEzb0RkUU43QTMwRGZBTjRBM29EZlFBWUVBQWxBdFlBU3dNQVVBRnNBSGNLQUhjQW1nQjNBSFVBZFFCMkFIVnU4VWdBeWdEQUFIY0FkUUIxQUhZQWRRQUxDZ0IzQUFzQW1nQjNBQXNDT3dCM0FBdHU4VWdBeWdEQUFIZ0tBSm9BZHdCM0FIVUFkUUIyQUhVQWVBQjFBSFVBZGdCMWJ2RklBTW9Bd0FBTENnQ2FBSGNBQ3dCM0FBc0NPd0IzQUF0dThVZ0F5Z0RBQUg0QUN3R2dBTGNCcHdDNkFhaGRBdTBDT3dMdGJ2RklBTW9Bd0FBTENnQ2FBdTBBQ3dMdEFBc0NPd0x0QUF0dThVZ0F5Z0RBQTI0QUN3TnZBQXUwVnNRQUF6c0FBQkNralVJcEFBc0FVSXVzT2dnV2NnTWVCeFZzR3dMNjdVLzJIbHptV09FZU9nQUxBU3Z1QUFzZUFmcEtVcG5wR2dZSkRDSVpNNll5QVJVRTlUaHFBRDVpWFFnbkFKWUpQbk96dzBaQUVaeEVLc0lBa0E0RGhBSG5UQUlEeHhVREswbHhDUWxQWWdJdklRVllKUUJWcUUxR2FrVUFLR1lpRFRvU0JBMUV0QVlBWFFKWUFJRjhHZ01IUnlBQUlBak9lOVluY2VrUkFBMEtBQ1VyandFN0F5YzZBQVlXQXFhaUtHNE1jRWNxQU5vTjMrTWc5VHdDQmhJa3VDbnkrSndVUTI5TDAwOEpsdVJ4dTNLK29BZHFpSE9xRkgwQUc1U1VJZlVKNVN4Q0dmeGRpcFJ6cVRtVDRWNVpiK3IxVW80Vm0rTnFTU0VsMm1OdlIySmhJYThTcFlPNm50ZHdGWEhDV1RDSzhmMitIeG83dWlHM2RyRHljQXVLSU1QNWJoaTA2QUNucUFySDFyejRScWcvL2xtNlNnSkdFVmJGOXhKSElTYVI2SHhxeFNua3c2c2hEbmVsSEtORWZHVVhTSlJKMUdjc210SncyNXhyWk1ESzlnWFNtMS9ZTWtkWDQvNk5LWU9kdGsvTlEzL05uREFTalRjM2ZQaklqVy81c1ZmVk9iWDJvVERXa3IxZEY5ZjNreEJzRDMvM2FRTzhoUGZSeitlMHVFaUpxdDExNjFncml1N2d6OGhERHd0cHkrRitCV3RlZm5LSFpQQXhjWm9XYm56bmhKcHkwZTg0MmozNmJjTnpHbklFdXNnR1gwYThaeHNuamNTc1BEWjA5eVozNmZDUWJyaUhlUTcySlJNSUxObDZlUFBmMkhXb1Z3Z1dBbTFmYjNWMnNBWTArQjZyQVhxU3dQQmdzZVZtb3FzQlRTcm05MStYYXNNWVl5U0k4ZWVSeEgzWnZIa016M0JRNWFKM2lVVmJZUE5NMy83ZW1SdGpsc01ndi85VnlUc3l0L21LKzhmZ1dlVDZTb0ZhY2xYcW40MmRBSXN2QWFyRjV2Tk5XSHpLU2tLUS84SGZrNVpXSzdyOXlsaU9zb295QmpSaGZrSFA0UTJEa1dYUWk2RkcvOXIvSXdibWtWNVQ3SlNvcEhLbjFwSndtOXRiNU90MG95TjFaMm1QcEtYSFR4eDJubEswOGZLazFoRVlBOFdnVlZXTDVsZ3gwaVR2K0tkb2pKZVUyM1pEam1pdWJYT3hWWEpLS2kyV2p1aDJITFpPRkxpU0M3VGxzNVNNaDRmK1BqNnhVU3JOakZxTEdlaFJOQjhsQzBRU0xObWtKSngvd1NHM01uakU5VDFDa1B3Skkwd0gybGZ6d0VUSWlWcVV4ZzBkZnU1cTM5R3QraHdkY3hraGhOdlE0VHlyQmNlb2YzTWhzL0l4RmNpMUhtSHI0Rk1aZ1hFRWN6UGlHQ3gwSFJ3ekFxRHEyajlBVm0xa3dOMG1SVkxXTHlsZ3RvUE5hcEY1Y1k0WTF3SmgvZTBCQndaajQ0WWdackROcXZELzlIdjdHRllkVVFlREp1UTNFV0k0SGFLcWF2VTFYakMvbjQxa1Q0TDc5a3FHcTBrTGhkVFp2Z1AzVEEzZlMwb3pWeis1cGlac29PdEl2QlVGb01LYk5jbUJMNll4eGFVQXVzSEIzOFhyUzhkUU1uUXdKZlVVa3BSb0dyNUFVZVdpY3ZCVHp5SzlnNzcreUNrZjVQQXlzTDdyL0pqY1pncmJ2UnBNVzlpeWF4WnZLTzZjZVpOMkV3SXhLd1ZGUHV2RnVpRVBHQ29hZ2JNbytTcHlkTHJYcUJ6TkNER0ZDck8vcmtjd2EyeGhva1FaNUNkWjBBc1UzSmZTcUo2bjVJMTRZQStQL3VBZ2ZoUFU4NFRsdzdjRUZmcDdBRUU4ZXk0c1AxMlBUdDRDb2RzMUdSZ0RPQjV4dnlpUjVtK0J4OE81bkJDTmN0VThCZXZmVjVBMDh4NlJIZDVqY3dQVE1EU1pKT2VkSVoxY0dRNzA0bHhiQXpxWk9QMDVaeGFPZ2h6U2R2RkJIWXFvbUFUQVJ5QUFESzRlbFA4THkzSXJVWktmV2gyM1h5MjB1QlVtTFM0UGZhZ3U5K295VmEyaVBncVJQM0YyQ1RVc3ZKNytSWW5OOGZGWmJVL0hWdnh2Y0ZGREtraVRxVjVVQlozR3o1NEpBS0J5aTloa0tNWkp2dUdnY1NZWEZtdzA4VXlvUXlWZGZURDEvZE1rQ0hYY1RHQUtlUk9nQXJzdm1SclFUTFVPWGlvT0hHSzJRa2pIdW9ZRmdYY2lab1RKZDZGczVxMVFYMUcrcC9lMjZoWXNFZjdRWkQxbm5JeWwvU0ZrTnRZWW1tQmhwQnJ4bDlXYlkwWXBIV1J1dzJMbC90ajltRDhQNHNuVnpKbDRGOUorMWFyVmVUYjlFNXIySUxIMDRxU3RqeFFOd24zbTRZTnF4bWFOYkxBcVcyVE42TGlkd3VKUnFTK05YYnRxeG9lRFhweGVHV214elNrV3hqa3lDa1g0TlFSbWU2cTVTQWNDK003KzlFVGZBL0V3cnpRYWpLYWtDd1l5ZXVuUDZaRmx4VTJvTUVuMVB6MzF6ZVN0Vzc0RzQwNlpKRkNsMXdBWElvVUtrV290WUVwT3VYQjF1Vk54SjYzZHBKRXFmeEJlcHR3SUhOclB6OEJsbFpvSWNCb1h3Z2ZKKzhWQVVuVlB2UnZleG53ME1hL1dpR1l1Sk81eThRVHZFWUJpZ0ZtaFV4WTVScXpFOE9jeXdOLzhtNFVZcmxhbmlKTzc1WFE2S1NvOSt0V0hsdStoTWkwVVZkaUtRcDdOZWxub1pVek5hSXlCUFZlT3dLNkdOcCtGZkh1UE9veWhhV3VOdlRZRmt2eHNjTVFXRGgremVGQ0ZrZ3diWGZ0aVYyM3l3SjQrdXdScW1nOWszS3p3SVFwenBwdDhEQkJPTWJycXdRTTVHYjA1c0V3ZEt6TWlBcU9sb2FBL2xyMEtBKzFwcjAvK0hpV29pSWpIQS93aXIybkl1UzNQZVUvamkzTzZad294Y1IxU1o5Rmh0TEM1UzBGSXpGaGJCV2NHVlAvS3B4T1BTaVVvQWRXVXBxS0grKzZTY3o1MDdpQ2N4WUk2cmRNQklDUEpaZWE3T2NtZUZ3NW1PYkpTaXFwamcyVW9XTklzK2NGaHlEU3Q2Z2VWNXFnaTNGdW5td3dEb0dTTWdlckZPWkdYMW0wZE1DWW81WE9ydXhPMDYzZHdFTks5RGJuVk05d1lGUkV6aDR2eVUxV1lZSi9MUlJwNm94Z2pxUC9YNWE4LzRBZjZwNk5Xa1FmZXJ6Qm1YbWUwelkvNG53TUptL3dkMXRJcVN3R3orRTN4UEVBT29abEppdDNYZGRENy9CVDFwbGx6T3grOGJtUXRBTlEvUzZmWmV4YzZxaTNXK1EyeGNtWFRVaHVTNW1wSFFSdmN4WlVOMFM1K1BMOWxYV1VBYVJaaEVIOGhUZEFjdU5NTUN1Vk5LVEVHdFNVS05pM082S2hTYVR6Y2s4Y3NaMnZXUlorZDdtVzhjNElLd1hJWWQyNVMveklmdFBrd1B6dWZqRXZPSFdWRDFtK0ZqcERWVVRWMERHRHVIajZRbmFFd0x1L2RFZ2RMUU9nOUUxU3JvOVhISjh5a0xBd3RQdStweHFLRHVGZXhxT04xc0tRbTdyd2JFMUU2OFVDZkEvZXJvdnJUQ0crREJTTmcwbDRnb0RRdlpONnVObGJ5THBjWkF3ajJVY2x5Y3ZMcElaTWd2NHlSbHBiM1l1TWZ0b3pvcmJjR1ZIdC9WZURWMytGZGYxVFAwaXVhQ3NQaTJHNFhlR2hzeUYxdWJWRHhrb0pobW5pUTAvalNnL2VZTUw5S0xmbkNGZ0lTV2twOTFlYXVSM0lRdkVEMG5BUFhLKzZoUENZcytuMytoQ1piaXNrbVZNRzJkYSswRXNaUG9uVWVJWThFYmZ1c1FYanNLL2VGRGFvc2JQakVmUVMwUktHN3lqNUdHNjlNN01lTzFIbWlVWW9jZ3lnSkhMNk0xcXpVRER3VVNtcjk5VjdTZHIyRjNKalFBSlkrRjB5SDMzSXYzK0M5TTM4ZU1MN2dUZ21OdS9yMmJVTWlQdnBZYlo2djEvSWFFU2lyQkhOYTdtUEtuNGRFbVlnN3YvK0hRZ1BOMUc3OWpCUTErc295ZGZEQzJyK2gyQmwvS0ljNUtqTUs3T0g2bmIxakxzTmYwRUhWZTJLQmlFNTFveDYzNnV5RzZMaG8wdDNKMzRMNVFZL2lsRTNtaWthRjRIS1hHMW1HMXJDZXZUMVZ2Nkdhdmx0eG9RZS9iTXJwWnZSZ2duQnhTRVBFZUV6a0VkT3hUblBYSFZqVVlkdzhKWXZqQi9vN0VlZ2MzTWErTlV4TExuc0swa0psaW5QbVVIekhHdHJrNStDQWJWekZPQnFweXkzUVZVbnpURGZDLzBYRDk0L29rSCtPQitpN2c5bG9saFdJalNuZkliK0VxNDNaWE9XbXd2anlWL3FxRCt0MGUrN21URU03NHFQL096dDhubUM3bVJweXU2M09CNEtuVXpGYzA3NFNxb3lQVUFnTSsvVEpHRm82VDQ0RUhuUVU0WDR6NnFhbm5WcWd3L1U3ekNwd2NtWFYxQXViSXJ2T21rS0hhekpBUjU1ZVBqcDV0TEJzTjh2QXFzM05BSGRjRUhPUjJ4UTBsc05BRnpTVXV4RlFDRll2WExaSmRPajlwNGZOcTZwMEhCR1VpazJZemFJNHh5U3k5MUt6aFEwK3ExaGp4dkltUndQUmY3NnRDaGxSa2hSQ2k3NE5YWjlxVU5lSXdQK3M1cCszbTVud1BkTk9IZ1NMRDc5bjdPOW0xbjF1REhpTW50cTRua1l3VjVPWjFFTmJYeEZkNFBncmx2YXZac3lVTzRNcVlscXFuMU84Vy9JMWRFWnE1ZFhocmJFVExhWkliQzJLai9BYS9RTStmcVVPSGRmMHRYQVExaHVaM2NtV0VDV1NYeS80M2ozNStNdnE5eHdzN0pLc2VyaVoxcEVXS2M4cWx6TnJHUFVHY1ZnT2E5Y1BKWUlKc0duSlRBVXNFY0RPRVZVTE81eDByWEJpamMxbGdYRXpRUUtoUk9mOHpJVjgydzhlc3djNzhZWDExS1lMV1FSY2dITkpFbEJ4ZlhyNzJsUzJSQlNsMDdxVEtvck8ydVVEWnIzc0ZoWXN2bmhMWm4wQTk0S1J6Si83REVHSUFoVzVaV0ZwTDhnRXd1MWFMQTlNdVdaek53bDhPemU5WStiWCt2OWd5d1JWbm9CNUkvOGtYVFhVMzE0MXlSTFlySU9PejZTT255SE55NFNpZXF6a0JYaGFyamZqcXExcTZ0a2xhRWJBOFFmbTJEYUlQczdPVHEvbnZKQmpLZk8ySDliSDJjQ01oMSs1Z3NwZnljdThmL2N1dVJtdERqeXFaN3VDSU15amRWM2ErcDNmcW1Yc1J4NEM4bHVqZXpJRkhuUWlWVFhMWHVJMVhyd04zK3NpWVlqMkhIVHZFU1V4OERsT1RYcGFrOXFGUksrTDNtZ0oxV3NEN0Y0Y3UxYUpvRm9ZUW51K3dHRE1PakpNM2tpQlFXSENjdmhKL0hSZHhvZE9RcDQ1WVphT1RBMjJOYjRYS0NWeHFrYndNWUZoellRWUlBbkNXOEZXMTR1Zjk4amhVRzJ6cktoUVEwcTBDRXEwdDVuWHl2VXl2UjhEdkQ2OUxVK2czaStIRldRTVE4UHFadUhEK3NOS0FWMCtNNkVKQzBzenE3ckVyN0I1YlE4QmNOSHp2RE1jOWVxQjVaQ1FkVGY4ME9ibjR1emp3cFlVN1NJU2R0VjBRR2E5RDNXcmgyQkRRdHBCS3hhTkZWKy9DeTJQL1N2KzhzN1VkMEZkNzRYNCtvL1ROenRXZ0VUVWFweSttYWpOUTY4THEzZWUwWk80OFZFYlRaWWlIMUNvNE9sZldlZjgyUldleVVYbzd3b00wM1B5YXBHZmlrVG5RaW5vTnE1ejV2ZUxwZU1WM0hDQU1UYVptQTFvR0xBbjdYUzNYWXN6K1hLN1ZNUXNjNFhLcm1EWE9MVS9wU1hWTlVxOGRJcVRiYS8vLzN4NkxpTFM2eHMxeHVDQVlTZmNRMytyUWdtdTd1dmYzVEhLdDVPb285N1RxY2JScXh4N0VBU2l6YVFDQlFsbEcvcll4VmFwTUxndExiWlM2NHcxTURCTVhYK1BRcEJLTndxVUtPZjJERFJEVVhRZjlFaE9TMFFqNG5UbWxBOGR6U0x6L0cxZCtVZDhNVHkvNmdoaGRpTHBlZXJHWS9VbERPZml1cUZzTVVVNS9VWWxQK0JBbWdSTHVOcHZyVWFMbFZrcnFEaWV2TlZFQXdGKzRDb00xTVpUbWp4akpNc0tKcSt1OFpkN3ROQ1VGeTZMaXlZWFJKUTRWeXZFUUZGYUNHS3N4SXdRa2s3RXpaNkxUSnEyaFV1UGh2QVcrZ1FuU0c2SitNc3pDKzdRQ1JIY25xRGR5TlJKNlQ5eHlTODdBNk1EdXRiektHdkdrdHBiWHF0eld0WGI5SHNmSzJjQk1vbWpOOWE0eStUYUpMblh4QWVYL0hXem1mNGNSNHZBTHQvUDR3NHFnS1kwNG1sNFpkTE9pbkZZUzZjdXAzRy8xaWU0K3QxZU9ucEJObHFHcXM3NWlsemtUNCtEc1pReE52YVNLSi8vNnpJYmJrL003TE9oRm1SYy8xUitrQnR6N0pGR2RabS9DT290SWR2UW9YcFRxUC8xdXFFVW1DYi9RV29HTE13TzVBTmNIenhkWTQ4SUdQNStKK3pLT1RCRlo0UGlkK0dUTStXcTEyTVYvSDg2eEVKcHRCYTZUK3Aza2dwd0xlZE1hbkJIQzJHZ05yRnBvTjJ4bnJNejlXRldYLzgveWdTQmthdnEyVXY3RmRDc0xFWUx1OUxMSXZBVTBiTlJEdHpZbCsvdlhtanBJdnVKRllqbUkwaW02UUVZcW5JZU1zTmpYRzR2SXV0SUdIaWplQUcvOUVEQm96S1Y1Y2xka0hiTHhIaDI1dlQrWkV6YmhYbHF2cHpLSndjRWdmTndMQUtGZW8wL3B2RUUxMFhEQitFWFJUWHRTekpvelFLRkZBSmhNeFlrVmFDVytFOUFMN3RNZVU4YWN4aWRIcXpiNmxYNDY5MVVzRHB5L0xMUm1UK2VwZ1c1Nis1Q3c4dEI0a01VdjZzOWxoM2VSS2J5R3MrSC80bVFNYVl6UFRmMk9PZG9rRW4renpndm9EM0ZxTktrOFFxR0FYVnNxY0dkWHJUNjJmU1BrUjJ2Uk9GaTY4QTZzZTg2VXhSVWs0Y2FqZlB5Q0M0RzV3RGhEK3pOcTRqb2RRNHU0bi9tMzdMcjM2bjRMSUFBc1ZyMDJkRmk5QWl3QTgxTVlzMnJtNGVEbERObWRNUnZFS1JIZkJ3VzVEZE1OcDBqUEZaTWVBUnFGL3dMNFhCZmQrRU1MQmZNenBINUdINk5hVysxdnJ2TWRnK1Z4RHphdGszTVhnTzNybzNQL0RwY0M2K01vNE15U0poS0poU1IwMVNHR0dwNWhQV21yclVncnYzbERuUCtIaGNJM250M1lxQm9WQVZUQkFRVDVpdWhUZzhudlB0ZDhaZVlqNncxeDZScUdVQnJTa3U3K04xK0JhYXNadmpUazY0Um9JRGxMOGJycEVjSngzT21ZN2pMb1pzc3dkdG1oZkMvRzIxbGxYaElUT3dtdlJERGVUVFBieUFTT2ExNmNGNS9BMWZaQWlkSnBxanUzd1lBeTlhdlBSMXlhNmVOcDlLOFhZcnJ0dXhscWkrYkRLd2xmcllkUjBSUmlLUlZUTE9IODUrWlk3WFNtelJwZlpCSmphVGE4MVZEY0pIcFpuWm5TUUxBU0dZVzlsNTFaVi9oN2VWelRpM0h2NmhVc2djLzUxQXFKUlRrcGJGVkxYWHN6b0JMOG5CWDB1LzBqQkxUOG5IK2ZKZVBicndVUlQ1OE9ZK1VpZVJqZDF2czA0dzBWRzVWTjJVNk1vR1prUXpLTi9wdHowUTM2NmR4b1RHbWo3aTFOUUdIaTlHZ25xdVhGWWRyQ2ZaQm1lYjdzMFQ2eXJkbFpINWNadXdIRnlJSi9rQXRHc1RnMHhINXRhQUFxNDRCQWsxQ1BrOUtWVmJxUXpyQ1VpRmRGLzZndGxQUThiSEhjMUcxVzkyTVhHWjVIRUhmdHlMWXM4bWJELzl4WVJVV2tIbWxNMHpDMmlsSmxuTmdWNGJmQUxwUWdoeE9Vb1pMN1ZUcXRDSElhUVNYbStZVU1ucGtYeWJuVitBNnhsbTJDVnk4Zm4wWGxtMlhSYTArenpPYTIxSldXbWl4ZmlQTVNDWjdxQTRyUzkzVk4zcGtwRjFzNVRvblFqaXNIZjdpVTlaR3ZVUE9BS1pjUjFwYmVWZi9VbDdPaGVwR0NhSWQ5d090cW83cEo3eUxjQlowcEZrT0YyOHk0ekVJL2tjVU5tdXRCSGFRcEJkTk04dmpDUzZIWlJva2tlbzg4VEJBakd5RzdTUis2dlVnVGN5SzlJbWFsajBrdXh6MHdtSytieVFVMTFBaUpGay95YTVkTmR1UkNsY25VNjR5R3UvaWVXU2VPb3MxdDNlcCtSUElXUTJweVRZVmJabHRUYnNiN05pd1NpM0FWKzhLTFdrN0x4Q25mWlVldEVNOFRobnNTb0dIMzgvbnlBd0ZndUpwOEZqdmxIdGNXWnVVNGhQdmEwckhmcjBVaE9PSi9GNnZTNjJGVzdLemttUmxsMkhFYzdvVXE0ZnlpNVQ3MFZsN1lWSWZzUEhVQ2RIZXNmOUxrN1dOVldPNzVKRGtZYk1JOFRPVzhKS1Z0TFk5ZDZVSlJJVE84b0tvMHhTK285OVl5MDRpbmlHSEFhR2o4OGtFV2d3djBPckhkWS9ucjc2RE9HTlM1OWhYQ0dYelRLVXZEbDlpS3BMU1dZTjFseElleXl3ZE5wVGtoYXk3NHcyakZUNk5TOHFram81Q3hBMXlmU1l3cDZBSklaTktJZUVLNVBKQVc3T1JnV2d3cDBWZ3pZcHFvdk1yV3hidStER1o2TGhpZTFSQXFwem04VlV6S0pPSDNtQ3pXdVRPTHNOM1ZUL2R2MmVlWWU5VWpiUjhZVEJzTHo3cTYwVk4xc1U1MWsrdW0xZjhKeEQ1cFBoYmhTQzhyUmFCNDU0dG1oNllVV3JKSTMrR1dZMHFlV2lvai90YmtZSVRPa0phZXVHdDRKckp2SEErbDBHdTdrWTdYT2FhMDVhbE1uUldWQ1hxRmdMSXdTWTR1RjU5VWU1U1U0UUt1Yy9IYW1EeGJyMHg2Y3NDZXRYR29QN1FuMUJrL0o5RHN5bk8vVUQ2aVoxSHlyeitqaXQwaERDd2kvRTlPamdLVGJCM1pRS1EvMFpPdmV2Zk5IRzBOSzRBajNDcDdOcFJrMDdSVDFpL1MwRUw5M0FnOEdSZ0tJOUNmcGFqS3lLNitKai9QSTFLTzUvODVWQXd6MkF3elA4RlRCYjA3NUl4Q1h2NlQ5UlZ2V1QydFVhcXhEUzkyenJHVWJXelVZazltU3M4MnBFQ0grZmtxc0R0OTNWVysrNFlzUi9kSENZY1FTWVRPL0thQk1EajlMU0QvSi8rejIwS3E4WHZaVUFJSHRtOWhSUFAzSXRidUF1MkhtNWxrUHM5MnBkN2tDeGdSczB4T1ZCbloxM2NjZEEwYXVucnd2OVNkcUVsSlJDM2crb0N1K25YeUNnbVhVczl5TWpUTUFJSGZ4WlYrYVBLY1plVUJXdDA1N1hvODVLczFJcjVnekVIQ1dxWkVockxaTXVGMTF6aUd0RlFVZHMvRUVTYWpoYWd6Y0tzeGFtY1NaeEd0aDRVSUkrYWRQaFFrVW54Mld5Tis0WVdSK3IzZjhNbmt5R0Z1UjR6anp4SlM4V3NRWVI1UFR5UmFEOWl4YTZNaDc0MW5CSGJ6ZmpYSHNrR0RxMTc5eGFSTnJDSUIxejF4UmZXZmpxdzJwSGMxems5eGxQcEw4c1FXQUl1RVRaWmhibm1MNTRyY2VYVk5SdlVpS3JycUlrZW9nc2wwWFhiMTd5bE5iMGY0R0E5V2Q0NHZmZkVHOEZTWkdIRUwyZmJhVEdSY1NpQ2VBOFBtQS9mNkh6OEhDUzc2ZlhVSHdnd2t6U3dsSTcxZWtaN0ZhcG1say9LQytIczhoVWN3M04yTE41TGhrVll5aXpZRmwvdVBlVlA1bHNvSkhoaGZXdnZTV3J1Q1VXMVpjSk9ldVRickRneXdKL3FHMDdnWkpwbG5UdkxjWWROYUgwS01ZT1lNR1grckI0TkdQRm1Rc05hSXdsV3JmQ2V6eHJlOHpYQnJzTVQrZWRWTGJMcU4xQnFCNzZKSDRCdlpUcVVJTWZHd1BHRW4rRW5tVFY4NmZQQmFZYkZMM0RGRWhqQjQ1Q2V3a1hFQXRKeGs0L01zMnBQWG5hUnFka3kwSE9ZZGNVY0UyemNYcTR2YUl2VzIvdjBuSEZKSDJYWGUyMnVlRG1xLzE4WEd0RUxTcTg1ajlYOHEwdGNOU1NLSklYOEZUdUpGL1BmOGo1UGhxRzJ1K29zdnNMeFlydnZmZVZKTCs0dGtjWGNyOUpWN3YwRVJtai9YNmZNM05DNGo2ZFMxKzlVbXIyb1BhdnFpQXlkVFpQTE1OUkdZMjNMTzl6QVZEbHk3akQrNzBHNVRQUExkaFJJbDRXeGNZakxuTStTTmNKMjZGT3JrcklTVXRQT2JJejVaYjNBRzYxMmtybnB5MTVSTVcrMWNRamxuV0ZJNjUzOHFreTlheGQyb0ptSElIUDA4S3lQMHViR08rVFFOT1l1djJ1aDE3eUNJdlI4VmNTdHc3bzFnME5NNjBzays4VHE3WWZJQkpydHA1M0drdnpYSDdPQTBwOC9uL3Uxc2F0Zi9WSmh0UjFsOFdhNkdtYXVnN2hhU3BhQ2FZUWF4NnRhMG1rdXRsYitlQU9TRzFhb2JNODFEOUE0aVMxUlJsekJCb1ZYNnRVMVM2V0UyTjlPUlk2RGZlTFJDNGw5UnZyNWg5NVhEV0IybVIxZDRXRnVkcHNnVll3aVR3VDMxbGpza0Q4WnlET2xtNURrR2g5Ti9VQi8wQUk1WHZiOFpCbWFpMmhRNEJXTXFGd1luenh3QjI2WUhTT3Y5V2dZM0pYbnZvTisyUjRycUdWaC9MTERNdHBGUCtTcE1HSk5XdmJJbDVTT29kYkNjelcyUktsZWtzUG9VZUdFenJqdEtIVmR0WkEra2ZxTytyVngvaWNsQ3F3b29wZXB2SnBTVERqVCtiOUdXeWxHUkY4RURiR2x3NmVVem1KTTk1T3Zveitrd0xYM2MyZlRqRmVZRXNFN3ZVWm0zbXFkR0p1S2gydzkvUUdTYXFSSHM5OWFTY0dPZERxa0ZjQUNvcWRiQm9RcXFqYW1oSDZROW5nMzlKQ2czbHJHSndkNTBRazlvdm5xQlRyOE1NRTdQczJ3aVZmeWdVbVBvVUJKSmZKV1g1TmRhMG51bmNiRmtBPT0nKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmNsdWRlLmpzLm1hcCJdLCJuYW1lcyI6WyJkZWNvZGUiLCJyZWFkX2NvbXByZXNzZWRfcGF5bG9hZCIsImdldERhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ens_normalize: () => (/* binding */ ens_normalize),\n/* harmony export */   ens_normalize_post_check: () => (/* binding */ ens_normalize_post_check)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _include_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./include.js */ \"(ssr)/./node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js\");\n/* harmony import */ var _decoder_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decoder.js */ \"(ssr)/./node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js\");\n/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */ \n\nconst r = (0,_include_js__WEBPACK_IMPORTED_MODULE_0__.getData)();\n\n// @TODO: This should be lazily loaded\nconst VALID = new Set((0,_decoder_js__WEBPACK_IMPORTED_MODULE_1__.read_member_array)(r));\nconst IGNORED = new Set((0,_decoder_js__WEBPACK_IMPORTED_MODULE_1__.read_member_array)(r));\nconst MAPPED = (0,_decoder_js__WEBPACK_IMPORTED_MODULE_1__.read_mapped_map)(r);\nconst EMOJI_ROOT = (0,_decoder_js__WEBPACK_IMPORTED_MODULE_1__.read_emoji_trie)(r);\n//const NFC_CHECK = new Set(read_member_array(r, Array.from(VALID.values()).sort((a, b) => a - b)));\n//const STOP = 0x2E;\nconst HYPHEN = 0x2D;\nconst UNDERSCORE = 0x5F;\nfunction explode_cp(name) {\n    return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__.toUtf8CodePoints)(name);\n}\nfunction filter_fe0f(cps) {\n    return cps.filter((cp)=>cp != 0xFE0F);\n}\nfunction ens_normalize_post_check(name) {\n    for (let label of name.split(\".\")){\n        let cps = explode_cp(label);\n        try {\n            for(let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--){\n                if (cps[i] !== UNDERSCORE) {\n                    throw new Error(`underscore only allowed at start`);\n                }\n            }\n            if (cps.length >= 4 && cps.every((cp)=>cp < 0x80) && cps[2] === HYPHEN && cps[3] === HYPHEN) {\n                throw new Error(`invalid label extension`);\n            }\n        } catch (err) {\n            throw new Error(`Invalid label \"${label}\": ${err.message}`);\n        }\n    }\n    return name;\n}\nfunction ens_normalize(name) {\n    return ens_normalize_post_check(normalize(name, filter_fe0f));\n}\nfunction normalize(name, emoji_filter) {\n    let input = explode_cp(name).reverse(); // flip for pop\n    let output = [];\n    while(input.length){\n        let emoji = consume_emoji_reversed(input);\n        if (emoji) {\n            output.push(...emoji_filter(emoji));\n            continue;\n        }\n        let cp = input.pop();\n        if (VALID.has(cp)) {\n            output.push(cp);\n            continue;\n        }\n        if (IGNORED.has(cp)) {\n            continue;\n        }\n        let cps = MAPPED[cp];\n        if (cps) {\n            output.push(...cps);\n            continue;\n        }\n        throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);\n    }\n    return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));\n}\nfunction nfc(s) {\n    return s.normalize(\"NFC\");\n}\nfunction consume_emoji_reversed(cps, eaten) {\n    var _a;\n    let node = EMOJI_ROOT;\n    let emoji;\n    let saved;\n    let stack = [];\n    let pos = cps.length;\n    if (eaten) eaten.length = 0; // clear input buffer (if needed)\n    while(pos){\n        let cp = cps[--pos];\n        node = (_a = node.branches.find((x)=>x.set.has(cp))) === null || _a === void 0 ? void 0 : _a.node;\n        if (!node) break;\n        if (node.save) {\n            saved = cp;\n        } else if (node.check) {\n            if (cp === saved) break;\n        }\n        stack.push(cp);\n        if (node.fe0f) {\n            stack.push(0xFE0F);\n            if (pos > 0 && cps[pos - 1] == 0xFE0F) pos--; // consume optional FE0F\n        }\n        if (node.valid) {\n            emoji = stack.slice(); // copy stack\n            if (node.valid == 2) emoji.splice(1, 1); // delete FE0F at position 1 (RGI ZWJ don't follow spec!)\n            if (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\n            cps.length = pos; // truncate\n        }\n    }\n    return emoji;\n} //# sourceMappingURL=lib.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL2Vucy1ub3JtYWxpemUvbGliLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTJCQyxHQUN5RDtBQUNuQjtBQUN2QyxNQUFNRSxJQUFJRCxvREFBT0E7QUFDa0U7QUFDbkYsc0NBQXNDO0FBQ3RDLE1BQU1LLFFBQVEsSUFBSUMsSUFBSUosOERBQWlCQSxDQUFDRDtBQUN4QyxNQUFNTSxVQUFVLElBQUlELElBQUlKLDhEQUFpQkEsQ0FBQ0Q7QUFDMUMsTUFBTU8sU0FBU0wsNERBQWVBLENBQUNGO0FBQy9CLE1BQU1RLGFBQWFMLDREQUFlQSxDQUFDSDtBQUNuQyxvR0FBb0c7QUFDcEcsb0JBQW9CO0FBQ3BCLE1BQU1TLFNBQVM7QUFDZixNQUFNQyxhQUFhO0FBQ25CLFNBQVNDLFdBQVdDLElBQUk7SUFDcEIsT0FBT2Qsd0VBQWdCQSxDQUFDYztBQUM1QjtBQUNBLFNBQVNDLFlBQVlDLEdBQUc7SUFDcEIsT0FBT0EsSUFBSUMsTUFBTSxDQUFDQyxDQUFBQSxLQUFNQSxNQUFNO0FBQ2xDO0FBQ08sU0FBU0MseUJBQXlCTCxJQUFJO0lBQ3pDLEtBQUssSUFBSU0sU0FBU04sS0FBS08sS0FBSyxDQUFDLEtBQU07UUFDL0IsSUFBSUwsTUFBTUgsV0FBV087UUFDckIsSUFBSTtZQUNBLElBQUssSUFBSUUsSUFBSU4sSUFBSU8sV0FBVyxDQUFDWCxjQUFjLEdBQUdVLEtBQUssR0FBR0EsSUFBSztnQkFDdkQsSUFBSU4sR0FBRyxDQUFDTSxFQUFFLEtBQUtWLFlBQVk7b0JBQ3ZCLE1BQU0sSUFBSVksTUFBTSxDQUFDLGdDQUFnQyxDQUFDO2dCQUN0RDtZQUNKO1lBQ0EsSUFBSVIsSUFBSVMsTUFBTSxJQUFJLEtBQUtULElBQUlVLEtBQUssQ0FBQ1IsQ0FBQUEsS0FBTUEsS0FBSyxTQUFTRixHQUFHLENBQUMsRUFBRSxLQUFLTCxVQUFV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QVc7UUFDakM7SUFDSjtJQUNBLE9BQU9oQjtBQUNYLEVBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1zdGFydGVyLWtpdC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vZW5zLW5vcm1hbGl6ZS9saWIuanM/OTE1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1JVCBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIxIEFuZHJldyBSYWZmZW5zcGVyZ2VyXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGlzIGEgbmVhciBjYXJib24tY29weSBvZiB0aGUgb3JpZ2luYWwgc291cmNlIChsaW5rIGJlbG93KSB3aXRoIHRoZVxuICogVHlwZVNjcmlwdCB0eXBpbmdzIGFkZGVkIGFuZCBhIGZldyB0d2Vha3MgdG8gbWFrZSBpdCBFUzMtY29tcGF0aWJsZS5cbiAqXG4gKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJhZmZ5L2Vucy1ub3JtYWxpemUuanNcbiAqL1xuaW1wb3J0IHsgdG9VdGY4Q29kZVBvaW50cyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5pbXBvcnQgeyBnZXREYXRhIH0gZnJvbSAnLi9pbmNsdWRlLmpzJztcbmNvbnN0IHIgPSBnZXREYXRhKCk7XG5pbXBvcnQgeyByZWFkX21lbWJlcl9hcnJheSwgcmVhZF9tYXBwZWRfbWFwLCByZWFkX2Vtb2ppX3RyaWUgfSBmcm9tICcuL2RlY29kZXIuanMnO1xuLy8gQFRPRE86IFRoaXMgc2hvdWxkIGJlIGxhemlseSBsb2FkZWRcbmNvbnN0IFZBTElEID0gbmV3IFNldChyZWFkX21lbWJlcl9hcnJheShyKSk7XG5jb25zdCBJR05PUkVEID0gbmV3IFNldChyZWFkX21lbWJlcl9hcnJheShyKSk7XG5jb25zdCBNQVBQRUQgPSByZWFkX21hcHBlZF9tYXAocik7XG5jb25zdCBFTU9KSV9ST09UID0gcmVhZF9lbW9qaV90cmllKHIpO1xuLy9jb25zdCBORkNfQ0hFQ0sgPSBuZXcgU2V0KHJlYWRfbWVtYmVyX2FycmF5KHIsIEFycmF5LmZyb20oVkFMSUQudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IGEgLSBiKSkpO1xuLy9jb25zdCBTVE9QID0gMHgyRTtcbmNvbnN0IEhZUEhFTiA9IDB4MkQ7XG5jb25zdCBVTkRFUlNDT1JFID0gMHg1RjtcbmZ1bmN0aW9uIGV4cGxvZGVfY3AobmFtZSkge1xuICAgIHJldHVybiB0b1V0ZjhDb2RlUG9pbnRzKG5hbWUpO1xufVxuZnVuY3Rpb24gZmlsdGVyX2ZlMGYoY3BzKSB7XG4gICAgcmV0dXJuIGNwcy5maWx0ZXIoY3AgPT4gY3AgIT0gMHhGRTBGKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbnNfbm9ybWFsaXplX3Bvc3RfY2hlY2sobmFtZSkge1xuICAgIGZvciAobGV0IGxhYmVsIG9mIG5hbWUuc3BsaXQoJy4nKSkge1xuICAgICAgICBsZXQgY3BzID0gZXhwbG9kZV9jcChsYWJlbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gY3BzLmxhc3RJbmRleE9mKFVOREVSU0NPUkUpIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY3BzW2ldICE9PSBVTkRFUlNDT1JFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5kZXJzY29yZSBvbmx5IGFsbG93ZWQgYXQgc3RhcnRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3BzLmxlbmd0aCA+PSA0ICYmIGNwcy5ldmVyeShjcCA9PiBjcCA8IDB4ODApICYmIGNwc1syXSA9PT0gSFlQSEVOICYmIGNwc1szXSA9PT0gSFlQSEVOKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGxhYmVsIGV4dGVuc2lvbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBsYWJlbCBcIiR7bGFiZWx9XCI6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5zX25vcm1hbGl6ZShuYW1lKSB7XG4gICAgcmV0dXJuIGVuc19ub3JtYWxpemVfcG9zdF9jaGVjayhub3JtYWxpemUobmFtZSwgZmlsdGVyX2ZlMGYpKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lLCBlbW9qaV9maWx0ZXIpIHtcbiAgICBsZXQgaW5wdXQgPSBleHBsb2RlX2NwKG5hbWUpLnJldmVyc2UoKTsgLy8gZmxpcCBmb3IgcG9wXG4gICAgbGV0IG91dHB1dCA9IFtdO1xuICAgIHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGVtb2ppID0gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChpbnB1dCk7XG4gICAgICAgIGlmIChlbW9qaSkge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goLi4uZW1vamlfZmlsdGVyKGVtb2ppKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3AgPSBpbnB1dC5wb3AoKTtcbiAgICAgICAgaWYgKFZBTElELmhhcyhjcCkpIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGNwKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJR05PUkVELmhhcyhjcCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjcHMgPSBNQVBQRURbY3BdO1xuICAgICAgICBpZiAoY3BzKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCguLi5jcHMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaXNhbGxvd2VkIGNvZGVwb2ludDogMHgke2NwLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gZW5zX25vcm1hbGl6ZV9wb3N0X2NoZWNrKG5mYyhTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5vdXRwdXQpKSk7XG59XG5mdW5jdGlvbiBuZmMocykge1xuICAgIHJldHVybiBzLm5vcm1hbGl6ZSgnTkZDJyk7XG59XG5mdW5jdGlvbiBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGNwcywgZWF0ZW4pIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG5vZGUgPSBFTU9KSV9ST09UO1xuICAgIGxldCBlbW9qaTtcbiAgICBsZXQgc2F2ZWQ7XG4gICAgbGV0IHN0YWNrID0gW107XG4gICAgbGV0IHBvcyA9IGNwcy5sZW5ndGg7XG4gICAgaWYgKGVhdGVuKVxuICAgICAgICBlYXRlbi5sZW5ndGggPSAwOyAvLyBjbGVhciBpbnB1dCBidWZmZXIgKGlmIG5lZWRlZClcbiAgICB3aGlsZSAocG9zKSB7XG4gICAgICAgIGxldCBjcCA9IGNwc1stLXBvc107XG4gICAgICAgIG5vZGUgPSAoX2EgPSBub2RlLmJyYW5jaGVzLmZpbmQoeCA9PiB4LnNldC5oYXMoY3ApKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGU7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobm9kZS5zYXZlKSB7IC8vIHJlbWVtYmVyXG4gICAgICAgICAgICBzYXZlZCA9IGNwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUuY2hlY2spIHsgLy8gY2hlY2sgZXhjbHVzaW9uXG4gICAgICAgICAgICBpZiAoY3AgPT09IHNhdmVkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2goY3ApO1xuICAgICAgICBpZiAobm9kZS5mZTBmKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKDB4RkUwRik7XG4gICAgICAgICAgICBpZiAocG9zID4gMCAmJiBjcHNbcG9zIC0gMV0gPT0gMHhGRTBGKVxuICAgICAgICAgICAgICAgIHBvcy0tOyAvLyBjb25zdW1lIG9wdGlvbmFsIEZFMEZcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS52YWxpZCkgeyAvLyB0aGlzIGlzIGEgdmFsaWQgZW1vamkgKHNvIGZhcilcbiAgICAgICAgICAgIGVtb2ppID0gc3RhY2suc2xpY2UoKTsgLy8gY29weSBzdGFja1xuICAgICAgICAgICAgaWYgKG5vZGUudmFsaWQgPT0gMilcbiAgICAgICAgICAgICAgICBlbW9qaS5zcGxpY2UoMSwgMSk7IC8vIGRlbGV0ZSBGRTBGIGF0IHBvc2l0aW9uIDEgKFJHSSBaV0ogZG9uJ3QgZm9sbG93IHNwZWMhKVxuICAgICAgICAgICAgaWYgKGVhdGVuKVxuICAgICAgICAgICAgICAgIGVhdGVuLnB1c2goLi4uY3BzLnNsaWNlKHBvcykucmV2ZXJzZSgpKTsgLy8gY29weSBpbnB1dCAoaWYgbmVlZGVkKVxuICAgICAgICAgICAgY3BzLmxlbmd0aCA9IHBvczsgLy8gdHJ1bmNhdGVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW1vamk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWIuanMubWFwIl0sIm5hbWVzIjpbInRvVXRmOENvZGVQb2ludHMiLCJnZXREYXRhIiwiciIsInJlYWRfbWVtYmVyX2FycmF5IiwicmVhZF9tYXBwZWRfbWFwIiwicmVhZF9lbW9qaV90cmllIiwiVkFMSUQiLCJTZXQiLCJJR05PUkVEIiwiTUFQUEVEIiwiRU1PSklfUk9PVCIsIkhZUEhFTiIsIlVOREVSU0NPUkUiLCJleHBsb2RlX2NwIiwibmFtZSIsImZpbHRlcl9mZTBmIiwiY3BzIiwiZmlsdGVyIiwiY3AiLCJlbnNfbm9ybWFsaXplX3Bvc3RfY2hlY2siLCJsYWJlbCIsInNwbGl0IiwiaSIsImxhc3RJbmRleE9mIiwiRXJyb3IiLCJsZW5ndGgiLCJldmVyeSIsImVyciIsIm1lc3NhZ2UiLCJlbnNfbm9ybWFsaXplIiwibm9ybWFsaXplIiwiZW1vamlfZmlsdGVyIiwiaW5wdXQiLCJyZXZlcnNlIiwib3V0cHV0IiwiZW1vamkiLCJjb25zdW1lX2Vtb2ppX3JldmVyc2VkIiwicHVzaCIsInBvcCIsImhhcyIsInRvU3RyaW5nIiwidG9VcHBlckNhc2UiLCJuZmMiLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50IiwicyIsImVhdGVuIiwiX2EiLCJub2RlIiwic2F2ZWQiLCJzdGFjayIsInBvcyIsImJyYW5jaGVzIiwiZmluZCIsIngiLCJzZXQiLCJzYXZlIiwiY2hlY2siLCJmZTBmIiwidmFsaWQiLCJzbGljZSIsInNwbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/hash/lib.esm/id.js":
/*!********************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/id.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   id: () => (/* binding */ id)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n\n\nfunction id(text) {\n    return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_0__.keccak256)((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(text));\n} //# sourceMappingURL=id.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL2lkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxRDtBQUNBO0FBQzlDLFNBQVNFLEdBQUdDLElBQUk7SUFDbkIsT0FBT0gsbUVBQVNBLENBQUNDLG1FQUFXQSxDQUFDRTtBQUNqQyxFQUNBLDhCQUE4QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL2lkLmpzPzQ2NWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGlkKHRleHQpIHtcbiAgICByZXR1cm4ga2VjY2FrMjU2KHRvVXRmOEJ5dGVzKHRleHQpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCJdLCJuYW1lcyI6WyJrZWNjYWsyNTYiLCJ0b1V0ZjhCeXRlcyIsImlkIiwidGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/hash/lib.esm/id.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/hash/lib.esm/namehash.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/namehash.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dnsEncode: () => (/* binding */ dnsEncode),\n/* harmony export */   ensNormalize: () => (/* binding */ ensNormalize),\n/* harmony export */   isValidName: () => (/* binding */ isValidName),\n/* harmony export */   namehash: () => (/* binding */ namehash)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/hash/lib.esm/_version.js\");\n/* harmony import */ var _ens_normalize_lib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ens-normalize/lib */ \"(ssr)/./node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js\");\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    if (comp.length === 0) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__.toUtf8Bytes)((0,_ens_normalize_lib__WEBPACK_IMPORTED_MODULE_3__.ens_normalize)(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for(let i = 0; i < bytes.length; i++){\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    if (last >= bytes.length) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\nfunction ensNormalize(name) {\n    return ensNameSplit(name).map((comp)=>(0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__.toUtf8String)(comp)).join(\".\");\n}\nfunction isValidName(name) {\n    try {\n        return ensNameSplit(name).length !== 0;\n    } catch (error) {}\n    return false;\n}\nfunction namehash(name) {\n    /* istanbul ignore if */ if (typeof name !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while(comps.length){\n        result = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.concat)([\n            result,\n            (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__.keccak256)(comps.pop())\n        ]));\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexlify)(result);\n}\nfunction dnsEncode(name) {\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.concat)(ensNameSplit(name).map((comp)=>{\n        // DNS does not allow components over 63 bytes in length\n        if (comp.length > 63) {\n            throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n        }\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n} //# sourceMappingURL=namehash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL25hbWVoYXNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBdUQ7QUFDWTtBQUNkO0FBQ047QUFDVjtBQUNyQyxNQUFNTyxTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDbUI7QUFDcEQsTUFBTUcsUUFBUSxJQUFJQyxXQUFXO0FBQzdCRCxNQUFNRSxJQUFJLENBQUM7QUFDWCxTQUFTQyxlQUFlQyxJQUFJO0lBQ3hCLElBQUlBLEtBQUtDLE1BQU0sS0FBSyxHQUFHO1FBQ25CLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQUNBLE9BQU9GO0FBQ1g7QUFDQSxTQUFTRyxhQUFhQyxJQUFJO0lBQ3RCLE1BQU1DLFFBQVFoQixtRUFBV0EsQ0FBQ00saUVBQWFBLENBQUNTO0lBQ3hDLE1BQU1FLFFBQVEsRUFBRTtJQUNoQixJQUFJRixLQUFLSCxNQUFNLEtBQUssR0FBRztRQUNuQixPQUFPSztJQUNYO0lBQ0EsSUFBSUMsT0FBTztJQUNYLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxNQUFNSixNQUFNLEVBQUVPLElBQUs7UUFDbkMsTUFBTUMsSUFBSUosS0FBSyxDQUFDRyxFQUFFO1FBQ2xCLDhDQUE4QztRQUM5QyxJQUFJQyxNQUFNLE1BQU07WUFDWkgsTUFBTUksSUFBSSxDQUFDWCxlQUFlTSxNQUFNTSxLQUFLLENBQUNKLE1BQU1DO1lBQzVDRCxPQUFPQyxJQUFJO1FBQ2Y7SUFDSjtJQUNBLHFEQUFxRDtJQUNyRCxJQUFJRCxRQUFRRixNQUFNSixNQUFNLEVBQUU7UUFDdEIsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCO0lBQ0FJLE1BQU1JLElBQUksQ0FBQ1gsZUFBZU0sTUFBTU0sS0FBSyxDQUFDSjtJQUN0QyxPQUFPRDtBQUNYO0FBQ08sU0FBU00sYUFBYVIsSUFBSTtJQUM3QixPQUFPRCxhQUFhQyxNQUFNUyxHQUFHLENBQUMsQ0FBQ2IsT0FBU1Ysb0VBQVlBLENBQUNVLE9BQU9jLElBQUksQ0FBQztBQUNyRTtBQUNPLFNBQVNDLFlBQVlYLElBQUk7SUFDNUIsSUFBSTtRQUNBLE9BQVFELGFBQWFDLE1BQU1ILE1BQU0sS0FBSztJQUMxQyxFQUNBLE9BQU9lLE9BQU8sQ0FBRTtJQUNoQixPQUFPO0FBQ1g7QUFDTyxTQUFTQyxTQUFTYixJQUFJO0lBQ3pCLHNCQUFzQixHQUN0QixJQUFJLE9BQVFBLFNBQVUsVUFBVTtRQUM1QlYsT0FBT3dCLGtCQUFrQixDQUFDLGtDQUFrQyxRQUFRZDtJQUN4RTtJQUNBLElBQUllLFNBQVN2QjtJQUNiLE1BQU1VLFFBQVFILGFBQWFDO0lBQzNCLE1BQU9FLE1BQU1MLE1BQU0sQ0FBRTtRQUNqQmtCLFNBQVM1QixtRUFBU0EsQ0FBQ0osNERBQU1BLENBQUM7WUFBQ2dDO1lBQVE1QixtRUFBU0EsQ0FBQ2UsTUFBTWMsR0FBRztTQUFJO0lBQzlEO0lBQ0EsT0FBT2hDLDZEQUFPQSxDQUFDK0I7QUFDbkI7QUFDTyxTQUFTRSxVQUFVakIsSUFBSTtJQUMxQixPQUFPaEIsNkRBQU9BLENBQUNELDREQUFNQSxDQUFDZ0IsYUFBYUMsTUFBTVMsR0FBRyxDQUFDLENBQUNiO1FBQzFDLHdEQUF3RDtRQUN4RCxJQUFJQSxLQUFLQyxNQUFNLEdBQUcsSUFBSTtZQUNsQixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxNQUFNRyxRQUFRLElBQUlSLFdBQVdHLEtBQUtDLE1BQU0sR0FBRztRQUMzQ0ksTUFBTWlCLEdBQUcsQ0FBQ3RCLE1BQU07UUFDaEJLLEtBQUssQ0FBQyxFQUFFLEdBQUdBLE1BQU1KLE1BQU0sR0FBRztRQUMxQixPQUFPSTtJQUNYLE9BQU87QUFDWCxFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL25hbWVoYXNoLmpzP2NjMTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29uY2F0LCBoZXhsaWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IGVuc19ub3JtYWxpemUgfSBmcm9tIFwiLi9lbnMtbm9ybWFsaXplL2xpYlwiO1xuY29uc3QgWmVyb3MgPSBuZXcgVWludDhBcnJheSgzMik7XG5aZXJvcy5maWxsKDApO1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnQoY29tcCkge1xuICAgIGlmIChjb21wLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lOyBlbXB0eSBjb21wb25lbnRcIik7XG4gICAgfVxuICAgIHJldHVybiBjb21wO1xufVxuZnVuY3Rpb24gZW5zTmFtZVNwbGl0KG5hbWUpIHtcbiAgICBjb25zdCBieXRlcyA9IHRvVXRmOEJ5dGVzKGVuc19ub3JtYWxpemUobmFtZSkpO1xuICAgIGNvbnN0IGNvbXBzID0gW107XG4gICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjb21wcztcbiAgICB9XG4gICAgbGV0IGxhc3QgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZCA9IGJ5dGVzW2ldO1xuICAgICAgICAvLyBBIHNlcGFyYXRvciAoaS5lLiBcIi5cIik7IGNvcHkgdGhpcyBjb21wb25lbnRcbiAgICAgICAgaWYgKGQgPT09IDB4MmUpIHtcbiAgICAgICAgICAgIGNvbXBzLnB1c2goY2hlY2tDb21wb25lbnQoYnl0ZXMuc2xpY2UobGFzdCwgaSkpKTtcbiAgICAgICAgICAgIGxhc3QgPSBpICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGVyZSB3YXMgYSBzdHJheSBzZXBhcmF0b3IgYXQgdGhlIGVuZCBvZiB0aGUgbmFtZVxuICAgIGlmIChsYXN0ID49IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lOyBlbXB0eSBjb21wb25lbnRcIik7XG4gICAgfVxuICAgIGNvbXBzLnB1c2goY2hlY2tDb21wb25lbnQoYnl0ZXMuc2xpY2UobGFzdCkpKTtcbiAgICByZXR1cm4gY29tcHM7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5zTm9ybWFsaXplKG5hbWUpIHtcbiAgICByZXR1cm4gZW5zTmFtZVNwbGl0KG5hbWUpLm1hcCgoY29tcCkgPT4gdG9VdGY4U3RyaW5nKGNvbXApKS5qb2luKFwiLlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTmFtZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChlbnNOYW1lU3BsaXQobmFtZSkubGVuZ3RoICE9PSAwKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gbmFtZWhhc2gobmFtZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0eXBlb2YgKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lOyBub3QgYSBzdHJpbmdcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gWmVyb3M7XG4gICAgY29uc3QgY29tcHMgPSBlbnNOYW1lU3BsaXQobmFtZSk7XG4gICAgd2hpbGUgKGNvbXBzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBrZWNjYWsyNTYoY29uY2F0KFtyZXN1bHQsIGtlY2NhazI1Nihjb21wcy5wb3AoKSldKSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZG5zRW5jb2RlKG5hbWUpIHtcbiAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoZW5zTmFtZVNwbGl0KG5hbWUpLm1hcCgoY29tcCkgPT4ge1xuICAgICAgICAvLyBETlMgZG9lcyBub3QgYWxsb3cgY29tcG9uZW50cyBvdmVyIDYzIGJ5dGVzIGluIGxlbmd0aFxuICAgICAgICBpZiAoY29tcC5sZW5ndGggPiA2Mykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBETlMgZW5jb2RlZCBlbnRyeTsgbGVuZ3RoIGV4Y2VlZHMgNjMgYnl0ZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjb21wLmxlbmd0aCArIDEpO1xuICAgICAgICBieXRlcy5zZXQoY29tcCwgMSk7XG4gICAgICAgIGJ5dGVzWzBdID0gYnl0ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0pKSkgKyBcIjAwXCI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYW1laGFzaC5qcy5tYXAiXSwibmFtZXMiOlsiY29uY2F0IiwiaGV4bGlmeSIsInRvVXRmOEJ5dGVzIiwidG9VdGY4U3RyaW5nIiwia2VjY2FrMjU2IiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsImVuc19ub3JtYWxpemUiLCJaZXJvcyIsIlVpbnQ4QXJyYXkiLCJmaWxsIiwiY2hlY2tDb21wb25lbnQiLCJjb21wIiwibGVuZ3RoIiwiRXJyb3IiLCJlbnNOYW1lU3BsaXQiLCJuYW1lIiwiYnl0ZXMiLCJjb21wcyIsImxhc3QiLCJpIiwiZCIsInB1c2giLCJzbGljZSIsImVuc05vcm1hbGl6ZSIsIm1hcCIsImpvaW4iLCJpc1ZhbGlkTmFtZSIsImVycm9yIiwibmFtZWhhc2giLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJyZXN1bHQiLCJwb3AiLCJkbnNFbmNvZGUiLCJzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/hash/lib.esm/namehash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/hash/lib.esm/typed-data.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/typed-data.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedDataEncoder: () => (/* binding */ TypedDataEncoder)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/hash/lib.esm/_version.js\");\n/* harmony import */ var _id__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./id */ \"(ssr)/./node_modules/@ethersproject/hash/lib.esm/id.js\");\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst NegativeOne = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(-1);\nconst Zero = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(0);\nconst One = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(1);\nconst MaxUint256 = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction hexPadRight(value) {\n    const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n            bytes,\n            padding.slice(padOffset)\n        ]);\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(bytes);\n}\nconst hexTrue = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(One.toHexString(), 32);\nconst hexFalse = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(Zero.toHexString(), 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\",\n    \"version\",\n    \"chainId\",\n    \"verifyingContract\",\n    \"salt\"\n];\nfunction checkString(key) {\n    return function(value) {\n        if (typeof value !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        }\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(value) {\n        try {\n            return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value).toString();\n        } catch (error) {}\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function(value) {\n        try {\n            return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_4__.getAddress)(value).toLowerCase();\n        } catch (error) {}\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value) {\n        try {\n            const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n            if (bytes.length !== 32) {\n                throw new Error(\"bad length\");\n            }\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(bytes);\n        } catch (error) {}\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = match[1] === \"\";\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n            const boundsUpper = MaxUint256.mask(signed ? width - 1 : width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;\n            return function(value) {\n                const v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value);\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${type}`, \"value\", value);\n                }\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n            return function(value) {\n                const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${type}`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch(type){\n        case \"address\":\n            return function(value) {\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)((0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_4__.getAddress)(value), 32);\n            };\n        case \"bool\":\n            return function(value) {\n                return !value ? hexFalse : hexTrue;\n            };\n        case \"bytes\":\n            return function(value) {\n                return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(value);\n            };\n        case \"string\":\n            return function(value) {\n                return (0,_id__WEBPACK_IMPORTED_MODULE_6__.id)(value);\n            };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type })=>type + \" \" + name).join(\",\")})`;\n}\nclass TypedDataEncoder {\n    constructor(types){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, \"types\", Object.freeze((0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.deepCopy)(types)));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, \"_encoderCache\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, \"_types\", {});\n        // Link struct types to their direct child structs\n        const links = {};\n        // Link structs to structs which contain them as a child\n        const parents = {};\n        // Link all subtypes within a given struct\n        const subtypes = {};\n        Object.keys(types).forEach((type)=>{\n            links[type] = {};\n            parents[type] = [];\n            subtypes[type] = {};\n        });\n        for(const name in types){\n            const uniqueNames = {};\n            types[name].forEach((field)=>{\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    return;\n                }\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n)=>parents[n].length === 0);\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        } else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t)=>JSON.stringify(t)).join(\", \")}`, \"types\", types);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, \"primaryType\", primaryTypes[0]);\n        // Check for circular type references\n        function checkCircular(type, found) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n            }\n            found[type] = true;\n            Object.keys(links[type]).forEach((child)=>{\n                if (!parents[child]) {\n                    return;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype)=>{\n                    subtypes[subtype][child] = true;\n                });\n            });\n            delete found[type];\n        }\n        checkCircular(this.primaryType, {});\n        // Compute each fully describe type\n        for(const name in subtypes){\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t)=>encodeType(t, types[t])).join(\"\");\n        }\n    }\n    getEncoder(type) {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n    _getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value)=>{\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256);\n                }\n                return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = (0,_id__WEBPACK_IMPORTED_MODULE_6__.id)(this._types[type]);\n            return (value)=>{\n                const values = fields.map(({ name, type })=>{\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) {\n                        return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(values);\n            };\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    encodeType(name) {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        }\n        return result;\n    }\n    encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    hashStruct(name, value) {\n        return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(this.encodeData(name, value));\n    }\n    encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v)=>this._visit(subtype, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type })=>{\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    static hashDomain(domain) {\n        const domainFields = [];\n        for(const name in domain){\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            }\n            domainFields.push({\n                name,\n                type\n            });\n        }\n        domainFields.sort((a, b)=>{\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n            EIP712Domain: domainFields\n        }, domain);\n    }\n    static encode(domain, types, value) {\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    static hash(domain, types, value) {\n        return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    static resolveNames(domain, types, value, resolveName) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // Make a copy to isolate it from the object passed in\n            domain = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.shallowCopy)(domain);\n            // Look up all ENS names\n            const ensCache = {};\n            // Do we need to look up the domain's verifyingContract?\n            if (domain.verifyingContract && !(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(domain.verifyingContract, 20)) {\n                ensCache[domain.verifyingContract] = \"0x\";\n            }\n            // We are going to use the encoder to visit all the base values\n            const encoder = TypedDataEncoder.from(types);\n            // Get a list of all the addresses\n            encoder.visit(value, (type, value)=>{\n                if (type === \"address\" && !(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(value, 20)) {\n                    ensCache[value] = \"0x\";\n                }\n                return value;\n            });\n            // Lookup each name\n            for(const name in ensCache){\n                ensCache[name] = yield resolveName(name);\n            }\n            // Replace the domain verifyingContract if needed\n            if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n                domain.verifyingContract = ensCache[domain.verifyingContract];\n            }\n            // Replace all ENS names with their address\n            value = encoder.visit(value, (type, value)=>{\n                if (type === \"address\" && ensCache[value]) {\n                    return ensCache[value];\n                }\n                return value;\n            });\n            return {\n                domain,\n                value\n            };\n        });\n    }\n    static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name)=>{\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({\n                name,\n                type: domainFieldTypes[name]\n            });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        const typesWithDomain = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.shallowCopy)(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        } else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value)=>{\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value).toString();\n                }\n                switch(type){\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof value !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n} //# sourceMappingURL=typed-data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL3R5cGVkLWRhdGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQ29EO0FBQ0M7QUFDd0M7QUFDeEM7QUFDNkI7QUFDbkM7QUFDVjtBQUNyQyxNQUFNb0IsU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BO0FBQ1A7QUFDMUIsTUFBTUcsVUFBVSxJQUFJQyxX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QUFNZ0QsVUFBVWIsaUJBQWlCaEQsSUFBSSxDQUFDa0Q7UUFDdEMsTUFBTXVELGtCQUFrQmxILHNFQUFXQSxDQUFDMkQ7UUFDcEMsSUFBSXVELGdCQUFnQlAsWUFBWSxFQUFFO1lBQzlCeEcsT0FBTzBCLGtCQUFrQixDQUFDLDRDQUE0QyxzQkFBc0I4QjtRQUNoRyxPQUNLO1lBQ0R1RCxnQkFBZ0JQLFlBQVksR0FBR007UUFDbkM7UUFDQSx5Q0FBeUM7UUFDekMzQyxRQUFRdUIsTUFBTSxDQUFDcEg7UUFDZixPQUFPO1lBQ0hrRixPQUFPdUQ7WUFDUFosUUFBUVU7WUFDUmhDLGFBQWFWLFFBQVFVLFdBQVc7WUFDaENtQyxTQUFTN0MsUUFBUTZCLEtBQUssQ0FBQzFILE9BQU8sQ0FBQzZELE1BQU03RDtnQkFDakMsUUFBUTtnQkFDUixJQUFJNkQsS0FBS0MsS0FBSyxDQUFDLGdCQUFnQjtvQkFDM0IsT0FBTzdDLDZEQUFPQSxDQUFDRiw4REFBUUEsQ0FBQ2Y7Z0JBQzVCO2dCQUNBLGNBQWM7Z0JBQ2QsSUFBSTZELEtBQUtDLEtBQUssQ0FBQyxXQUFXO29CQUN0QixPQUFPaEQsK0RBQVNBLENBQUNrQixJQUFJLENBQUNoQyxPQUFPd0QsUUFBUTtnQkFDekM7Z0JBQ0EsT0FBUUs7b0JBQ0osS0FBSzt3QkFDRCxPQUFPN0QsTUFBTTBELFdBQVc7b0JBQzVCLEtBQUs7d0JBQ0QsT0FBTyxDQUFDLENBQUMxRDtvQkFDYixLQUFLO3dCQUNELElBQUksT0FBUUEsVUFBVyxVQUFVOzRCQUM3QjBCLE9BQU8wQixrQkFBa0IsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxFQUFFLFNBQVNwRDt3QkFDekQ7d0JBQ0EsT0FBT0E7Z0JBQ2Y7Z0JBQ0EsT0FBTzBCLE9BQU8wQixrQkFBa0IsQ0FBQyxvQkFBb0IsUUFBUVM7WUFDakU7UUFDSjtJQUNKO0FBQ0osRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS90eXBlZC1kYXRhLmpzP2JhYTYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBoZXhDb25jYXQsIGhleGxpZnksIGhleFplcm9QYWQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2XCI7XG5pbXBvcnQgeyBkZWVwQ29weSwgZGVmaW5lUmVhZE9ubHksIHNoYWxsb3dDb3B5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IGlkIH0gZnJvbSBcIi4vaWRcIjtcbmNvbnN0IHBhZGRpbmcgPSBuZXcgVWludDhBcnJheSgzMik7XG5wYWRkaW5nLmZpbGwoMCk7XG5jb25zdCBOZWdhdGl2ZU9uZSA9IEJpZ051bWJlci5mcm9tKC0xKTtcbmNvbnN0IFplcm8gPSBCaWdOdW1iZXIuZnJvbSgwKTtcbmNvbnN0IE9uZSA9IEJpZ051bWJlci5mcm9tKDEpO1xuY29uc3QgTWF4VWludDI1NiA9IEJpZ051bWJlci5mcm9tKFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpO1xuZnVuY3Rpb24gaGV4UGFkUmlnaHQodmFsdWUpIHtcbiAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICBjb25zdCBwYWRPZmZzZXQgPSBieXRlcy5sZW5ndGggJSAzMjtcbiAgICBpZiAocGFkT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBoZXhDb25jYXQoW2J5dGVzLCBwYWRkaW5nLnNsaWNlKHBhZE9mZnNldCldKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xufVxuY29uc3QgaGV4VHJ1ZSA9IGhleFplcm9QYWQoT25lLnRvSGV4U3RyaW5nKCksIDMyKTtcbmNvbnN0IGhleEZhbHNlID0gaGV4WmVyb1BhZChaZXJvLnRvSGV4U3RyaW5nKCksIDMyKTtcbmNvbnN0IGRvbWFpbkZpZWxkVHlwZXMgPSB7XG4gICAgbmFtZTogXCJzdHJpbmdcIixcbiAgICB2ZXJzaW9uOiBcInN0cmluZ1wiLFxuICAgIGNoYWluSWQ6IFwidWludDI1NlwiLFxuICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBcImFkZHJlc3NcIixcbiAgICBzYWx0OiBcImJ5dGVzMzJcIlxufTtcbmNvbnN0IGRvbWFpbkZpZWxkTmFtZXMgPSBbXG4gICAgXCJuYW1lXCIsIFwidmVyc2lvblwiLCBcImNoYWluSWRcIiwgXCJ2ZXJpZnlpbmdDb250cmFjdFwiLCBcInNhbHRcIlxuXTtcbmZ1bmN0aW9uIGNoZWNrU3RyaW5nKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBmb3IgJHtKU09OLnN0cmluZ2lmeShrZXkpfWAsIGBkb21haW4uJHtrZXl9YCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufVxuY29uc3QgZG9tYWluQ2hlY2tzID0ge1xuICAgIG5hbWU6IGNoZWNrU3RyaW5nKFwibmFtZVwiKSxcbiAgICB2ZXJzaW9uOiBjaGVja1N0cmluZyhcInZlcnNpb25cIiksXG4gICAgY2hhaW5JZDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgZG9tYWluIHZhbHVlIGZvciBcImNoYWluSWRcImAsIFwiZG9tYWluLmNoYWluSWRcIiwgdmFsdWUpO1xuICAgIH0sXG4gICAgdmVyaWZ5aW5nQ29udHJhY3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3ModmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgZG9tYWluIHZhbHVlIFwidmVyaWZ5aW5nQ29udHJhY3RcImAsIFwiZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XCIsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNhbHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSAzMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBsZW5ndGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgZG9tYWluIHZhbHVlIFwic2FsdFwiYCwgXCJkb21haW4uc2FsdFwiLCB2YWx1ZSk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGdldEJhc2VFbmNvZGVyKHR5cGUpIHtcbiAgICAvLyBpbnRYWCBhbmQgdWludFhYXG4gICAge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL14odT8paW50KFxcZCopJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZCA9IChtYXRjaFsxXSA9PT0gXCJcIik7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiMjU2XCIpO1xuICAgICAgICAgICAgaWYgKHdpZHRoICUgOCAhPT0gMCB8fCB3aWR0aCA+IDI1NiB8fCAobWF0Y2hbMl0gJiYgbWF0Y2hbMl0gIT09IFN0cmluZyh3aWR0aCkpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbnVtZXJpYyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBib3VuZHNVcHBlciA9IE1heFVpbnQyNTYubWFzayhzaWduZWQgPyAod2lkdGggLSAxKSA6IHdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc0xvd2VyID0gc2lnbmVkID8gYm91bmRzVXBwZXIuYWRkKE9uZSkubXVsKE5lZ2F0aXZlT25lKSA6IFplcm87XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IEJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodi5sdChib3VuZHNMb3dlcikgfHwgdi5ndChib3VuZHNVcHBlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgdmFsdWUgb3V0LW9mLWJvdW5kcyBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4WmVyb1BhZCh2LnRvVHdvcygyNTYpLnRvSGV4U3RyaW5nKCksIDMyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYnl0ZXNYWFxuICAgIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKykkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgICBpZiAod2lkdGggPT09IDAgfHwgd2lkdGggPiAzMiB8fCBtYXRjaFsxXSAhPT0gU3RyaW5nKHdpZHRoKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJ5dGVzIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGxlbmd0aCBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4UGFkUmlnaHQodmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImFkZHJlc3NcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGhleFplcm9QYWQoZ2V0QWRkcmVzcyh2YWx1ZSksIDMyKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImJvb2xcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgoIXZhbHVlKSA/IGhleEZhbHNlIDogaGV4VHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJieXRlc1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQodmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGVuY29kZVR5cGUobmFtZSwgZmllbGRzKSB7XG4gICAgcmV0dXJuIGAke25hbWV9KCR7ZmllbGRzLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+ICh0eXBlICsgXCIgXCIgKyBuYW1lKSkuam9pbihcIixcIil9KWA7XG59XG5leHBvcnQgY2xhc3MgVHlwZWREYXRhRW5jb2RlciB7XG4gICAgY29uc3RydWN0b3IodHlwZXMpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJ0eXBlc1wiLCBPYmplY3QuZnJlZXplKGRlZXBDb3B5KHR5cGVzKSkpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9lbmNvZGVyQ2FjaGVcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl90eXBlc1wiLCB7fSk7XG4gICAgICAgIC8vIExpbmsgc3RydWN0IHR5cGVzIHRvIHRoZWlyIGRpcmVjdCBjaGlsZCBzdHJ1Y3RzXG4gICAgICAgIGNvbnN0IGxpbmtzID0ge307XG4gICAgICAgIC8vIExpbmsgc3RydWN0cyB0byBzdHJ1Y3RzIHdoaWNoIGNvbnRhaW4gdGhlbSBhcyBhIGNoaWxkXG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSB7fTtcbiAgICAgICAgLy8gTGluayBhbGwgc3VidHlwZXMgd2l0aGluIGEgZ2l2ZW4gc3RydWN0XG4gICAgICAgIGNvbnN0IHN1YnR5cGVzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHR5cGVzKS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgICAgICBsaW5rc1t0eXBlXSA9IHt9O1xuICAgICAgICAgICAgcGFyZW50c1t0eXBlXSA9IFtdO1xuICAgICAgICAgICAgc3VidHlwZXNbdHlwZV0gPSB7fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0eXBlcykge1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlTmFtZXMgPSB7fTtcbiAgICAgICAgICAgIHR5cGVzW25hbWVdLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZWFjaCBmaWVsZCBoYXMgYSB1bmlxdWUgbmFtZVxuICAgICAgICAgICAgICAgIGlmICh1bmlxdWVOYW1lc1tmaWVsZC5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBkdXBsaWNhdGUgdmFyaWFibGUgbmFtZSAke0pTT04uc3RyaW5naWZ5KGZpZWxkLm5hbWUpfSBpbiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmlxdWVOYW1lc1tmaWVsZC5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBiYXNlIHR5cGUgKGRyb3AgYW55IGFycmF5IHNwZWNpZmllcnMpXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZVR5cGUgPSBmaWVsZC50eXBlLm1hdGNoKC9eKFteXFx4NWJdKikoXFx4NWJ8JCkvKVsxXTtcbiAgICAgICAgICAgICAgICBpZiAoYmFzZVR5cGUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2UgdG8gJHtKU09OLnN0cmluZ2lmeShiYXNlVHlwZSl9YCwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgYSBiYXNlIGVuY29kaW5nIHR5cGU/XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKGJhc2VUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcGFyZW50c1tiYXNlVHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgdW5rbm93biB0eXBlICR7SlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBZGQgbGlua2FnZVxuICAgICAgICAgICAgICAgIHBhcmVudHNbYmFzZVR5cGVdLnB1c2gobmFtZSk7XG4gICAgICAgICAgICAgICAgbGlua3NbbmFtZV1bYmFzZVR5cGVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZHVjZSB0aGUgcHJpbWFyeSB0eXBlXG4gICAgICAgIGNvbnN0IHByaW1hcnlUeXBlcyA9IE9iamVjdC5rZXlzKHBhcmVudHMpLmZpbHRlcigobikgPT4gKHBhcmVudHNbbl0ubGVuZ3RoID09PSAwKSk7XG4gICAgICAgIGlmIChwcmltYXJ5VHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyBwcmltYXJ5IHR5cGVcIiwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJpbWFyeVR5cGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGFtYmlndW91cyBwcmltYXJ5IHR5cGVzIG9yIHVudXNlZCB0eXBlczogJHtwcmltYXJ5VHlwZXMubWFwKCh0KSA9PiAoSlNPTi5zdHJpbmdpZnkodCkpKS5qb2luKFwiLCBcIil9YCwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcmltYXJ5VHlwZVwiLCBwcmltYXJ5VHlwZXNbMF0pO1xuICAgICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2VzXG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrQ2lyY3VsYXIodHlwZSwgZm91bmQpIHtcbiAgICAgICAgICAgIGlmIChmb3VuZFt0eXBlXSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkodHlwZSl9YCwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3VuZFt0eXBlXSA9IHRydWU7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhsaW5rc1t0eXBlXSkuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudHNbY2hpbGRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY2hlY2sgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBjaGVja0NpcmN1bGFyKGNoaWxkLCBmb3VuZCk7XG4gICAgICAgICAgICAgICAgLy8gTWFyayBhbGwgYW5jZXN0b3JzIGFzIGhhdmluZyB0aGlzIGRlY2VuZGFudFxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGZvdW5kKS5mb3JFYWNoKChzdWJ0eXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnR5cGVzW3N1YnR5cGVdW2NoaWxkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlbGV0ZSBmb3VuZFt0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0NpcmN1bGFyKHRoaXMucHJpbWFyeVR5cGUsIHt9KTtcbiAgICAgICAgLy8gQ29tcHV0ZSBlYWNoIGZ1bGx5IGRlc2NyaWJlIHR5cGVcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHN1YnR5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCBzdCA9IE9iamVjdC5rZXlzKHN1YnR5cGVzW25hbWVdKTtcbiAgICAgICAgICAgIHN0LnNvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuX3R5cGVzW25hbWVdID0gZW5jb2RlVHlwZShuYW1lLCB0eXBlc1tuYW1lXSkgKyBzdC5tYXAoKHQpID0+IGVuY29kZVR5cGUodCwgdHlwZXNbdF0pKS5qb2luKFwiXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEVuY29kZXIodHlwZSkge1xuICAgICAgICBsZXQgZW5jb2RlciA9IHRoaXMuX2VuY29kZXJDYWNoZVt0eXBlXTtcbiAgICAgICAgaWYgKCFlbmNvZGVyKSB7XG4gICAgICAgICAgICBlbmNvZGVyID0gdGhpcy5fZW5jb2RlckNhY2hlW3R5cGVdID0gdGhpcy5fZ2V0RW5jb2Rlcih0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlcjtcbiAgICB9XG4gICAgX2dldEVuY29kZXIodHlwZSkge1xuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheVxuICAgICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL14oLiopKFxceDViKFxcZCopXFx4NWQpJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnR5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIGNvbnN0IHN1YkVuY29kZXIgPSB0aGlzLmdldEVuY29kZXIoc3VidHlwZSk7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA+PSAwICYmIHZhbHVlLmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhcnJheSBsZW5ndGggbWlzbWF0Y2g7IGV4cGVjdGVkIGxlbmd0aCAkeyBhcnJheUxlbmd0aCB9XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdmFsdWUubWFwKHN1YkVuY29kZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90eXBlc1tzdWJ0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubWFwKGtlY2NhazI1Nik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYoaGV4Q29uY2F0KHJlc3VsdCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJ1Y3RcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy50eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZFR5cGUgPSBpZCh0aGlzLl90eXBlc1t0eXBlXSk7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZmllbGRzLm1hcCgoeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGVzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMudW5zaGlmdChlbmNvZGVkVHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleENvbmNhdCh2YWx1ZXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICBlbmNvZGVUeXBlKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fdHlwZXNbbmFtZV07XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGB1bmtub3duIHR5cGU6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVuY29kZURhdGEodHlwZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZSk7XG4gICAgfVxuICAgIGhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih0aGlzLmVuY29kZURhdGEobmFtZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZURhdGEodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICBoYXNoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hTdHJ1Y3QodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICBfdmlzaXQodHlwZSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIEJhc2ljIGVuY29kZXIgdHlwZSAoYWRkcmVzcywgYm9vbCwgdWludDI1NiwgZXRjKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIodHlwZSk7XG4gICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0eXBlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKC4qKShcXHg1YihcXGQqKVxceDVkKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJ0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID49IDAgJiYgdmFsdWUubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYXJyYXkgbGVuZ3RoIG1pc21hdGNoOyBleHBlY3RlZCBsZW5ndGggJHsgYXJyYXlMZW5ndGggfVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHYpID0+IHRoaXMuX3Zpc2l0KHN1YnR5cGUsIHYsIGNhbGxiYWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMudHlwZXNbdHlwZV07XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZHMucmVkdWNlKChhY2N1bSwgeyBuYW1lLCB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IHRoaXMuX3Zpc2l0KHR5cGUsIHZhbHVlW25hbWVdLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGB1bmtub3duIHR5cGU6ICR7dHlwZX1gLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIHZpc2l0KHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXQodGhpcy5wcmltYXJ5VHlwZSwgdmFsdWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlZERhdGFFbmNvZGVyKHR5cGVzKTtcbiAgICB9XG4gICAgc3RhdGljIGdldFByaW1hcnlUeXBlKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLnByaW1hcnlUeXBlO1xuICAgIH1cbiAgICBzdGF0aWMgaGFzaFN0cnVjdChuYW1lLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykuaGFzaFN0cnVjdChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBoYXNoRG9tYWluKGRvbWFpbikge1xuICAgICAgICBjb25zdCBkb21haW5GaWVsZHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRvbWFpbikge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV07XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIHR5cGVkLWRhdGEgZG9tYWluIGtleTogJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcImRvbWFpblwiLCBkb21haW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tYWluRmllbGRzLnB1c2goeyBuYW1lLCB0eXBlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRvbWFpbkZpZWxkcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGEubmFtZSkgLSBkb21haW5GaWVsZE5hbWVzLmluZGV4T2YoYi5uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmhhc2hTdHJ1Y3QoXCJFSVA3MTJEb21haW5cIiwgeyBFSVA3MTJEb21haW46IGRvbWFpbkZpZWxkcyB9LCBkb21haW4pO1xuICAgIH1cbiAgICBzdGF0aWMgZW5jb2RlKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBoZXhDb25jYXQoW1xuICAgICAgICAgICAgXCIweDE5MDFcIixcbiAgICAgICAgICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pLFxuICAgICAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5oYXNoKHZhbHVlKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgc3RhdGljIGhhc2goZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazI1NihUeXBlZERhdGFFbmNvZGVyLmVuY29kZShkb21haW4sIHR5cGVzLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvLyBSZXBsYWNlcyBhbGwgYWRkcmVzcyB0eXBlcyB3aXRoIEVOUyBuYW1lcyB3aXRoIHRoZWlyIGxvb2tlZCB1cCBhZGRyZXNzXG4gICAgc3RhdGljIHJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgcmVzb2x2ZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIE1ha2UgYSBjb3B5IHRvIGlzb2xhdGUgaXQgZnJvbSB0aGUgb2JqZWN0IHBhc3NlZCBpblxuICAgICAgICAgICAgZG9tYWluID0gc2hhbGxvd0NvcHkoZG9tYWluKTtcbiAgICAgICAgICAgIC8vIExvb2sgdXAgYWxsIEVOUyBuYW1lc1xuICAgICAgICAgICAgY29uc3QgZW5zQ2FjaGUgPSB7fTtcbiAgICAgICAgICAgIC8vIERvIHdlIG5lZWQgdG8gbG9vayB1cCB0aGUgZG9tYWluJ3MgdmVyaWZ5aW5nQ29udHJhY3Q/XG4gICAgICAgICAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmICFpc0hleFN0cmluZyhkb21haW4udmVyaWZ5aW5nQ29udHJhY3QsIDIwKSkge1xuICAgICAgICAgICAgICAgIGVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF0gPSBcIjB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gdXNlIHRoZSBlbmNvZGVyIHRvIHZpc2l0IGFsbCB0aGUgYmFzZSB2YWx1ZXNcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpO1xuICAgICAgICAgICAgLy8gR2V0IGEgbGlzdCBvZiBhbGwgdGhlIGFkZHJlc3Nlc1xuICAgICAgICAgICAgZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiICYmICFpc0hleFN0cmluZyh2YWx1ZSwgMjApKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuc0NhY2hlW3ZhbHVlXSA9IFwiMHhcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBMb29rdXAgZWFjaCBuYW1lXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZW5zQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBlbnNDYWNoZVtuYW1lXSA9IHlpZWxkIHJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgZG9tYWluIHZlcmlmeWluZ0NvbnRyYWN0IGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYgKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCAmJiBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdKSB7XG4gICAgICAgICAgICAgICAgZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ID0gZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgYWxsIEVOUyBuYW1lcyB3aXRoIHRoZWlyIGFkZHJlc3NcbiAgICAgICAgICAgIHZhbHVlID0gZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiICYmIGVuc0NhY2hlW3ZhbHVlXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5zQ2FjaGVbdmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbWFpbiwgdmFsdWUgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRQYXlsb2FkKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBkb21haW4gZmllbGRzXG4gICAgICAgIFR5cGVkRGF0YUVuY29kZXIuaGFzaERvbWFpbihkb21haW4pO1xuICAgICAgICAvLyBEZXJpdmUgdGhlIEVJUDcxMkRvbWFpbiBTdHJ1Y3QgcmVmZXJlbmNlIHR5cGVcbiAgICAgICAgY29uc3QgZG9tYWluVmFsdWVzID0ge307XG4gICAgICAgIGNvbnN0IGRvbWFpblR5cGVzID0gW107XG4gICAgICAgIGRvbWFpbkZpZWxkTmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkb21haW5bbmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbWFpblZhbHVlc1tuYW1lXSA9IGRvbWFpbkNoZWNrc1tuYW1lXSh2YWx1ZSk7XG4gICAgICAgICAgICBkb21haW5UeXBlcy5wdXNoKHsgbmFtZSwgdHlwZTogZG9tYWluRmllbGRUeXBlc1tuYW1lXSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpO1xuICAgICAgICBjb25zdCB0eXBlc1dpdGhEb21haW4gPSBzaGFsbG93Q29weSh0eXBlcyk7XG4gICAgICAgIGlmICh0eXBlc1dpdGhEb21haW4uRUlQNzEyRG9tYWluKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidHlwZXMgbXVzdCBub3QgY29udGFpbiBFSVA3MTJEb21haW4gdHlwZVwiLCBcInR5cGVzLkVJUDcxMkRvbWFpblwiLCB0eXBlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eXBlc1dpdGhEb21haW4uRUlQNzEyRG9tYWluID0gZG9tYWluVHlwZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRhdGEgc3RydWN0dXJlcyBhbmQgdHlwZXNcbiAgICAgICAgZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZXM6IHR5cGVzV2l0aERvbWFpbixcbiAgICAgICAgICAgIGRvbWFpbjogZG9tYWluVmFsdWVzLFxuICAgICAgICAgICAgcHJpbWFyeVR5cGU6IGVuY29kZXIucHJpbWFyeVR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBieXRlc1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLm1hdGNoKC9eYnl0ZXMoXFxkKikvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShhcnJheWlmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1aW50IG9yIGludFxuICAgICAgICAgICAgICAgIGlmICh0eXBlLm1hdGNoKC9edT9pbnQvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBzdHJpbmdgLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZWQtZGF0YS5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiZ2V0QWRkcmVzcyIsIkJpZ051bWJlciIsImFycmF5aWZ5IiwiaGV4Q29uY2F0IiwiaGV4bGlmeSIsImhleFplcm9QYWQiLCJpc0hleFN0cmluZyIsImtlY2NhazI1NiIsImRlZXBDb3B5IiwiZGVmaW5lUmVhZE9ubHkiLCJzaGFsbG93Q29weSIsIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJpZCIsInBhZGRpbmciLCJVaW50OEFycmF5IiwiZmlsbCIsIk5lZ2F0aXZlT25lIiwiZnJvbSIsIlplcm8iLCJPbmUiLCJNYXhVaW50MjU2IiwiaGV4UGFkUmlnaHQiLCJieXRlcyIsInBhZE9mZnNldCIsImxlbmd0aCIsInNsaWNlIiwiaGV4VHJ1ZSIsInRvSGV4U3RyaW5nIiwiaGV4RmFsc2UiLCJkb21haW5GaWVsZFR5cGVzIiwibmFtZSIsImNoYWluSWQiLCJ2ZXJpZnlpbmdDb250cmFjdCIsInNhbHQiLCJkb21haW5GaWVsZE5hbWVzIiwiY2hlY2tTdHJpbmciLCJrZXkiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwiZG9tYWluQ2hlY2tzIiwidG9TdHJpbmciLCJlcnJvciIsInRvTG93ZXJDYXNlIiwiRXJyb3IiLCJnZXRCYXNlRW5jb2RlciIsInR5cGUiLCJtYXRjaCIsInNpZ25lZCIsIndpZHRoIiwicGFyc2VJbnQiLCJTdHJpbmciLCJib3VuZHNVcHBlciIsIm1hc2siLCJib3VuZHNMb3dlciIsImFkZCIsIm11bCIsInYiLCJsdCIsImd0IiwidG9Ud29zIiwiZW5jb2RlVHlwZSIsImZpZWxkcyIsIm1hcCIsImpvaW4iLCJUeXBlZERhdGFFbmNvZGVyIiwiY29uc3RydWN0b3IiLCJ0eXBlcyIsIk9iamVjdCIsImZyZWV6ZSIsImxpbmtzIiwicGFyZW50cyIsInN1YnR5cGVzIiwia2V5cyIsImZvckVhY2giLCJ1bmlxdWVOYW1lcyIsImZpZWxkIiwiYmFzZVR5cGUiLCJlbmNvZGVyIiwicHVzaCIsInByaW1hcnlUeXBlcyIsImZpbHRlciIsIm4iLCJ0IiwiY2hlY2tDaXJjdWxhciIsImZvdW5kIiwiY2hpbGQiLCJzdWJ0eXBlIiwicHJpbWFyeVR5cGUiLCJzdCIsInNvcnQiLCJfdHlwZXMiLCJnZXRFbmNvZGVyIiwiX2VuY29kZXJDYWNoZSIsIl9nZXRFbmNvZGVyIiwic3ViRW5jb2RlciIsImVuY29kZWRUeXBlIiwidmFsdWVzIiwidW5zaGlmdCIsImVuY29kZURhdGEiLCJoYXNoU3RydWN0IiwiZW5jb2RlIiwiaGFzaCIsIl92aXNpdCIsImNhbGxiYWNrIiwicmVkdWNlIiwiYWNjdW0iLCJ2aXNpdCIsImdldFByaW1hcnlUeXBlIiwiaGFzaERvbWFpbiIsImRvbWFpbiIsImRvbWFpbkZpZWxkcyIsImEiLCJiIiwiaW5kZXhPZiIsIkVJUDcxMkRvbWFpbiIsInJlc29sdmVOYW1lcyIsInJlc29sdmVOYW1lIiwiZW5zQ2FjaGUiLCJnZXRQYXlsb2FkIiwiZG9tYWluVmFsdWVzIiwiZG9tYWluVHlwZXMiLCJ0eXBlc1dpdGhEb21haW4iLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/hash/lib.esm/typed-data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/keccak256/lib.esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/keccak256/lib.esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256)\n/* harmony export */ });\n/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-sha3 */ \"(ssr)/./node_modules/js-sha3/src/sha3.js\");\n/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_sha3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n\n\n\nfunction keccak256(data) {\n    return \"0x\" + js_sha3__WEBPACK_IMPORTED_MODULE_0___default().keccak_256((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(data));\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2L2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFhO0FBQ2M7QUFDcUI7QUFDekMsU0FBU0UsVUFBVUMsSUFBSTtJQUMxQixPQUFPLE9BQU9ILHlEQUFlLENBQUNDLDhEQUFRQSxDQUFDRTtBQUMzQyxFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2L2xpYi5lc20vaW5kZXguanM/MzcyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCBzaGEzIGZyb20gXCJqcy1zaGEzXCI7XG5pbXBvcnQgeyBhcnJheWlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2NhazI1NihkYXRhKSB7XG4gICAgcmV0dXJuICcweCcgKyBzaGEzLmtlY2Nha18yNTYoYXJyYXlpZnkoZGF0YSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbInNoYTMiLCJhcnJheWlmeSIsImtlY2NhazI1NiIsImRhdGEiLCJrZWNjYWtfMjU2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/keccak256/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/logger/lib.esm/_version.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/logger/lib.esm/_version.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"logger/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvbG9nZ2VyL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFVBQVUsZUFBZSxDQUN0QyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2xvZ2dlci9saWIuZXNtL192ZXJzaW9uLmpzP2EwMGIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImxvZ2dlci81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/logger/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/logger/lib.esm/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorCode: () => (/* binding */ ErrorCode),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/_version.js\");\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\nconst LogLevels = {\n    debug: 1,\n    \"default\": 2,\n    info: 2,\n    warning: 3,\n    error: 4,\n    off: 5\n};\nlet _logLevel = LogLevels[\"default\"];\n\nlet _globalLogger = null;\nfunction _checkNormalize() {\n    try {\n        const missing = [];\n        // Make sure all forms of normalization are supported\n        [\n            \"NFD\",\n            \"NFC\",\n            \"NFKD\",\n            \"NFKC\"\n        ].forEach((form)=>{\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                }\n                ;\n            } catch (error) {\n                missing.push(form);\n            }\n        });\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\");\n        }\n    } catch (error) {\n        return error.message;\n    }\n    return null;\n}\nconst _normalizeError = _checkNormalize();\nvar LogLevel;\n(function(LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel || (LogLevel = {}));\nvar ErrorCode;\n(function(ErrorCode) {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    // Not Implemented\n    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n    // Unsupported Operation\n    //   - operation\n    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n    // Some sort of bad response from the server\n    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n    // Timeout\n    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n    ///////////////////\n    // Interaction Errors\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ErrorCode[\"ACTION_REJECTED\"] = \"ACTION_REJECTED\";\n})(ErrorCode || (ErrorCode = {}));\n;\nconst HEX = \"0123456789abcdef\";\nclass Logger {\n    constructor(version){\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n    _log(logLevel, args) {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) {\n            return;\n        }\n        console.log.apply(console, args);\n    }\n    debug(...args) {\n        this._log(Logger.levels.DEBUG, args);\n    }\n    info(...args) {\n        this._log(Logger.levels.INFO, args);\n    }\n    warn(...args) {\n        this._log(Logger.levels.WARNING, args);\n    }\n    makeError(message, code, params) {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, {});\n        }\n        if (!code) {\n            code = Logger.errors.UNKNOWN_ERROR;\n        }\n        if (!params) {\n            params = {};\n        }\n        const messageDetails = [];\n        Object.keys(params).forEach((key)=>{\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for(let i = 0; i < value.length; i++){\n                        hex += HEX[value[i] >> 4];\n                        hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${code}`);\n        messageDetails.push(`version=${this.version}`);\n        const reason = message;\n        let url = \"\";\n        switch(code){\n            case ErrorCode.NUMERIC_FAULT:\n                {\n                    url = \"NUMERIC_FAULT\";\n                    const fault = message;\n                    switch(fault){\n                        case \"overflow\":\n                        case \"underflow\":\n                        case \"division-by-zero\":\n                            url += \"-\" + fault;\n                            break;\n                        case \"negative-power\":\n                        case \"negative-width\":\n                            url += \"-unsupported\";\n                            break;\n                        case \"unbound-bitwise-result\":\n                            url += \"-unbound-result\";\n                            break;\n                    }\n                    break;\n                }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n        if (url) {\n            message += \" [ See: https://links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n        // @TODO: Any??\n        const error = new Error(message);\n        error.reason = reason;\n        error.code = code;\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n        return error;\n    }\n    throwError(message, code, params) {\n        throw this.makeError(message, code, params);\n    }\n    throwArgumentError(message, name, value) {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n    assert(condition, message, code, params) {\n        if (!!condition) {\n            return;\n        }\n        this.throwError(message, code, params);\n    }\n    assertArgument(condition, message, name, value) {\n        if (!!condition) {\n            return;\n        }\n        this.throwArgumentError(message, name, value);\n    }\n    checkNormalize(message) {\n        if (message == null) {\n            message = \"platform missing String.prototype.normalize\";\n        }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\",\n                form: _normalizeError\n            });\n        }\n    }\n    checkSafeUint53(value, message) {\n        if (typeof value !== \"number\") {\n            return;\n        }\n        if (message == null) {\n            message = \"value not safe\";\n        }\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n    checkArgumentCount(count, expectedCount, message) {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n    checkNew(target, kind) {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, {\n                name: kind.name\n            });\n        }\n    }\n    checkAbstract(target, kind) {\n        if (target === kind) {\n            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, {\n                name: target.name,\n                operation: \"new\"\n            });\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, {\n                name: kind.name\n            });\n        }\n    }\n    static globalLogger() {\n        if (!_globalLogger) {\n            _globalLogger = new Logger(_version__WEBPACK_IMPORTED_MODULE_0__.version);\n        }\n        return _globalLogger;\n    }\n    static setCensorship(censorship, permanent) {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        if (_permanentCensorErrors) {\n            if (!censorship) {\n                return;\n            }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n    static setLogLevel(logLevel) {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n    static from(version) {\n        return new Logger(version);\n    }\n}\nLogger.errors = ErrorCode;\nLogger.levels = LogLevel; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvbG9nZ2VyL2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFhO0FBQ2IsSUFBSUEseUJBQXlCO0FBQzdCLElBQUlDLGdCQUFnQjtBQUNwQixNQUFNQyxZQUFZO0lBQUVDLE9BQU87SUFBRyxXQUFXO0lBQUdDLE1BQU07SUFBR0MsU0FBUztJQUFHQyxPQUFPO0lBQUdDLEtBQUs7QUFBRTtBQUNsRixJQUFJQyxZQUFZTixTQUFTLENBQUMsVUFBVTtBQUNDO0FBQ3JDLElBQUlRLGdCQUFnQjtBQUNwQixTQUFTQztJQUNMLElBQUk7UUFDQSxNQUFNQyxVQUFVLEVBQUU7UUFDbEIscURBQXFEO1FBQ3JEO1lBQUM7WUFBTztZQUFPO1lBQVE7U0FBTyxDQUFDQyxPQUFPLENBQUMsQ0FBQ0M7WUFDcEMsSUFBSTtnQkFDQSxJQUFJLE9BQU9DLFNBQVMsQ0FBQ0QsVUFBVSxRQUFRO29CQUNuQyxNQUFNLElBQUlFLE1BQU07Z0JBQ3BCOztZQUVKLEVBQ0EsT0FBT1YsT0FBTztnQkFDVk0sUUFBUUssSUFBSSxDQUFDSDtZQUNqQjtRQUNKO1FBQ0EsSUFBSUYsUUFBUU0sTUFBTSxFQUFFO1lBQ2hCLE1BQU0sSUFBSUYsTUFBTSxhQUFhSixRQUFRTyxJQUFJLENBQUM7UUFDOUM7UUFDQSxJQUFJQyxPQUFPQyxZQUFZLENBQUMsTUFBTU4sU0FBUyxDQUFDLFdBQVdLLE9BQU9DLFlBQVksQ0FBQyxNQUFNLFNBQVM7WUFDbEYsTUFBTSxJQUFJTCxNQUFNO1FBQ3BCO0lBQ0osRUFDQSxPQUFPVixPQUFPO1FBQ1YsT0FBT0EsTUFBTWdCLE9BQU87SUFDeEI7SUFDQSxPQUFPO0FBQ1g7QUFDQSxNQUFNQyxrQkFBa0JaO0FBQ2pCLElBQUlhLFNBQVM7QUFDbkIsVUFBVUEsUUFBUTtJQUNmQSxRQUFRLENBQUMsUUFBUSxHQUFHO0lBQ3BCQSxRQUFRLENBQUMsT0FBTyxHQUFHO0lBQ25CQSxRQUFRLENBQUMs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QUFXO1lBQ2Y7UUFDSjtRQUNBakYsZ0JBQWdCLENBQUMsQ0FBQzhGO1FBQ2xCL0YseUJBQXlCLENBQUMsQ0FBQ2dHO0lBQy9CO0lBQ0EsT0FBT0MsWUFBWTlELFFBQVEsRUFBRTtRQUN6QixNQUFNRSxRQUFRbkMsU0FBUyxDQUFDaUMsU0FBU0csV0FBVyxHQUFHO1FBQy9DLElBQUlELFNBQVMsTUFBTTtZQUNmVixPQUFPa0UsWUFBWSxHQUFHL0MsSUFBSSxDQUFDLHlCQUF5Qlg7WUFDcEQ7UUFDSjtRQUNBM0IsWUFBWTZCO0lBQ2hCO0lBQ0EsT0FBTzZELEtBQUt6RixPQUFPLEVBQUU7UUFDakIsT0FBTyxJQUFJa0IsT0FBT2xCO0lBQ3RCO0FBQ0o7QUFDQWtCLE9BQU93QixNQUFNLEdBQUcxQjtBQUNoQkUsT0FBT2dCLE1BQU0sR0FBR25CLFVBQ2hCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvbG9nZ2VyL2xpYi5lc20vaW5kZXguanM/ZGQ2OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmxldCBfcGVybWFuZW50Q2Vuc29yRXJyb3JzID0gZmFsc2U7XG5sZXQgX2NlbnNvckVycm9ycyA9IGZhbHNlO1xuY29uc3QgTG9nTGV2ZWxzID0geyBkZWJ1ZzogMSwgXCJkZWZhdWx0XCI6IDIsIGluZm86IDIsIHdhcm5pbmc6IDMsIGVycm9yOiA0LCBvZmY6IDUgfTtcbmxldCBfbG9nTGV2ZWwgPSBMb2dMZXZlbHNbXCJkZWZhdWx0XCJdO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5sZXQgX2dsb2JhbExvZ2dlciA9IG51bGw7XG5mdW5jdGlvbiBfY2hlY2tOb3JtYWxpemUoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWlzc2luZyA9IFtdO1xuICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIGZvcm1zIG9mIG5vcm1hbGl6YXRpb24gYXJlIHN1cHBvcnRlZFxuICAgICAgICBbXCJORkRcIiwgXCJORkNcIiwgXCJORktEXCIsIFwiTkZLQ1wiXS5mb3JFYWNoKChmb3JtKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChcInRlc3RcIi5ub3JtYWxpemUoZm9ybSkgIT09IFwidGVzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBub3JtYWxpemVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaChmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBcIiArIG1pc3Npbmcuam9pbihcIiwgXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU3RyaW5nLmZyb21DaGFyQ29kZSgweGU5KS5ub3JtYWxpemUoXCJORkRcIikgIT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg2NSwgMHgwMzAxKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnJva2VuIGltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBfbm9ybWFsaXplRXJyb3IgPSBfY2hlY2tOb3JtYWxpemUoKTtcbmV4cG9ydCB2YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbXCJERUJVR1wiXSA9IFwiREVCVUdcIjtcbiAgICBMb2dMZXZlbFtcIklORk9cIl0gPSBcIklORk9cIjtcbiAgICBMb2dMZXZlbFtcIldBUk5JTkdcIl0gPSBcIldBUk5JTkdcIjtcbiAgICBMb2dMZXZlbFtcIkVSUk9SXCJdID0gXCJFUlJPUlwiO1xuICAgIExvZ0xldmVsW1wiT0ZGXCJdID0gXCJPRkZcIjtcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XG5leHBvcnQgdmFyIEVycm9yQ29kZTtcbihmdW5jdGlvbiAoRXJyb3JDb2RlKSB7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEdlbmVyaWMgRXJyb3JzXG4gICAgLy8gVW5rbm93biBFcnJvclxuICAgIEVycm9yQ29kZVtcIlVOS05PV05fRVJST1JcIl0gPSBcIlVOS05PV05fRVJST1JcIjtcbiAgICAvLyBOb3QgSW1wbGVtZW50ZWRcbiAgICBFcnJvckNvZGVbXCJOT1RfSU1QTEVNRU5URURcIl0gPSBcIk5PVF9JTVBMRU1FTlRFRFwiO1xuICAgIC8vIFVuc3VwcG9ydGVkIE9wZXJhdGlvblxuICAgIC8vICAgLSBvcGVyYXRpb25cbiAgICBFcnJvckNvZGVbXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIl0gPSBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiO1xuICAgIC8vIE5ldHdvcmsgRXJyb3IgKGkuZS4gRXRoZXJldW0gTmV0d29yaywgc3VjaCBhcyBhbiBpbnZhbGlkIGNoYWluIElEKVxuICAgIC8vICAgLSBldmVudCAoXCJub05ldHdvcmtcIiBpcyBub3QgcmUtdGhyb3duIGluIHByb3ZpZGVyLnJlYWR5OyBvdGhlcndpc2UgdGhyb3duKVxuICAgIEVycm9yQ29kZVtcIk5FVFdPUktfRVJST1JcIl0gPSBcIk5FVFdPUktfRVJST1JcIjtcbiAgICAvLyBTb21lIHNvcnQgb2YgYmFkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxuICAgIEVycm9yQ29kZVtcIlNFUlZFUl9FUlJPUlwiXSA9IFwiU0VSVkVSX0VSUk9SXCI7XG4gICAgLy8gVGltZW91dFxuICAgIEVycm9yQ29kZVtcIlRJTUVPVVRcIl0gPSBcIlRJTUVPVVRcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gT3BlcmF0aW9uYWwgIEVycm9yc1xuICAgIC8vIEJ1ZmZlciBPdmVycnVuXG4gICAgRXJyb3JDb2RlW1wiQlVGRkVSX09WRVJSVU5cIl0gPSBcIkJVRkZFUl9PVkVSUlVOXCI7XG4gICAgLy8gTnVtZXJpYyBGYXVsdFxuICAgIC8vICAgLSBvcGVyYXRpb246IHRoZSBvcGVyYXRpb24gYmVpbmcgZXhlY3V0ZWRcbiAgICAvLyAgIC0gZmF1bHQ6IHRoZSByZWFzb24gdGhpcyBmYXVsdGVkXG4gICAgRXJyb3JDb2RlW1wiTlVNRVJJQ19GQVVMVFwiXSA9IFwiTlVNRVJJQ19GQVVMVFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBBcmd1bWVudCBFcnJvcnNcbiAgICAvLyBNaXNzaW5nIG5ldyBvcGVyYXRvciB0byBhbiBvYmplY3RcbiAgICAvLyAgLSBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgY2xhc3NcbiAgICBFcnJvckNvZGVbXCJNSVNTSU5HX05FV1wiXSA9IFwiTUlTU0lOR19ORVdcIjtcbiAgICAvLyBJbnZhbGlkIGFyZ3VtZW50IChlLmcuIHZhbHVlIGlzIGluY29tcGF0aWJsZSB3aXRoIHR5cGUpIHRvIGEgZnVuY3Rpb246XG4gICAgLy8gICAtIGFyZ3VtZW50OiBUaGUgYXJndW1lbnQgbmFtZSB0aGF0IHdhcyBpbnZhbGlkXG4gICAgLy8gICAtIHZhbHVlOiBUaGUgdmFsdWUgb2YgdGhlIGFyZ3VtZW50XG4gICAgRXJyb3JDb2RlW1wiSU5WQUxJRF9BUkdVTUVOVFwiXSA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiO1xuICAgIC8vIE1pc3NpbmcgYXJndW1lbnQgdG8gYSBmdW5jdGlvbjpcbiAgICAvLyAgIC0gY291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHJlY2VpdmVkXG4gICAgLy8gICAtIGV4cGVjdGVkQ291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGV4cGVjdGVkXG4gICAgRXJyb3JDb2RlW1wiTUlTU0lOR19BUkdVTUVOVFwiXSA9IFwiTUlTU0lOR19BUkdVTUVOVFwiO1xuICAgIC8vIFRvbyBtYW55IGFyZ3VtZW50c1xuICAgIC8vICAgLSBjb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgcmVjZWl2ZWRcbiAgICAvLyAgIC0gZXhwZWN0ZWRDb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgZXhwZWN0ZWRcbiAgICBFcnJvckNvZGVbXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCJdID0gXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEJsb2NrY2hhaW4gRXJyb3JzXG4gICAgLy8gQ2FsbCBleGNlcHRpb25cbiAgICAvLyAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uXG4gICAgLy8gIC0gYWRkcmVzcz86IHRoZSBjb250cmFjdCBhZGRyZXNzXG4gICAgLy8gIC0gYXJncz86IFRoZSBhcmd1bWVudHMgcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uXG4gICAgLy8gIC0gbWV0aG9kPzogVGhlIFNvbGlkaXR5IG1ldGhvZCBzaWduYXR1cmVcbiAgICAvLyAgLSBlcnJvclNpZ25hdHVyZT86IFRoZSBFSVA4NDggZXJyb3Igc2lnbmF0dXJlXG4gICAgLy8gIC0gZXJyb3JBcmdzPzogVGhlIEVJUDg0OCBlcnJvciBwYXJhbWV0ZXJzXG4gICAgLy8gIC0gcmVhc29uOiBUaGUgcmVhc29uIChvbmx5IGZvciBFSVA4NDggXCJFcnJvcihzdHJpbmcpXCIpXG4gICAgRXJyb3JDb2RlW1wiQ0FMTF9FWENFUFRJT05cIl0gPSBcIkNBTExfRVhDRVBUSU9OXCI7XG4gICAgLy8gSW5zdWZmaWNpZW50IGZ1bmRzICg8IHZhbHVlICsgZ2FzTGltaXQgKiBnYXNQcmljZSlcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcbiAgICBFcnJvckNvZGVbXCJJTlNVRkZJQ0lFTlRfRlVORFNcIl0gPSBcIklOU1VGRklDSUVOVF9GVU5EU1wiO1xuICAgIC8vIE5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFxuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuICAgIEVycm9yQ29kZVtcIk5PTkNFX0VYUElSRURcIl0gPSBcIk5PTkNFX0VYUElSRURcIjtcbiAgICAvLyBUaGUgcmVwbGFjZW1lbnQgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb24gaXMgdG9vIGxvd1xuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuICAgIEVycm9yQ29kZVtcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCJdID0gXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiO1xuICAgIC8vIFRoZSBnYXMgbGltaXQgY291bGQgbm90IGJlIGVzdGltYXRlZFxuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIHBhc3NlZCB0byBlc3RpbWF0ZUdhc1xuICAgIEVycm9yQ29kZVtcIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXCJdID0gXCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVFwiO1xuICAgIC8vIFRoZSB0cmFuc2FjdGlvbiB3YXMgcmVwbGFjZWQgYnkgb25lIHdpdGggYSBoaWdoZXIgZ2FzIHByaWNlXG4gICAgLy8gICAtIHJlYXNvbjogXCJjYW5jZWxsZWRcIiwgXCJyZXBsYWNlZFwiIG9yIFwicmVwcmljZWRcIlxuICAgIC8vICAgLSBjYW5jZWxsZWQ6IHRydWUgaWYgcmVhc29uID09IFwiY2FuY2VsbGVkXCIgb3IgcmVhc29uID09IFwicmVwbGFjZWRcIilcbiAgICAvLyAgIC0gaGFzaDogb3JpZ2luYWwgdHJhbnNhY3Rpb24gaGFzaFxuICAgIC8vICAgLSByZXBsYWNlbWVudDogdGhlIGZ1bGwgVHJhbnNhY3Rpb25zUmVzcG9uc2UgZm9yIHRoZSByZXBsYWNlbWVudFxuICAgIC8vICAgLSByZWNlaXB0OiB0aGUgcmVjZWlwdCBvZiB0aGUgcmVwbGFjZW1lbnRcbiAgICBFcnJvckNvZGVbXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiXSA9IFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gSW50ZXJhY3Rpb24gRXJyb3JzXG4gICAgLy8gVGhlIHVzZXIgcmVqZWN0ZWQgdGhlIGFjdGlvbiwgc3VjaCBhcyBzaWduaW5nIGEgbWVzc2FnZSBvciBzZW5kaW5nXG4gICAgLy8gYSB0cmFuc2FjdGlvblxuICAgIEVycm9yQ29kZVtcIkFDVElPTl9SRUpFQ1RFRFwiXSA9IFwiQUNUSU9OX1JFSkVDVEVEXCI7XG59KShFcnJvckNvZGUgfHwgKEVycm9yQ29kZSA9IHt9KSk7XG47XG5jb25zdCBIRVggPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbmV4cG9ydCBjbGFzcyBMb2dnZXIge1xuICAgIGNvbnN0cnVjdG9yKHZlcnNpb24pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZlcnNpb24sXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9sb2cobG9nTGV2ZWwsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBsb2dMZXZlbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoTG9nTGV2ZWxzW2xldmVsXSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbG9nIGxldmVsIG5hbWVcIiwgXCJsb2dMZXZlbFwiLCBsb2dMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9sb2dMZXZlbCA+IExvZ0xldmVsc1tsZXZlbF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgICB9XG4gICAgZGVidWcoLi4uYXJncykge1xuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyLmxldmVscy5ERUJVRywgYXJncyk7XG4gICAgfVxuICAgIGluZm8oLi4uYXJncykge1xuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyLmxldmVscy5JTkZPLCBhcmdzKTtcbiAgICB9XG4gICAgd2FybiguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZyhMb2dnZXIubGV2ZWxzLldBUk5JTkcsIGFyZ3MpO1xuICAgIH1cbiAgICBtYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG4gICAgICAgIC8vIEVycm9ycyBhcmUgYmVpbmcgY2Vuc29yZWRcbiAgICAgICAgaWYgKF9jZW5zb3JFcnJvcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ha2VFcnJvcihcImNlbnNvcmVkIGVycm9yXCIsIGNvZGUsIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIGNvZGUgPSBMb2dnZXIuZXJyb3JzLlVOS05PV05fRVJST1I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VEZXRhaWxzID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoZXggPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZXggKz0gSEVYW3ZhbHVlW2ldID4+IDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGV4ICs9IEhFWFt2YWx1ZVtpXSAmIDB4MGZdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9VWludDhBcnJheSgweFwiICsgaGV4ICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChrZXkgKyBcIj1cIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChrZXkgKyBcIj1cIiArIEpTT04uc3RyaW5naWZ5KHBhcmFtc1trZXldLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goYGNvZGU9JHtjb2RlfWApO1xuICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGB2ZXJzaW9uPSR7dGhpcy52ZXJzaW9ufWApO1xuICAgICAgICBjb25zdCByZWFzb24gPSBtZXNzYWdlO1xuICAgICAgICBsZXQgdXJsID0gXCJcIjtcbiAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5OVU1FUklDX0ZBVUxUOiB7XG4gICAgICAgICAgICAgICAgdXJsID0gXCJOVU1FUklDX0ZBVUxUXCI7XG4gICAgICAgICAgICAgICAgY29uc3QgZmF1bHQgPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm92ZXJmbG93XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmRlcmZsb3dcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRpdmlzaW9uLWJ5LXplcm9cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi1cIiArIGZhdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuZWdhdGl2ZS1wb3dlclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmVnYXRpdmUtd2lkdGhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi11bnN1cHBvcnRlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1bmJvdW5kLWJpdHdpc2UtcmVzdWx0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCItdW5ib3VuZC1yZXN1bHRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLkNBTExfRVhDRVBUSU9OOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuSU5TVUZGSUNJRU5UX0ZVTkRTOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuTUlTU0lOR19ORVc6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5OT05DRV9FWFBJUkVEOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQ6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5UUkFOU0FDVElPTl9SRVBMQUNFRDpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUOlxuICAgICAgICAgICAgICAgIHVybCA9IGNvZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiBbIFNlZTogaHR0cHM6L1xcL2xpbmtzLmV0aGVycy5vcmcvdjUtZXJyb3JzLVwiICsgdXJsICsgXCIgXVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlRGV0YWlscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgbWVzc2FnZURldGFpbHMuam9pbihcIiwgXCIpICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IEFueT8/XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5yZWFzb24gPSByZWFzb247XG4gICAgICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgZXJyb3Jba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICB0aHJvd0Vycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuICAgICAgICB0aHJvdyB0aGlzLm1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpO1xuICAgIH1cbiAgICB0aHJvd0FyZ3VtZW50RXJyb3IobWVzc2FnZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgIGFyZ3VtZW50OiBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCEhY29uZGl0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcyk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGNvbmRpdGlvbiwgbWVzc2FnZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCEhY29uZGl0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0FyZ3VtZW50RXJyb3IobWVzc2FnZSwgbmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBjaGVja05vcm1hbGl6ZShtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX25vcm1hbGl6ZUVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIGZvcm06IF9ub3JtYWxpemVFcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tTYWZlVWludDUzKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcInZhbHVlIG5vdCBzYWZlXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAweDFmZmZmZmZmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImNoZWNrU2FmZUludGVnZXJcIixcbiAgICAgICAgICAgICAgICBmYXVsdDogXCJvdXQtb2Ytc2FmZS1yYW5nZVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICUgMSkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjaGVja1NhZmVJbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgZmF1bHQ6IFwibm9uLWludGVnZXJcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrQXJndW1lbnRDb3VudChjb3VudCwgZXhwZWN0ZWRDb3VudCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiOiBcIiArIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgPCBleHBlY3RlZENvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIGFyZ3VtZW50XCIgKyBtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID4gZXhwZWN0ZWRDb3VudCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzXCIgKyBtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tOZXcodGFyZ2V0LCBraW5kKSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IE9iamVjdCB8fCB0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBuZXdcIiwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX05FVywgeyBuYW1lOiBraW5kLm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tBYnN0cmFjdCh0YXJnZXQsIGtpbmQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0ga2luZCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiY2Fubm90IGluc3RhbnRpYXRlIGFic3RyYWN0IGNsYXNzIFwiICsgSlNPTi5zdHJpbmdpZnkoa2luZC5uYW1lKSArIFwiIGRpcmVjdGx5OyB1c2UgYSBzdWItY2xhc3NcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgbmFtZTogdGFyZ2V0Lm5hbWUsIG9wZXJhdGlvbjogXCJuZXdcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YXJnZXQgPT09IE9iamVjdCB8fCB0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBuZXdcIiwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX05FVywgeyBuYW1lOiBraW5kLm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdsb2JhbExvZ2dlcigpIHtcbiAgICAgICAgaWYgKCFfZ2xvYmFsTG9nZ2VyKSB7XG4gICAgICAgICAgICBfZ2xvYmFsTG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2dsb2JhbExvZ2dlcjtcbiAgICB9XG4gICAgc3RhdGljIHNldENlbnNvcnNoaXAoY2Vuc29yc2hpcCwgcGVybWFuZW50KSB7XG4gICAgICAgIGlmICghY2Vuc29yc2hpcCAmJiBwZXJtYW5lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nZ2VyKCkudGhyb3dFcnJvcihcImNhbm5vdCBwZXJtYW5lbnRseSBkaXNhYmxlIGNlbnNvcnNoaXBcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2V0Q2Vuc29yc2hpcFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3Blcm1hbmVudENlbnNvckVycm9ycykge1xuICAgICAgICAgICAgaWYgKCFjZW5zb3JzaGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiZXJyb3IgY2Vuc29yc2hpcCBwZXJtYW5lbnRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2V0Q2Vuc29yc2hpcFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfY2Vuc29yRXJyb3JzID0gISFjZW5zb3JzaGlwO1xuICAgICAgICBfcGVybWFuZW50Q2Vuc29yRXJyb3JzID0gISFwZXJtYW5lbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBzZXRMb2dMZXZlbChsb2dMZXZlbCkge1xuICAgICAgICBjb25zdCBsZXZlbCA9IExvZ0xldmVsc1tsb2dMZXZlbC50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgaWYgKGxldmVsID09IG51bGwpIHtcbiAgICAgICAgICAgIExvZ2dlci5nbG9iYWxMb2dnZXIoKS53YXJuKFwiaW52YWxpZCBsb2cgbGV2ZWwgLSBcIiArIGxvZ0xldmVsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfbG9nTGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmVyc2lvbikge1xuICAgICAgICByZXR1cm4gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbiAgICB9XG59XG5Mb2dnZXIuZXJyb3JzID0gRXJyb3JDb2RlO1xuTG9nZ2VyLmxldmVscyA9IExvZ0xldmVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9wZXJtYW5lbnRDZW5zb3JFcnJvcnMiLCJfY2Vuc29yRXJyb3JzIiwiTG9nTGV2ZWxzIiwiZGVidWciLCJpbmZvIiwid2FybmluZyIsImVycm9yIiwib2ZmIiwiX2xvZ0xldmVsIiwidmVyc2lvbiIsIl9nbG9iYWxMb2dnZXIiLCJfY2hlY2tOb3JtYWxpemUiLCJtaXNzaW5nIiwiZm9yRWFjaCIsImZvcm0iLCJub3JtYWxpemUiLCJFcnJvciIsInB1c2giLCJsZW5ndGgiLCJqb2luIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwibWVzc2FnZSIsIl9ub3JtYWxpemVFcnJvciIsIkxvZ0xldmVsIiwiRXJyb3JDb2RlIiwiSEVYIiwiTG9nZ2VyIiwiY29uc3RydWN0b3IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiX2xvZyIsImxvZ0xldmVsIiwiYXJncyIsImxldmVsIiwidG9Mb3dlckNhc2UiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJjb25zb2xlIiwibG9nIiwiYXBwbHkiLCJsZXZlbHMiLCJERUJVRyIsIklORk8iLCJ3YXJuIiwiV0FSTklORyIsIm1ha2VFcnJvciIsImNvZGUiLCJwYXJhbXMiLCJlcnJvcnMiLCJVTktOT1dOX0VSUk9SIiwibWVzc2FnZURldGFpbHMiLCJrZXlzIiwia2V5IiwiVWludDhBcnJheSIsImhleCIsImkiLCJKU09OIiwic3RyaW5naWZ5IiwidG9TdHJpbmciLCJyZWFzb24iLCJ1cmwiLCJOVU1FUklDX0ZBVUxUIiwiZmF1bHQiLCJDQUxMX0VYQ0VQVElPTiIsIklOU1VGRklDSUVOVF9GVU5EUyIsIk1JU1NJTkdfTkVXIiwiTk9OQ0VfRVhQSVJFRCIsIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEIiwiVFJBTlNBQ1RJT05fUkVQTEFDRUQiLCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVCIsInRocm93RXJyb3IiLCJuYW1lIiwiSU5WQUxJRF9BUkdVTUVOVCIsImFyZ3VtZW50IiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwiYXNzZXJ0QXJndW1lbnQiLCJjaGVja05vcm1hbGl6ZSIsIlVOU1VQUE9SVEVEX09QRVJBVElPTiIsIm9wZXJhdGlvbiIsImNoZWNrU2FmZVVpbnQ1MyIsImNoZWNrQXJndW1lbnRDb3VudCIsImNvdW50IiwiZXhwZWN0ZWRDb3VudCIsIk1JU1NJTkdfQVJHVU1FTlQiLCJVTkVYUEVDVEVEX0FSR1VNRU5UIiwiY2hlY2tOZXciLCJ0YXJnZXQiLCJraW5kIiwiY2hlY2tBYnN0cmFjdCIsImdsb2JhbExvZ2dlciIsInNldENlbnNvcnNoaXAiLCJjZW5zb3JzaGlwIiwicGVybWFuZW50Iiwic2V0TG9nTGV2ZWwiLCJmcm9tIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/networks/lib.esm/_version.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersproject/networks/lib.esm/_version.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"networks/5.7.1\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvbmV0d29ya3MvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSxpQkFBaUIsQ0FDeEMsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1zdGFydGVyLWtpdC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9uZXR3b3Jrcy9saWIuZXNtL192ZXJzaW9uLmpzP2I3NTAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIm5ldHdvcmtzLzUuNy4xXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/networks/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/networks/lib.esm/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ethersproject/networks/lib.esm/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getNetwork: () => (/* binding */ getNetwork)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/networks/lib.esm/_version.js\");\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n;\nfunction isRenetworkable(value) {\n    return value && typeof value.renetwork === \"function\";\n}\nfunction ethDefaultProvider(network) {\n    const func = function(providers, options) {\n        if (options == null) {\n            options = {};\n        }\n        const providerList = [];\n        if (providers.InfuraProvider && options.infura !== \"-\") {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            } catch (error) {}\n        }\n        if (providers.EtherscanProvider && options.etherscan !== \"-\") {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            } catch (error) {}\n        }\n        if (providers.AlchemyProvider && options.alchemy !== \"-\") {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            } catch (error) {}\n        }\n        if (providers.PocketProvider && options.pocket !== \"-\") {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [\n                \"goerli\",\n                \"ropsten\",\n                \"rinkeby\",\n                \"sepolia\"\n            ];\n            try {\n                const provider = new providers.PocketProvider(network, options.pocket);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch (error) {}\n        }\n        if (providers.CloudflareProvider && options.cloudflare !== \"-\") {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            } catch (error) {}\n        }\n        if (providers.AnkrProvider && options.ankr !== \"-\") {\n            try {\n                const skip = [\n                    \"ropsten\"\n                ];\n                const provider = new providers.AnkrProvider(network, options.ankr);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch (error) {}\n        }\n        if (providerList.length === 0) {\n            return null;\n        }\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            } else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n        return providerList[0];\n    };\n    func.renetwork = function(network) {\n        return ethDefaultProvider(network);\n    };\n    return func;\n}\nfunction etcDefaultProvider(url, network) {\n    const func = function(providers, options) {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n        return null;\n    };\n    func.renetwork = function(network) {\n        return etcDefaultProvider(url, network);\n    };\n    return func;\n}\nconst homestead = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\nconst ropsten = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\nconst classicMordor = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n// See: https://chainlist.org\nconst networks = {\n    unspecified: {\n        chainId: 0,\n        name: \"unspecified\"\n    },\n    homestead: homestead,\n    mainnet: homestead,\n    morden: {\n        chainId: 2,\n        name: \"morden\"\n    },\n    ropsten: ropsten,\n    testnet: ropsten,\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n    kintsugi: {\n        chainId: 1337702,\n        name: \"kintsugi\"\n    },\n    sepolia: {\n        chainId: 11155111,\n        name: \"sepolia\",\n        _defaultProvider: ethDefaultProvider(\"sepolia\")\n    },\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/etc\", \"classic\")\n    },\n    classicMorden: {\n        chainId: 62,\n        name: \"classicMorden\"\n    },\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n    xdai: {\n        chainId: 100,\n        name: \"xdai\"\n    },\n    matic: {\n        chainId: 137,\n        name: \"matic\",\n        _defaultProvider: ethDefaultProvider(\"matic\")\n    },\n    maticmum: {\n        chainId: 80001,\n        name: \"maticmum\"\n    },\n    optimism: {\n        chainId: 10,\n        name: \"optimism\",\n        _defaultProvider: ethDefaultProvider(\"optimism\")\n    },\n    \"optimism-kovan\": {\n        chainId: 69,\n        name: \"optimism-kovan\"\n    },\n    \"optimism-goerli\": {\n        chainId: 420,\n        name: \"optimism-goerli\"\n    },\n    arbitrum: {\n        chainId: 42161,\n        name: \"arbitrum\"\n    },\n    \"arbitrum-rinkeby\": {\n        chainId: 421611,\n        name: \"arbitrum-rinkeby\"\n    },\n    \"arbitrum-goerli\": {\n        chainId: 421613,\n        name: \"arbitrum-goerli\"\n    },\n    bnb: {\n        chainId: 56,\n        name: \"bnb\"\n    },\n    bnbt: {\n        chainId: 97,\n        name: \"bnbt\"\n    }\n};\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */ function getNetwork(network) {\n    // No network (null)\n    if (network == null) {\n        return null;\n    }\n    if (typeof network === \"number\") {\n        for(const name in networks){\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: standard.ensAddress || null,\n                    _defaultProvider: standard._defaultProvider || null\n                };\n            }\n        }\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n    if (typeof network === \"string\") {\n        const standard = networks[network];\n        if (standard == null) {\n            return null;\n        }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: standard._defaultProvider || null\n        };\n    }\n    const standard = networks[network.name];\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof network.chainId !== \"number\") {\n            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        } else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: network.ensAddress || standard.ensAddress || null,\n        _defaultProvider: defaultProvider\n    };\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvbmV0d29ya3MvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBYTtBQUNrQztBQUNWO0FBQ3JDLE1BQU1FLFNBQVMsSUFBSUYseURBQU1BLENBQUNDLDZDQUFPQTs7QUFFakMsU0FBU0UsZ0JBQWdCQyxLQUFLO0lBQzFCLE9BQVFBLFNBQVMsT0FBUUEsTUFBTUMsU0FBUyxLQUFNO0FBQ2xEO0FBQ0EsU0FBU0MsbUJBQW1CQyxPQUFPO0lBQy9CLE1BQU1DLE9BQU8sU0FBVUMsU0FBUyxFQUFFQyxPQUFPO1FBQ3JDLElBQUlBLFdBQVcsTUFBTTtZQUNqQkEsVUFBVSxDQUFDO1FBQ2Y7UUFDQSxNQUFNQyxlQUFlLEVBQUU7UUFDdkIsSUFBSUYsVUFBVUcsY0FBYyxJQUFJRixRQUFRRyxNQUFNLEtBQUssS0FBSztZQUNwRCxJQUFJO2dCQUNBRixhQUFhRyxJQUFJLENBQUMsSUFBSUwsVUFBVUcsY0FBYyxDQUFDTCxTQUFTRyxRQUFRRyxNQUFNO1lBQzFFLEVBQ0EsT0FBT0UsT0FBTyxDQUFFO1FBQ3BCO1FBQ0EsSUFBSU4sVUFBVU8saUJBQWlCLElBQUlOLFFBQVFPLFNBQVMsS0FBSyxLQUFLO1lBQzFELElBQUk7Z0JBQ0FOLGFBQWFHLElBQUksQ0FBQyxJQUFJTCxVQUFVTyxpQkFBaUIsQ0FBQ1QsU0FBU0csUUFBUU8sU0FBUztZQUNoRixFQUNBLE9BQU9GLE9BQU8sQ0FBRTtRQUNwQjtRQUNBLElBQUlOLFVBQVVTLGVBQWUsSUFBSVIsUUFBUVMsT0FBTyxLQUFLLEtBQUs7WUFDdEQsSUFBSTtnQkFDQVIsYUFBYUcsSUFBSSxDQUFDLElBQUlMLFVBQVVTLGVBQWUsQ0FBQ1gsU0FBU0csUUFBUVMsT0FBTztZQUM1RSxFQUNBLE9BQU9KLE9BQU8sQ0FBRTtRQUNwQjtRQUNBLElBQUlOLFVBQVVXLGNBQWMsSUFBSVYsUUFBUVcsTUFBTSxLQUFLLEtBQUs7WUFDcEQseURBQXlEO1lBQ3pE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UUFDcEU7UUFDQSxPQUFPQTtJQUNYO0lBQ0Esd0ZBQXdGO0lBQ3hGLElBQUlBLFFBQVE4QixPQUFPLEtBQUssS0FBSzlCLFFBQVE4QixPQUFPLEtBQUsyQixTQUFTM0IsT0FBTyxFQUFFO1FBQy9EbkMsT0FBTytELGtCQUFrQixDQUFDLDRCQUE0QixXQUFXMUQ7SUFDckU7SUFDQSwrRUFBK0U7SUFDL0UsNkVBQTZFO0lBQzdFLElBQUkyRCxrQkFBa0IzRCxRQUFRZ0MsZ0JBQWdCLElBQUk7SUFDbEQsSUFBSTJCLG1CQUFtQixRQUFRRixTQUFTekIsZ0JBQWdCLEVBQUU7UUFDdEQsSUFBSXBDLGdCQUFnQjZELFNBQVN6QixnQkFBZ0IsR0FBRztZQUM1QzJCLGtCQUFrQkYsU0FBU3pCLGdCQUFnQixDQUFDbEMsU0FBUyxDQUFDRTtRQUMxRCxPQUNLO1lBQ0QyRCxrQkFBa0JGLFNBQVN6QixnQkFBZ0I7UUFDL0M7SUFDSjtJQUNBLHNEQUFzRDtJQUN0RCxPQUFPO1FBQ0hkLE1BQU1sQixRQUFRa0IsSUFBSTtRQUNsQlksU0FBUzJCLFNBQVMzQixPQUFPO1FBQ3pCQyxZQUFhL0IsUUFBUStCLFVBQVUsSUFBSTBCLFNBQVMxQixVQUFVLElBQUk7UUFDMURDLGtCQUFrQjJCO0lBQ3RCO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L25ldHdvcmtzL2xpYi5lc20vaW5kZXguanM/NmQxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbjtcbmZ1bmN0aW9uIGlzUmVuZXR3b3JrYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5yZW5ldHdvcmspID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gZXRoRGVmYXVsdFByb3ZpZGVyKG5ldHdvcmspIHtcbiAgICBjb25zdCBmdW5jID0gZnVuY3Rpb24gKHByb3ZpZGVycywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvdmlkZXJMaXN0ID0gW107XG4gICAgICAgIGlmIChwcm92aWRlcnMuSW5mdXJhUHJvdmlkZXIgJiYgb3B0aW9ucy5pbmZ1cmEgIT09IFwiLVwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuSW5mdXJhUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5pbmZ1cmEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5FdGhlcnNjYW5Qcm92aWRlciAmJiBvcHRpb25zLmV0aGVyc2NhbiAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5FdGhlcnNjYW5Qcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmV0aGVyc2NhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJzLkFsY2hlbXlQcm92aWRlciAmJiBvcHRpb25zLmFsY2hlbXkgIT09IFwiLVwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuQWxjaGVteVByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMuYWxjaGVteSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJzLlBvY2tldFByb3ZpZGVyICYmIG9wdGlvbnMucG9ja2V0ICE9PSBcIi1cIikge1xuICAgICAgICAgICAgLy8gVGhlc2UgbmV0d29ya3MgYXJlIGN1cnJlbnRseSBmYXVsdHkgb24gUG9ja2V0IGFzIHRoZWlyXG4gICAgICAgICAgICAvLyBuZXR3b3JrIGRvZXMgbm90IGhhbmRsZSB0aGUgQmVybGluIGhhcmRmb3JrLCB3aGljaCBpc1xuICAgICAgICAgICAgLy8gbGl2ZSBvbiB0aGVzZSBvbmVzLlxuICAgICAgICAgICAgLy8gQFRPRE86IFRoaXMgZ29lcyBhd2F5IG9uY2UgUG9ja2V0IGhhcyB1cGdyYWRlZCB0aGVpciBub2Rlc1xuICAgICAgICAgICAgY29uc3Qgc2tpcCA9IFtcImdvZXJsaVwiLCBcInJvcHN0ZW5cIiwgXCJyaW5rZWJ5XCIsIFwic2Vwb2xpYVwiXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJzLlBvY2tldFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMucG9ja2V0KTtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIubmV0d29yayAmJiBza2lwLmluZGV4T2YocHJvdmlkZXIubmV0d29yay5uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5DbG91ZGZsYXJlUHJvdmlkZXIgJiYgb3B0aW9ucy5jbG91ZGZsYXJlICE9PSBcIi1cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlckxpc3QucHVzaChuZXcgcHJvdmlkZXJzLkNsb3VkZmxhcmVQcm92aWRlcihuZXR3b3JrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm92aWRlcnMuQW5rclByb3ZpZGVyICYmIG9wdGlvbnMuYW5rciAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2tpcCA9IFtcInJvcHN0ZW5cIl07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJzLkFua3JQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmFua3IpO1xuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlci5uZXR3b3JrICYmIHNraXAuaW5kZXhPZihwcm92aWRlci5uZXR3b3JrLm5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlckxpc3QucHVzaChwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5GYWxsYmFja1Byb3ZpZGVyKSB7XG4gICAgICAgICAgICBsZXQgcXVvcnVtID0gMTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnF1b3J1bSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcXVvcnVtID0gb3B0aW9ucy5xdW9ydW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXR3b3JrID09PSBcImhvbWVzdGVhZFwiKSB7XG4gICAgICAgICAgICAgICAgcXVvcnVtID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgcHJvdmlkZXJzLkZhbGxiYWNrUHJvdmlkZXIocHJvdmlkZXJMaXN0LCBxdW9ydW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm92aWRlckxpc3RbMF07XG4gICAgfTtcbiAgICBmdW5jLnJlbmV0d29yayA9IGZ1bmN0aW9uIChuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBldGhEZWZhdWx0UHJvdmlkZXIobmV0d29yayk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuYztcbn1cbmZ1bmN0aW9uIGV0Y0RlZmF1bHRQcm92aWRlcih1cmwsIG5ldHdvcmspIHtcbiAgICBjb25zdCBmdW5jID0gZnVuY3Rpb24gKHByb3ZpZGVycywgb3B0aW9ucykge1xuICAgICAgICBpZiAocHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKHVybCwgbmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBmdW5jLnJlbmV0d29yayA9IGZ1bmN0aW9uIChuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBldGNEZWZhdWx0UHJvdmlkZXIodXJsLCBuZXR3b3JrKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jO1xufVxuY29uc3QgaG9tZXN0ZWFkID0ge1xuICAgIGNoYWluSWQ6IDEsXG4gICAgZW5zQWRkcmVzczogXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIixcbiAgICBuYW1lOiBcImhvbWVzdGVhZFwiLFxuICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcImhvbWVzdGVhZFwiKVxufTtcbmNvbnN0IHJvcHN0ZW4gPSB7XG4gICAgY2hhaW5JZDogMyxcbiAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgIG5hbWU6IFwicm9wc3RlblwiLFxuICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcInJvcHN0ZW5cIilcbn07XG5jb25zdCBjbGFzc2ljTW9yZG9yID0ge1xuICAgIGNoYWluSWQ6IDYzLFxuICAgIG5hbWU6IFwiY2xhc3NpY01vcmRvclwiLFxuICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0Y0RlZmF1bHRQcm92aWRlcihcImh0dHBzOi8vd3d3LmV0aGVyY2x1c3Rlci5jb20vbW9yZG9yXCIsIFwiY2xhc3NpY01vcmRvclwiKVxufTtcbi8vIFNlZTogaHR0cHM6Ly9jaGFpbmxpc3Qub3JnXG5jb25zdCBuZXR3b3JrcyA9IHtcbiAgICB1bnNwZWNpZmllZDogeyBjaGFpbklkOiAwLCBuYW1lOiBcInVuc3BlY2lmaWVkXCIgfSxcbiAgICBob21lc3RlYWQ6IGhvbWVzdGVhZCxcbiAgICBtYWlubmV0OiBob21lc3RlYWQsXG4gICAgbW9yZGVuOiB7IGNoYWluSWQ6IDIsIG5hbWU6IFwibW9yZGVuXCIgfSxcbiAgICByb3BzdGVuOiByb3BzdGVuLFxuICAgIHRlc3RuZXQ6IHJvcHN0ZW4sXG4gICAgcmlua2VieToge1xuICAgICAgICBjaGFpbklkOiA0LFxuICAgICAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgICAgICBuYW1lOiBcInJpbmtlYnlcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwicmlua2VieVwiKVxuICAgIH0sXG4gICAga292YW46IHtcbiAgICAgICAgY2hhaW5JZDogNDIsXG4gICAgICAgIG5hbWU6IFwia292YW5cIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwia292YW5cIilcbiAgICB9LFxuICAgIGdvZXJsaToge1xuICAgICAgICBjaGFpbklkOiA1LFxuICAgICAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgICAgICBuYW1lOiBcImdvZXJsaVwiLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJnb2VybGlcIilcbiAgICB9LFxuICAgIGtpbnRzdWdpOiB7IGNoYWluSWQ6IDEzMzc3MDIsIG5hbWU6IFwia2ludHN1Z2lcIiB9LFxuICAgIHNlcG9saWE6IHtcbiAgICAgICAgY2hhaW5JZDogMTExNTUxMTEsXG4gICAgICAgIG5hbWU6IFwic2Vwb2xpYVwiLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJzZXBvbGlhXCIpXG4gICAgfSxcbiAgICAvLyBFVEMgKFNlZTogIzM1MSlcbiAgICBjbGFzc2ljOiB7XG4gICAgICAgIGNoYWluSWQ6IDYxLFxuICAgICAgICBuYW1lOiBcImNsYXNzaWNcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRjRGVmYXVsdFByb3ZpZGVyKFwiaHR0cHM6L1xcL3d3dy5ldGhlcmNsdXN0ZXIuY29tL2V0Y1wiLCBcImNsYXNzaWNcIilcbiAgICB9LFxuICAgIGNsYXNzaWNNb3JkZW46IHsgY2hhaW5JZDogNjIsIG5hbWU6IFwiY2xhc3NpY01vcmRlblwiIH0sXG4gICAgY2xhc3NpY01vcmRvcjogY2xhc3NpY01vcmRvcixcbiAgICBjbGFzc2ljVGVzdG5ldDogY2xhc3NpY01vcmRvcixcbiAgICBjbGFzc2ljS290dGk6IHtcbiAgICAgICAgY2hhaW5JZDogNixcbiAgICAgICAgbmFtZTogXCJjbGFzc2ljS290dGlcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRjRGVmYXVsdFByb3ZpZGVyKFwiaHR0cHM6L1xcL3d3dy5ldGhlcmNsdXN0ZXIuY29tL2tvdHRpXCIsIFwiY2xhc3NpY0tvdHRpXCIpXG4gICAgfSxcbiAgICB4ZGFpOiB7IGNoYWluSWQ6IDEwMCwgbmFtZTogXCJ4ZGFpXCIgfSxcbiAgICBtYXRpYzoge1xuICAgICAgICBjaGFpbklkOiAxMzcsXG4gICAgICAgIG5hbWU6IFwibWF0aWNcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwibWF0aWNcIilcbiAgICB9LFxuICAgIG1hdGljbXVtOiB7IGNoYWluSWQ6IDgwMDAxLCBuYW1lOiBcIm1hdGljbXVtXCIgfSxcbiAgICBvcHRpbWlzbToge1xuICAgICAgICBjaGFpbklkOiAxMCxcbiAgICAgICAgbmFtZTogXCJvcHRpbWlzbVwiLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJvcHRpbWlzbVwiKVxuICAgIH0sXG4gICAgXCJvcHRpbWlzbS1rb3ZhblwiOiB7IGNoYWluSWQ6IDY5LCBuYW1lOiBcIm9wdGltaXNtLWtvdmFuXCIgfSxcbiAgICBcIm9wdGltaXNtLWdvZXJsaVwiOiB7IGNoYWluSWQ6IDQyMCwgbmFtZTogXCJvcHRpbWlzbS1nb2VybGlcIiB9LFxuICAgIGFyYml0cnVtOiB7IGNoYWluSWQ6IDQyMTYxLCBuYW1lOiBcImFyYml0cnVtXCIgfSxcbiAgICBcImFyYml0cnVtLXJpbmtlYnlcIjogeyBjaGFpbklkOiA0MjE2MTEsIG5hbWU6IFwiYXJiaXRydW0tcmlua2VieVwiIH0sXG4gICAgXCJhcmJpdHJ1bS1nb2VybGlcIjogeyBjaGFpbklkOiA0MjE2MTMsIG5hbWU6IFwiYXJiaXRydW0tZ29lcmxpXCIgfSxcbiAgICBibmI6IHsgY2hhaW5JZDogNTYsIG5hbWU6IFwiYm5iXCIgfSxcbiAgICBibmJ0OiB7IGNoYWluSWQ6IDk3LCBuYW1lOiBcImJuYnRcIiB9LFxufTtcbi8qKlxuICogIGdldE5ldHdvcmtcbiAqXG4gKiAgQ29udmVydHMgYSBuYW1lZCBjb21tb24gbmV0d29ya3Mgb3IgY2hhaW4gSUQgKG5ldHdvcmsgSUQpIHRvIGEgTmV0d29ya1xuICogIGFuZCB2ZXJpZmllcyBhIG5ldHdvcmsgaXMgYSB2YWxpZCBOZXR3b3JrLi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5ldHdvcmsobmV0d29yaykge1xuICAgIC8vIE5vIG5ldHdvcmsgKG51bGwpXG4gICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIG5ldHdvcmtzKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFuZGFyZCA9IG5ldHdvcmtzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHN0YW5kYXJkLmNoYWluSWQgPT09IG5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdGFuZGFyZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBzdGFuZGFyZC5jaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICBlbnNBZGRyZXNzOiAoc3RhbmRhcmQuZW5zQWRkcmVzcyB8fCBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogKHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIgfHwgbnVsbClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFpbklkOiBuZXR3b3JrLFxuICAgICAgICAgICAgbmFtZTogXCJ1bmtub3duXCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3Qgc3RhbmRhcmQgPSBuZXR3b3Jrc1tuZXR3b3JrXTtcbiAgICAgICAgaWYgKHN0YW5kYXJkID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBzdGFuZGFyZC5uYW1lLFxuICAgICAgICAgICAgY2hhaW5JZDogc3RhbmRhcmQuY2hhaW5JZCxcbiAgICAgICAgICAgIGVuc0FkZHJlc3M6IHN0YW5kYXJkLmVuc0FkZHJlc3MsXG4gICAgICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiAoc3RhbmRhcmQuX2RlZmF1bHRQcm92aWRlciB8fCBudWxsKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzdGFuZGFyZCA9IG5ldHdvcmtzW25ldHdvcmsubmFtZV07XG4gICAgLy8gTm90IGEgc3RhbmRhcmQgbmV0d29yazsgY2hlY2sgdGhhdCBpdCBpcyBhIHZhbGlkIG5ldHdvcmsgaW4gZ2VuZXJhbFxuICAgIGlmICghc3RhbmRhcmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yay5jaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbmV0d29yayBjaGFpbklkXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBjaGFpbklkIG1hdGNoZXMgdGhlIGV4cGVjdGVkIG5ldHdvcmsgY2hhaW5JZCAob3IgaXMgMDsgZGlzYWJsZSBFSVAtMTU1KVxuICAgIGlmIChuZXR3b3JrLmNoYWluSWQgIT09IDAgJiYgbmV0d29yay5jaGFpbklkICE9PSBzdGFuZGFyZC5jaGFpbklkKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJuZXR3b3JrIGNoYWluSWQgbWlzbWF0Y2hcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgIH1cbiAgICAvLyBAVE9ETzogSW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBhZGQgYW4gYXR0YWNoIGZ1bmN0aW9uIHRvIGEgZGVmYXVsdFByb3ZpZGVyXG4gICAgLy8gY2xhc3MgYW5kIG1vdmUgdGhlIF9kZWZhdWx0UHJvdmlkZXIgaW50ZXJuYWwgdG8gdGhpcyBmaWxlIChleHRlbmQgTmV0d29yaylcbiAgICBsZXQgZGVmYXVsdFByb3ZpZGVyID0gbmV0d29yay5fZGVmYXVsdFByb3ZpZGVyIHx8IG51bGw7XG4gICAgaWYgKGRlZmF1bHRQcm92aWRlciA9PSBudWxsICYmIHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKGlzUmVuZXR3b3JrYWJsZShzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyKSkge1xuICAgICAgICAgICAgZGVmYXVsdFByb3ZpZGVyID0gc3RhbmRhcmQuX2RlZmF1bHRQcm92aWRlci5yZW5ldHdvcmsobmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0UHJvdmlkZXIgPSBzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFN0YW5kYXJkIE5ldHdvcmsgKGFsbG93IG92ZXJyaWRpbmcgdGhlIEVOUyBhZGRyZXNzKVxuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5ldHdvcmsubmFtZSxcbiAgICAgICAgY2hhaW5JZDogc3RhbmRhcmQuY2hhaW5JZCxcbiAgICAgICAgZW5zQWRkcmVzczogKG5ldHdvcmsuZW5zQWRkcmVzcyB8fCBzdGFuZGFyZC5lbnNBZGRyZXNzIHx8IG51bGwpLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBkZWZhdWx0UHJvdmlkZXJcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJpc1JlbmV0d29ya2FibGUiLCJ2YWx1ZSIsInJlbmV0d29yayIsImV0aERlZmF1bHRQcm92aWRlciIsIm5ldHdvcmsiLCJmdW5jIiwicHJvdmlkZXJzIiwib3B0aW9ucyIsInByb3ZpZGVyTGlzdCIsIkluZnVyYVByb3ZpZGVyIiwiaW5mdXJhIiwicHVzaCIsImVycm9yIiwiRXRoZXJzY2FuUHJvdmlkZXIiLCJldGhlcnNjYW4iLCJBbGNoZW15UHJvdmlkZXIiLCJhbGNoZW15IiwiUG9ja2V0UHJvdmlkZXIiLCJwb2NrZXQiLCJza2lwIiwicHJvdmlkZXIiLCJpbmRleE9mIiwibmFtZSIsIkNsb3VkZmxhcmVQcm92aWRlciIsImNsb3VkZmxhcmUiLCJBbmtyUHJvdmlkZXIiLCJhbmtyIiwibGVuZ3RoIiwiRmFsbGJhY2tQcm92aWRlciIsInF1b3J1bSIsImV0Y0RlZmF1bHRQcm92aWRlciIsInVybCIsIkpzb25ScGNQcm92aWRlciIsImhvbWVzdGVhZCIsImNoYWluSWQiLCJlbnNBZGRyZXNzIiwiX2RlZmF1bHRQcm92aWRlciIsInJvcHN0ZW4iLCJjbGFzc2ljTW9yZG9yIiwibmV0d29ya3MiLCJ1bnNwZWNpZmllZCIsIm1haW5uZXQiLCJtb3JkZW4iLCJ0ZXN0bmV0Iiwicmlua2VieSIsImtvdmFuIiwiZ29lcmxpIiwia2ludHN1Z2kiLCJzZXBvbGlhIiwiY2xhc3NpYyIsImNsYXNzaWNNb3JkZW4iLCJjbGFzc2ljVGVzdG5ldCIsImNsYXNzaWNLb3R0aSIsInhkYWkiLCJtYXRpYyIsIm1hdGljbXVtIiwib3B0aW1pc20iLCJhcmJpdHJ1bSIsImJuYiIsImJuYnQiLCJnZXROZXR3b3JrIiwic3RhbmRhcmQiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJkZWZhdWx0UHJvdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/networks/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/properties/lib.esm/_version.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ethersproject/properties/lib.esm/_version.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"properties/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvcGVydGllcy9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSxVQUFVLG1CQUFtQixDQUMxQyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXMvbGliLmVzbS9fdmVyc2lvbi5qcz8zMmJlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJwcm9wZXJ0aWVzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/properties/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/properties/lib.esm/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersproject/properties/lib.esm/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Description: () => (/* binding */ Description),\n/* harmony export */   checkProperties: () => (/* binding */ checkProperties),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   defineReadOnly: () => (/* binding */ defineReadOnly),\n/* harmony export */   getStatic: () => (/* binding */ getStatic),\n/* harmony export */   resolveProperties: () => (/* binding */ resolveProperties),\n/* harmony export */   shallowCopy: () => (/* binding */ shallowCopy)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/properties/lib.esm/_version.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nfunction defineReadOnly(object, name, value) {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false\n    });\n}\n// Crawl up the constructor chain to find a static method\nfunction getStatic(ctor, key) {\n    for(let i = 0; i < 32; i++){\n        if (ctor[key]) {\n            return ctor[key];\n        }\n        if (!ctor.prototype || typeof ctor.prototype !== \"object\") {\n            break;\n        }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\nfunction resolveProperties(object) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const promises = Object.keys(object).map((key)=>{\n            const value = object[key];\n            return Promise.resolve(value).then((v)=>({\n                    key: key,\n                    value: v\n                }));\n        });\n        const results = yield Promise.all(promises);\n        return results.reduce((accum, result)=>{\n            accum[result.key] = result.value;\n            return accum;\n        }, {});\n    });\n}\nfunction checkProperties(object, properties) {\n    if (!object || typeof object !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n    Object.keys(object).forEach((key)=>{\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\nfunction shallowCopy(object) {\n    const result = {};\n    for(const key in object){\n        result[key] = object[key];\n    }\n    return result;\n}\nconst opaque = {\n    bigint: true,\n    boolean: true,\n    \"function\": true,\n    number: true,\n    string: true\n};\nfunction _isFrozen(object) {\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof object]) {\n        return true;\n    }\n    if (Array.isArray(object) || typeof object === \"object\") {\n        if (!Object.isFrozen(object)) {\n            return false;\n        }\n        const keys = Object.keys(object);\n        for(let i = 0; i < keys.length; i++){\n            let value = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                continue;\n            }\n            if (!_isFrozen(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n    if (_isFrozen(object)) {\n        return object;\n    }\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item)=>deepCopy(item)));\n    }\n    if (typeof object === \"object\") {\n        const result = {};\n        for(const key in object){\n            const value = object[key];\n            if (value === undefined) {\n                continue;\n            }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n        return result;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, \"object\", object);\n}\nfunction deepCopy(object) {\n    return _deepCopy(object);\n}\nclass Description {\n    constructor(info){\n        for(const key in info){\n            this[key] = deepCopy(info[key]);\n        }\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvcGVydGllcy9saWIuZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFhO0FBQ2IsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQytDO0FBQ1Y7QUFDckMsTUFBTVMsU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BO0FBQzFCLFNBQVNFLGVBQWVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFbEIsS0FBSztJQUM5Q21C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WDtJQUNBLE9BQU9lLE9BQU8wQixrQkFBa0IsQ0FBQyxDQUFDLGdCQUFnQixFQUFFLE9BQVF4QixPQUFRLENBQUMsRUFBRSxVQUFVQTtBQUNyRjtBQUNBLHlFQUF5RTtBQUN6RSwrQ0FBK0M7QUFDL0MsU0FBU3VDLFVBQVV2QyxNQUFNO0lBQ3JCLElBQUlnQyxVQUFVaEMsU0FBUztRQUNuQixPQUFPQTtJQUNYO0lBQ0Esa0RBQWtEO0lBQ2xELElBQUlrQyxNQUFNQyxPQUFPLENBQUNuQyxTQUFTO1FBQ3ZCLE9BQU9FLE9BQU9zQyxNQUFNLENBQUN4QyxPQUFPZ0IsR0FBRyxDQUFDLENBQUN5QixPQUFTQyxTQUFTRDtJQUN2RDtJQUNBLElBQUksT0FBUXpDLFdBQVksVUFBVTtRQUM5QixNQUFNUixTQUFTLENBQUM7UUFDaEIsSUFBSyxNQUFNZ0IsT0FBT1IsT0FBUTtZQUN0QixNQUFNakIsUUFBUWlCLE1BQU0sQ0FBQ1EsSUFBSTtZQUN6QixJQUFJekIsVUFBVWtELFdBQVc7Z0JBQ3JCO1lBQ0o7WUFDQWxDLGVBQWVQLFFBQVFnQixLQUFLa0MsU0FBUzNEO1FBQ3pDO1FBQ0EsT0FBT1M7SUFDWDtJQUNBLE9BQU9NLE9BQU8wQixrQkFBa0IsQ0FBQyxDQUFDLGdCQUFnQixFQUFFLE9BQVF4QixPQUFRLENBQUMsRUFBRSxVQUFVQTtBQUNyRjtBQUNPLFNBQVMwQyxTQUFTMUMsTUFBTTtJQUMzQixPQUFPdUMsVUFBVXZDO0FBQ3JCO0FBQ08sTUFBTTJDO0lBQ1QvQixZQUFZZ0MsSUFBSSxDQUFFO1FBQ2QsSUFBSyxNQUFNcEMsT0FBT29DLEtBQU07WUFDcEIsSUFBSSxDQUFDcEMsSUFBSSxHQUFHa0MsU0FBU0UsSUFBSSxDQUFDcEMsSUFBSTtRQUNsQztJQUNKO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXMvbGliLmVzbS9pbmRleC5qcz8yNjhlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lUmVhZE9ubHkob2JqZWN0LCBuYW1lLCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgfSk7XG59XG4vLyBDcmF3bCB1cCB0aGUgY29uc3RydWN0b3IgY2hhaW4gdG8gZmluZCBhIHN0YXRpYyBtZXRob2RcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGF0aWMoY3Rvciwga2V5KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgIGlmIChjdG9yW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBjdG9yW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdG9yLnByb3RvdHlwZSB8fCB0eXBlb2YgKGN0b3IucHJvdG90eXBlKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdG9yLnByb3RvdHlwZSkuY29uc3RydWN0b3I7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVQcm9wZXJ0aWVzKG9iamVjdCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gT2JqZWN0LmtleXMob2JqZWN0KS5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oKHYpID0+ICh7IGtleToga2V5LCB2YWx1ZTogdiB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHRzID0geWllbGQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoKGFjY3VtLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGFjY3VtWyhyZXN1bHQua2V5KV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1Byb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFvYmplY3QgfHwgdHlwZW9mIChvYmplY3QpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9iamVjdFwiLCBcIm9iamVjdFwiLCBvYmplY3QpO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAoIXByb3BlcnRpZXNba2V5XSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgb2JqZWN0IGtleSAtIFwiICsga2V5LCBcInRyYW5zYWN0aW9uOlwiICsga2V5LCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0NvcHkob2JqZWN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBvcGFxdWUgPSB7IGJpZ2ludDogdHJ1ZSwgYm9vbGVhbjogdHJ1ZSwgXCJmdW5jdGlvblwiOiB0cnVlLCBudW1iZXI6IHRydWUsIHN0cmluZzogdHJ1ZSB9O1xuZnVuY3Rpb24gX2lzRnJvemVuKG9iamVjdCkge1xuICAgIC8vIE9wYXF1ZSBvYmplY3RzIGFyZSBub3QgbXV0YWJsZSwgc28gc2FmZSB0byBjb3B5IGJ5IGFzc2lnbm1lbnRcbiAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQgfHwgb2JqZWN0ID09PSBudWxsIHx8IG9wYXF1ZVt0eXBlb2YgKG9iamVjdCldKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpIHx8IHR5cGVvZiAob2JqZWN0KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoIU9iamVjdC5pc0Zyb3plbihvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5c1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhY2Nlc3NpbmcgYSB2YWx1ZSB0cmlnZ2VycyBhbiBlcnJvciwgaXQgaXMgYSBnZXR0ZXJcbiAgICAgICAgICAgICAgICAvLyBkZXNpZ25lZCB0byBkbyBzbyAoZS5nLiBSZXN1bHQpIGFuZCBpcyB0aGVyZWZvcmUgXCJmcm96ZW5cIlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfaXNGcm96ZW4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgQ2Fubm90IGRlZXBDb3B5ICR7dHlwZW9mIChvYmplY3QpfWAsIFwib2JqZWN0XCIsIG9iamVjdCk7XG59XG4vLyBSZXR1cm5zIGEgbmV3IGNvcHkgb2Ygb2JqZWN0LCBzdWNoIHRoYXQgbm8gcHJvcGVydGllcyBtYXkgYmUgcmVwbGFjZWQuXG4vLyBOZXcgcHJvcGVydGllcyBtYXkgYmUgYWRkZWQgb25seSB0byBvYmplY3RzLlxuZnVuY3Rpb24gX2RlZXBDb3B5KG9iamVjdCkge1xuICAgIGlmIChfaXNGcm96ZW4ob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICAvLyBBcnJheXMgYXJlIG11dGFibGUsIHNvIHdlIG5lZWQgdG8gY3JlYXRlIGEgY29weVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUob2JqZWN0Lm1hcCgoaXRlbSkgPT4gZGVlcENvcHkoaXRlbSkpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAob2JqZWN0KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHJlc3VsdCwga2V5LCBkZWVwQ29weSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBDYW5ub3QgZGVlcENvcHkgJHt0eXBlb2YgKG9iamVjdCl9YCwgXCJvYmplY3RcIiwgb2JqZWN0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ29weShvYmplY3QpIHtcbiAgICByZXR1cm4gX2RlZXBDb3B5KG9iamVjdCk7XG59XG5leHBvcnQgY2xhc3MgRGVzY3JpcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGluZm8pIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5mbykge1xuICAgICAgICAgICAgdGhpc1trZXldID0gZGVlcENvcHkoaW5mb1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiZGVmaW5lUmVhZE9ubHkiLCJvYmplY3QiLCJuYW1lIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJnZXRTdGF0aWMiLCJjdG9yIiwia2V5IiwiaSIsInByb3RvdHlwZSIsImdldFByb3RvdHlwZU9mIiwiY29uc3RydWN0b3IiLCJyZXNvbHZlUHJvcGVydGllcyIsInByb21pc2VzIiwia2V5cyIsIm1hcCIsInYiLCJyZXN1bHRzIiwiYWxsIiwicmVkdWNlIiwiYWNjdW0iLCJjaGVja1Byb3BlcnRpZXMiLCJwcm9wZXJ0aWVzIiwidGhyb3dBcmd1bWVudEVycm9yIiwiZm9yRWFjaCIsInNoYWxsb3dDb3B5Iiwib3BhcXVlIiwiYmlnaW50IiwiYm9vbGVhbiIsIm51bWJlciIsInN0cmluZyIsIl9pc0Zyb3plbiIsInVuZGVmaW5lZCIsIkFycmF5IiwiaXNBcnJheSIsImlzRnJvemVuIiwibGVuZ3RoIiwiZXJyb3IiLCJfZGVlcENvcHkiLCJmcmVlemUiLCJpdGVtIiwiZGVlcENvcHkiLCJEZXNjcmlwdGlvbiIsImluZm8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/properties/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/providers/lib.esm/_version.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/_version.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"providers/5.7.2\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFVBQVUsa0JBQWtCLENBQ3pDLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vX3ZlcnNpb24uanM/MDFiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwicHJvdmlkZXJzLzUuNy4yXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/providers/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/providers/lib.esm/base-provider.js":
/*!************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/base-provider.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseProvider: () => (/* binding */ BaseProvider),\n/* harmony export */   Event: () => (/* binding */ Event),\n/* harmony export */   Resolver: () => (/* binding */ Resolver)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/abstract-provider */ \"(ssr)/./node_modules/@ethersproject/abstract-provider/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_base64__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @ethersproject/base64 */ \"(ssr)/./node_modules/@ethersproject/base64/lib.esm/base64.js\");\n/* harmony import */ var _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/basex */ \"(ssr)/./node_modules/@ethersproject/basex/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/./node_modules/@ethersproject/constants/lib.esm/hashes.js\");\n/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/./node_modules/@ethersproject/hash/lib.esm/namehash.js\");\n/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @ethersproject/networks */ \"(ssr)/./node_modules/@ethersproject/networks/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/sha2 */ \"(ssr)/./node_modules/@ethersproject/sha2/lib.esm/sha2.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/./node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var bech32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bech32 */ \"(ssr)/./node_modules/bech32/index.js\");\n/* harmony import */ var bech32__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bech32__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./formatter */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/formatter.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(_version__WEBPACK_IMPORTED_MODULE_2__.version);\n\nconst MAX_CCIP_REDIRECTS = 10;\n//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic) {\n    if (topic == null) {\n        return \"null\";\n    }\n    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(topic) !== 32) {\n        logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n    }\n    return topic.toLowerCase();\n}\nfunction serializeTopics(topics) {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while(topics.length > 0 && topics[topics.length - 1] == null){\n        topics.pop();\n    }\n    return topics.map((topic)=>{\n        if (Array.isArray(topic)) {\n            // Only track unique OR-topics\n            const unique = {};\n            topic.forEach((topic)=>{\n                unique[checkTopic(topic)] = true;\n            });\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n            return sorted.join(\"|\");\n        } else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic)=>{\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic)=>{\n            return topic === \"null\" ? null : topic;\n        });\n        return comps.length === 1 ? comps[0] : comps;\n    });\n}\nfunction getEventTag(eventName) {\n    if (typeof eventName === \"string\") {\n        eventName = eventName.toLowerCase();\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n    } else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n    } else if (_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__.ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n    } else if (eventName && typeof eventName === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n    throw new Error(\"invalid event - \" + eventName);\n}\n//////////////////////////////\n// Helper Object\nfunction getTime() {\n    return new Date().getTime();\n}\nfunction stall(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, duration);\n    });\n}\n//////////////////////////////\n// Provider Object\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */ const PollableEvents = [\n    \"block\",\n    \"network\",\n    \"pending\",\n    \"poll\"\n];\nclass Event {\n    constructor(tag, listener, once){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"tag\", tag);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"listener\", listener);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"once\", once);\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n    get event() {\n        switch(this.type){\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n        }\n        return this.tag;\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            return null;\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            return null;\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        return this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0;\n    }\n}\n;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos = {\n    \"0\": {\n        symbol: \"btc\",\n        p2pkh: 0x00,\n        p2sh: 0x05,\n        prefix: \"bc\"\n    },\n    \"2\": {\n        symbol: \"ltc\",\n        p2pkh: 0x30,\n        p2sh: 0x32,\n        prefix: \"ltc\"\n    },\n    \"3\": {\n        symbol: \"doge\",\n        p2pkh: 0x1e,\n        p2sh: 0x16\n    },\n    \"60\": {\n        symbol: \"eth\",\n        ilk: \"eth\"\n    },\n    \"61\": {\n        symbol: \"etc\",\n        ilk: \"eth\"\n    },\n    \"700\": {\n        symbol: \"xdai\",\n        ilk: \"eth\"\n    }\n};\nfunction bytes32ify(value) {\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(value).toHexString(), 32);\n}\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data) {\n    return _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__.Base58.encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n        data,\n        (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__.sha256)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__.sha256)(data)), 0, 4)\n    ]));\n}\nconst matcherIpfs = new RegExp(\"^(ipfs)://(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https)://(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\")\n];\nfunction _parseString(result, start) {\n    try {\n        return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__.toUtf8String)(_parseBytes(result, start));\n    } catch (error) {}\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    const offset = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, start, start + 32)).toNumber();\n    const length = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, offset, offset + 32)).toNumber();\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, offset + 32, offset + 32 + length);\n}\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\nfunction numPad(value) {\n    const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if (value.length % 32 === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for(let i = 0; i < datas.length; i++){\n        result.push(null);\n        byteCount += 32;\n    }\n    for(let i = 0; i < datas.length; i++){\n        const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(result);\n}\nclass Resolver {\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider, address, name, resolvedAddress){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"provider\", provider);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"name\", name);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"address\", provider.formatter.address(address));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"_resolvedAddress\", resolvedAddress);\n    }\n    supportsWildcard() {\n        if (!this._supportsEip2544) {\n            // supportsInterface(bytes4 = selector(\"resolve(bytes,bytes)\"))\n            this._supportsEip2544 = this.provider.call({\n                to: this.address,\n                data: \"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"\n            }).then((result)=>{\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result).eq(1);\n            }).catch((error)=>{\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                    return false;\n                }\n                // Rethrow the error: link is down, etc. Let future attempts retry.\n                this._supportsEip2544 = null;\n                throw error;\n            });\n        }\n        return this._supportsEip2544;\n    }\n    _fetch(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // e.g. keccak256(\"addr(bytes32,uint256)\")\n            const tx = {\n                to: this.address,\n                ccipReadEnabled: true,\n                data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                    selector,\n                    (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(this.name),\n                    parameters || \"0x\"\n                ])\n            };\n            // Wildcard support; use EIP-2544 to resolve the request\n            let parseBytes = false;\n            if (yield this.supportsWildcard()) {\n                parseBytes = true;\n                // selector(\"resolve(bytes,bytes)\")\n                tx.data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                    \"0x9061b923\",\n                    encodeBytes([\n                        (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.dnsEncode)(this.name),\n                        tx.data\n                    ])\n                ]);\n            }\n            try {\n                let result = yield this.provider.call(tx);\n                if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(result).length % 32 === 4) {\n                    logger.throwError(\"resolver threw error\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                        transaction: tx,\n                        data: result\n                    });\n                }\n                if (parseBytes) {\n                    result = _parseBytes(result, 0);\n                }\n                return result;\n            } catch (error) {\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                throw error;\n            }\n        });\n    }\n    _fetchBytes(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const result = yield this._fetch(selector, parameters);\n            if (result != null) {\n                return _parseBytes(result, 0);\n            }\n            return null;\n        });\n    }\n    _getAddress(coinType, hexBytes) {\n        const coinInfo = coinInfos[String(coinType)];\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${coinType}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${coinType})`\n            });\n        }\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n        const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(hexBytes);\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n                        [\n                            coinInfo.p2pkh\n                        ],\n                        \"0x\" + p2pkh[2]\n                    ]));\n                }\n            }\n        }\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n                        [\n                            coinInfo.p2sh\n                        ],\n                        \"0x\" + p2sh[2]\n                    ]));\n                }\n            }\n        }\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            } else {\n                version = -1;\n            }\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32__WEBPACK_IMPORTED_MODULE_0___default().toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32__WEBPACK_IMPORTED_MODULE_0___default().encode(coinInfo.prefix, words);\n            }\n        }\n        return null;\n    }\n    getAddress(coinType) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (coinType == null) {\n                coinType = 60;\n            }\n            // If Ethereum, use the standard `addr(bytes32)`\n            if (coinType === 60) {\n                try {\n                    // keccak256(\"addr(bytes32)\")\n                    const result = yield this._fetch(\"0x3b3b57de\");\n                    // No address\n                    if (result === \"0x\" || result === _ethersproject_constants__WEBPACK_IMPORTED_MODULE_11__.HashZero) {\n                        return null;\n                    }\n                    return this.provider.formatter.callAddress(result);\n                } catch (error) {\n                    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                        return null;\n                    }\n                    throw error;\n                }\n            }\n            // keccak256(\"addr(bytes32,uint256\")\n            const hexBytes = yield this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n            // No address\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // Compute the address\n            const address = this._getAddress(coinType, hexBytes);\n            if (address == null) {\n                logger.throwError(`invalid or unsupported coin data`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `getAddress(${coinType})`,\n                    coinType: coinType,\n                    data: hexBytes\n                });\n            }\n            return address;\n        });\n    }\n    getAvatar() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const linkage = [\n                {\n                    type: \"name\",\n                    content: this.name\n                }\n            ];\n            try {\n                // test data for ricmoo.eth\n                //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n                const avatar = yield this.getText(\"avatar\");\n                if (avatar == null) {\n                    return null;\n                }\n                for(let i = 0; i < matchers.length; i++){\n                    const match = avatar.match(matchers[i]);\n                    if (match == null) {\n                        continue;\n                    }\n                    const scheme = match[1].toLowerCase();\n                    switch(scheme){\n                        case \"https\":\n                            linkage.push({\n                                type: \"url\",\n                                content: avatar\n                            });\n                            return {\n                                linkage,\n                                url: avatar\n                            };\n                        case \"data\":\n                            linkage.push({\n                                type: \"data\",\n                                content: avatar\n                            });\n                            return {\n                                linkage,\n                                url: avatar\n                            };\n                        case \"ipfs\":\n                            linkage.push({\n                                type: \"ipfs\",\n                                content: avatar\n                            });\n                            return {\n                                linkage,\n                                url: getIpfsLink(avatar)\n                            };\n                        case \"erc721\":\n                        case \"erc1155\":\n                            {\n                                // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                                const selector = scheme === \"erc721\" ? \"0xc87b56dd\" : \"0x0e89341c\";\n                                linkage.push({\n                                    type: scheme,\n                                    content: avatar\n                                });\n                                // The owner of this name\n                                const owner = this._resolvedAddress || (yield this.getAddress());\n                                const comps = (match[2] || \"\").split(\"/\");\n                                if (comps.length !== 2) {\n                                    return null;\n                                }\n                                const addr = yield this.provider.formatter.address(comps[0]);\n                                const tokenId = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(comps[1]).toHexString(), 32);\n                                // Check that this account owns the token\n                                if (scheme === \"erc721\") {\n                                    // ownerOf(uint256 tokenId)\n                                    const tokenOwner = this.provider.formatter.callAddress((yield this.provider.call({\n                                        to: addr,\n                                        data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                                            \"0x6352211e\",\n                                            tokenId\n                                        ])\n                                    })));\n                                    if (owner !== tokenOwner) {\n                                        return null;\n                                    }\n                                    linkage.push({\n                                        type: \"owner\",\n                                        content: tokenOwner\n                                    });\n                                } else if (scheme === \"erc1155\") {\n                                    // balanceOf(address owner, uint256 tokenId)\n                                    const balance = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((yield this.provider.call({\n                                        to: addr,\n                                        data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                                            \"0x00fdd58e\",\n                                            (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(owner, 32),\n                                            tokenId\n                                        ])\n                                    })));\n                                    if (balance.isZero()) {\n                                        return null;\n                                    }\n                                    linkage.push({\n                                        type: \"balance\",\n                                        content: balance.toString()\n                                    });\n                                }\n                                // Call the token contract for the metadata URL\n                                const tx = {\n                                    to: this.provider.formatter.address(comps[0]),\n                                    data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                                        selector,\n                                        tokenId\n                                    ])\n                                };\n                                let metadataUrl = _parseString((yield this.provider.call(tx)), 0);\n                                if (metadataUrl == null) {\n                                    return null;\n                                }\n                                linkage.push({\n                                    type: \"metadata-url-base\",\n                                    content: metadataUrl\n                                });\n                                // ERC-1155 allows a generic {id} in the URL\n                                if (scheme === \"erc1155\") {\n                                    metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                                    linkage.push({\n                                        type: \"metadata-url-expanded\",\n                                        content: metadataUrl\n                                    });\n                                }\n                                // Transform IPFS metadata links\n                                if (metadataUrl.match(/^ipfs:/i)) {\n                                    metadataUrl = getIpfsLink(metadataUrl);\n                                }\n                                linkage.push({\n                                    type: \"metadata-url\",\n                                    content: metadataUrl\n                                });\n                                // Get the token metadata\n                                const metadata = yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.fetchJson)(metadataUrl);\n                                if (!metadata) {\n                                    return null;\n                                }\n                                linkage.push({\n                                    type: \"metadata\",\n                                    content: JSON.stringify(metadata)\n                                });\n                                // Pull the image URL out\n                                let imageUrl = metadata.image;\n                                if (typeof imageUrl !== \"string\") {\n                                    return null;\n                                }\n                                if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                                // Allow\n                                } else {\n                                    // Transform IPFS link to gateway\n                                    const ipfs = imageUrl.match(matcherIpfs);\n                                    if (ipfs == null) {\n                                        return null;\n                                    }\n                                    linkage.push({\n                                        type: \"url-ipfs\",\n                                        content: imageUrl\n                                    });\n                                    imageUrl = getIpfsLink(imageUrl);\n                                }\n                                linkage.push({\n                                    type: \"url\",\n                                    content: imageUrl\n                                });\n                                return {\n                                    linkage,\n                                    url: imageUrl\n                                };\n                            }\n                    }\n                }\n            } catch (error) {}\n            return null;\n        });\n    }\n    getContentHash() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // keccak256(\"contenthash()\")\n            const hexBytes = yield this._fetchBytes(\"0xbc1c58d1\");\n            // No contenthash\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // IPFS (CID: 1, Type: DAG-PB)\n            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipfs) {\n                const length = parseInt(ipfs[3], 16);\n                if (ipfs[4].length === length * 2) {\n                    return \"ipfs://\" + _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__.Base58.encode(\"0x\" + ipfs[1]);\n                }\n            }\n            // IPNS (CID: 1, Type: libp2p-key)\n            const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipns) {\n                const length = parseInt(ipns[3], 16);\n                if (ipns[4].length === length * 2) {\n                    return \"ipns://\" + _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__.Base58.encode(\"0x\" + ipns[1]);\n                }\n            }\n            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n            if (swarm) {\n                if (swarm[1].length === 32 * 2) {\n                    return \"bzz://\" + swarm[1];\n                }\n            }\n            const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);\n            if (skynet) {\n                if (skynet[1].length === 34 * 2) {\n                    // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5\n                    const urlSafe = {\n                        \"=\": \"\",\n                        \"+\": \"-\",\n                        \"/\": \"_\"\n                    };\n                    const hash = (0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_13__.encode)(\"0x\" + skynet[1]).replace(/[=+\\/]/g, (a)=>urlSafe[a]);\n                    return \"sia://\" + hash;\n                }\n            }\n            return logger.throwError(`invalid or unsupported content hash data`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"getContentHash()\",\n                data: hexBytes\n            });\n        });\n    }\n    getText(key) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // The key encoded as parameter to fetchBytes\n            let keyBytes = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__.toUtf8Bytes)(key);\n            // The nodehash consumes the first slot, so the string pointer targets\n            // offset 64, with the length at offset 64 and data starting at offset 96\n            keyBytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n                bytes32ify(64),\n                bytes32ify(keyBytes.length),\n                keyBytes\n            ]);\n            // Pad to word-size (32 bytes)\n            if (keyBytes.length % 32 !== 0) {\n                keyBytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([\n                    keyBytes,\n                    (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(\"0x\", 32 - key.length % 32)\n                ]);\n            }\n            const hexBytes = yield this._fetchBytes(\"0x59d1d43c\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(keyBytes));\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__.toUtf8String)(hexBytes);\n        });\n    }\n}\nlet defaultFormatter = null;\nlet nextPollId = 1;\nclass BaseProvider extends _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__.Provider {\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */ constructor(network){\n        super();\n        // Events being listened to\n        this._events = [];\n        this._emitted = {\n            block: -2\n        };\n        this.disableCcipRead = false;\n        this.formatter = new.target.getFormatter();\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"anyNetwork\", network === \"any\");\n        if (this.anyNetwork) {\n            network = this.detectNetwork();\n        }\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error)=>{});\n            // Trigger initial network setting (async)\n            this._ready().catch((error)=>{});\n        } else {\n            const knownNetwork = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.getStatic)(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n            } else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n        this._maxInternalBlockNumber = -1024;\n        this._lastBlockNumber = -2;\n        this._maxFilterBlockRange = 10;\n        this._pollingInterval = 4000;\n        this._fastQueryDate = 0;\n    }\n    _ready() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._network == null) {\n                let network = null;\n                if (this._networkPromise) {\n                    try {\n                        network = yield this._networkPromise;\n                    } catch (error) {}\n                }\n                // Try the Provider's network detection (this MUST throw if it cannot)\n                if (network == null) {\n                    network = yield this.detectNetwork();\n                }\n                // This should never happen; every Provider sub-class should have\n                // suggested a network by here (or have thrown).\n                if (!network) {\n                    logger.throwError(\"no network detected\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // Possible this call stacked so do not call defineReadOnly again\n                if (this._network == null) {\n                    if (this.anyNetwork) {\n                        this._network = network;\n                    } else {\n                        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, \"_network\", network);\n                    }\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return this._network;\n        });\n    }\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready() {\n        return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(()=>{\n            return this._ready().then((network)=>{\n                return network;\n            }, (error)=>{\n                // If the network isn't running yet, we will wait\n                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter() {\n        if (defaultFormatter == null) {\n            defaultFormatter = new _formatter__WEBPACK_IMPORTED_MODULE_14__.Formatter();\n        }\n        return defaultFormatter;\n    }\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network) {\n        return (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_15__.getNetwork)(network == null ? \"homestead\" : network);\n    }\n    ccipReadFetch(tx, calldata, urls) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.disableCcipRead || urls.length === 0) {\n                return null;\n            }\n            const sender = tx.to.toLowerCase();\n            const data = calldata.toLowerCase();\n            const errorMessages = [];\n            for(let i = 0; i < urls.length; i++){\n                const url = urls[i];\n                // URL expansion\n                const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n                // If no {data} is present, use POST; otherwise GET\n                const json = url.indexOf(\"{data}\") >= 0 ? null : JSON.stringify({\n                    data,\n                    sender\n                });\n                const result = yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.fetchJson)({\n                    url: href,\n                    errorPassThrough: true\n                }, json, (value, response)=>{\n                    value.status = response.statusCode;\n                    return value;\n                });\n                if (result.data) {\n                    return result.data;\n                }\n                const errorMessage = result.message || \"unknown error\";\n                // 4xx indicates the result is not present; stop\n                if (result.status >= 400 && result.status < 500) {\n                    return logger.throwError(`response not found during CCIP fetch: ${errorMessage}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                        url,\n                        errorMessage\n                    });\n                }\n                // 5xx indicates server issue; try the next url\n                errorMessages.push(errorMessage);\n            }\n            return logger.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m)=>JSON.stringify(m)).join(\", \")}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                urls,\n                errorMessages\n            });\n        });\n    }\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    _getInternalBlockNumber(maxAge) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this._ready();\n            // Allowing stale data up to maxAge old\n            if (maxAge > 0) {\n                // While there are pending internal block requests...\n                while(this._internalBlockNumber){\n                    // ...\"remember\" which fetch we started with\n                    const internalBlockNumber = this._internalBlockNumber;\n                    try {\n                        // Check the result is not too stale\n                        const result = yield internalBlockNumber;\n                        if (getTime() - result.respTime <= maxAge) {\n                            return result.blockNumber;\n                        }\n                        break;\n                    } catch (error) {\n                        // The fetch rejected; if we are the first to get the\n                        // rejection, drop through so we replace it with a new\n                        // fetch; all others blocked will then get that fetch\n                        // which won't match the one they \"remembered\" and loop\n                        if (this._internalBlockNumber === internalBlockNumber) {\n                            break;\n                        }\n                    }\n                }\n            }\n            const reqTime = getTime();\n            const checkInternalBlockNumber = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                blockNumber: this.perform(\"getBlockNumber\", {}),\n                networkError: this.getNetwork().then((network)=>null, (error)=>error)\n            }).then(({ blockNumber, networkError })=>{\n                if (networkError) {\n                    // Unremember this bad internal block number\n                    if (this._internalBlockNumber === checkInternalBlockNumber) {\n                        this._internalBlockNumber = null;\n                    }\n                    throw networkError;\n                }\n                const respTime = getTime();\n                blockNumber = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(blockNumber).toNumber();\n                if (blockNumber < this._maxInternalBlockNumber) {\n                    blockNumber = this._maxInternalBlockNumber;\n                }\n                this._maxInternalBlockNumber = blockNumber;\n                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n                return {\n                    blockNumber,\n                    reqTime,\n                    respTime\n                };\n            });\n            this._internalBlockNumber = checkInternalBlockNumber;\n            // Swallow unhandled exceptions; if needed they are handled else where\n            checkInternalBlockNumber.catch((error)=>{\n                // Don't null the dead (rejected) fetch, if it has already been updated\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n            });\n            return (yield checkInternalBlockNumber).blockNumber;\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const pollId = nextPollId++;\n            // Track all running promises, so we can trigger a post-poll once they are complete\n            const runners = [];\n            let blockNumber = null;\n            try {\n                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n            } catch (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this._setFastBlockNumber(blockNumber);\n            // Emit a poll event after we have the latest (fast) block number\n            this.emit(\"poll\", pollId, blockNumber);\n            // If the block has not changed, meh.\n            if (blockNumber === this._lastBlockNumber) {\n                this.emit(\"didPoll\", pollId);\n                return;\n            }\n            // First polling cycle, trigger a \"block\" events\n            if (this._emitted.block === -2) {\n                this._emitted.block = blockNumber - 1;\n            }\n            if (Math.abs(this._emitted.block - blockNumber) > 1000) {\n                logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);\n                this.emit(\"error\", logger.makeError(\"network block skew detected\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NETWORK_ERROR, {\n                    blockNumber: blockNumber,\n                    event: \"blockSkew\",\n                    previousBlockNumber: this._emitted.block\n                }));\n                this.emit(\"block\", blockNumber);\n            } else {\n                // Notify all listener for each block that has passed\n                for(let i = this._emitted.block + 1; i <= blockNumber; i++){\n                    this.emit(\"block\", i);\n                }\n            }\n            // The emitted block was updated, check for obsolete events\n            if (this._emitted.block !== blockNumber) {\n                this._emitted.block = blockNumber;\n                Object.keys(this._emitted).forEach((key)=>{\n                    // The block event does not expire\n                    if (key === \"block\") {\n                        return;\n                    }\n                    // The block we were at when we emitted this event\n                    const eventBlockNumber = this._emitted[key];\n                    // We cannot garbage collect pending transactions or blocks here\n                    // They should be garbage collected by the Provider when setting\n                    // \"pending\" events\n                    if (eventBlockNumber === \"pending\") {\n                        return;\n                    }\n                    // Evict any transaction hashes or block hashes over 12 blocks\n                    // old, since they should not return null anyways\n                    if (blockNumber - eventBlockNumber > 12) {\n                        delete this._emitted[key];\n                    }\n                });\n            }\n            // First polling cycle\n            if (this._lastBlockNumber === -2) {\n                this._lastBlockNumber = blockNumber - 1;\n            }\n            // Find all transaction hashes we are waiting on\n            this._events.forEach((event)=>{\n                switch(event.type){\n                    case \"tx\":\n                        {\n                            const hash = event.hash;\n                            let runner = this.getTransactionReceipt(hash).then((receipt)=>{\n                                if (!receipt || receipt.blockNumber == null) {\n                                    return null;\n                                }\n                                this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                                this.emit(hash, receipt);\n                                return null;\n                            }).catch((error)=>{\n                                this.emit(\"error\", error);\n                            });\n                            runners.push(runner);\n                            break;\n                        }\n                    case \"filter\":\n                        {\n                            // We only allow a single getLogs to be in-flight at a time\n                            if (!event._inflight) {\n                                event._inflight = true;\n                                // This is the first filter for this event, so we want to\n                                // restrict events to events that happened no earlier than now\n                                if (event._lastBlockNumber === -2) {\n                                    event._lastBlockNumber = blockNumber - 1;\n                                }\n                                // Filter from the last *known* event; due to load-balancing\n                                // and some nodes returning updated block numbers before\n                                // indexing events, a logs result with 0 entries cannot be\n                                // trusted and we must retry a range which includes it again\n                                const filter = event.filter;\n                                filter.fromBlock = event._lastBlockNumber + 1;\n                                filter.toBlock = blockNumber;\n                                // Prevent fitler ranges from growing too wild, since it is quite\n                                // likely there just haven't been any events to move the lastBlockNumber.\n                                const minFromBlock = filter.toBlock - this._maxFilterBlockRange;\n                                if (minFromBlock > filter.fromBlock) {\n                                    filter.fromBlock = minFromBlock;\n                                }\n                                if (filter.fromBlock < 0) {\n                                    filter.fromBlock = 0;\n                                }\n                                const runner = this.getLogs(filter).then((logs)=>{\n                                    // Allow the next getLogs\n                                    event._inflight = false;\n                                    if (logs.length === 0) {\n                                        return;\n                                    }\n                                    logs.forEach((log)=>{\n                                        // Only when we get an event for a given block number\n                                        // can we trust the events are indexed\n                                        if (log.blockNumber > event._lastBlockNumber) {\n                                            event._lastBlockNumber = log.blockNumber;\n                                        }\n                                        // Make sure we stall requests to fetch blocks and txs\n                                        this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                        this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                                        this.emit(filter, log);\n                                    });\n                                }).catch((error)=>{\n                                    this.emit(\"error\", error);\n                                    // Allow another getLogs (the range was not updated)\n                                    event._inflight = false;\n                                });\n                                runners.push(runner);\n                            }\n                            break;\n                        }\n                }\n            });\n            this._lastBlockNumber = blockNumber;\n            // Once all events for this loop have been processed, emit \"didPoll\"\n            Promise.all(runners).then(()=>{\n                this.emit(\"didPoll\", pollId);\n            }).catch((error)=>{\n                this.emit(\"error\", error);\n            });\n            return;\n        });\n    }\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber) {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) {\n            this.poll();\n        }\n    }\n    get network() {\n        return this._network;\n    }\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return logger.throwError(\"provider does not support network detection\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"provider.detectNetwork\"\n            });\n        });\n    }\n    getNetwork() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const network = yield this._ready();\n            // Make sure we are still connected to the same network; this is\n            // only an external call for backends which can have the underlying\n            // network change spontaneously\n            const currentNetwork = yield this.detectNetwork();\n            if (network.chainId !== currentNetwork.chainId) {\n                // We are allowing network changes, things can get complex fast;\n                // make sure you know what you are doing if you use \"any\"\n                if (this.anyNetwork) {\n                    this._network = currentNetwork;\n                    // Reset all internal block number guards and caches\n                    this._lastBlockNumber = -2;\n                    this._fastBlockNumber = null;\n                    this._fastBlockNumberPromise = null;\n                    this._fastQueryDate = 0;\n                    this._emitted.block = -2;\n                    this._maxInternalBlockNumber = -1024;\n                    this._internalBlockNumber = null;\n                    // The \"network\" event MUST happen before this method resolves\n                    // so any events have a chance to unregister, so we stall an\n                    // additional event loop before returning from /this/ call\n                    this.emit(\"network\", currentNetwork, network);\n                    yield stall(0);\n                    return this._network;\n                }\n                const error = logger.makeError(\"underlying network changed\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NETWORK_ERROR, {\n                    event: \"changed\",\n                    network: network,\n                    detectedNetwork: currentNetwork\n                });\n                this.emit(\"error\", error);\n                throw error;\n            }\n            return network;\n        });\n    }\n    get blockNumber() {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber)=>{\n            this._setFastBlockNumber(blockNumber);\n        }, (error)=>{});\n        return this._fastBlockNumber != null ? this._fastBlockNumber : -1;\n    }\n    get polling() {\n        return this._poller != null;\n    }\n    set polling(value) {\n        if (value && !this._poller) {\n            this._poller = setInterval(()=>{\n                this.poll();\n            }, this.pollingInterval);\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(()=>{\n                    this.poll();\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(()=>{\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) {\n                            this.poll();\n                        }\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n        } else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n    get pollingInterval() {\n        return this._pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (typeof value !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n        this._pollingInterval = value;\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(()=>{\n                this.poll();\n            }, this._pollingInterval);\n        }\n    }\n    _getFastBlockNumber() {\n        const now = getTime();\n        // Stale block number, request a newer value\n        if (now - this._fastQueryDate > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber)=>{\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n        return this._fastBlockNumberPromise;\n    }\n    _setFastBlockNumber(blockNumber) {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n            return;\n        }\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n    waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);\n        });\n    }\n    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const receipt = yield this.getTransactionReceipt(transactionHash);\n            // Receipt is already good\n            if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n                return receipt;\n            }\n            // Poll until the receipt is good...\n            return new Promise((resolve, reject)=>{\n                const cancelFuncs = [];\n                let done = false;\n                const alreadyDone = function() {\n                    if (done) {\n                        return true;\n                    }\n                    done = true;\n                    cancelFuncs.forEach((func)=>{\n                        func();\n                    });\n                    return false;\n                };\n                const minedHandler = (receipt)=>{\n                    if (receipt.confirmations < confirmations) {\n                        return;\n                    }\n                    if (alreadyDone()) {\n                        return;\n                    }\n                    resolve(receipt);\n                };\n                this.on(transactionHash, minedHandler);\n                cancelFuncs.push(()=>{\n                    this.removeListener(transactionHash, minedHandler);\n                });\n                if (replaceable) {\n                    let lastBlockNumber = replaceable.startBlock;\n                    let scannedBlock = null;\n                    const replaceHandler = (blockNumber)=>__awaiter(this, void 0, void 0, function*() {\n                            if (done) {\n                                return;\n                            }\n                            // Wait 1 second; this is only used in the case of a fault, so\n                            // we will trade off a little bit of latency for more consistent\n                            // results and fewer JSON-RPC calls\n                            yield stall(1000);\n                            this.getTransactionCount(replaceable.from).then((nonce)=>__awaiter(this, void 0, void 0, function*() {\n                                    if (done) {\n                                        return;\n                                    }\n                                    if (nonce <= replaceable.nonce) {\n                                        lastBlockNumber = blockNumber;\n                                    } else {\n                                        // First check if the transaction was mined\n                                        {\n                                            const mined = yield this.getTransaction(transactionHash);\n                                            if (mined && mined.blockNumber != null) {\n                                                return;\n                                            }\n                                        }\n                                        // First time scanning. We start a little earlier for some\n                                        // wiggle room here to handle the eventually consistent nature\n                                        // of blockchain (e.g. the getTransactionCount was for a\n                                        // different block)\n                                        if (scannedBlock == null) {\n                                            scannedBlock = lastBlockNumber - 3;\n                                            if (scannedBlock < replaceable.startBlock) {\n                                                scannedBlock = replaceable.startBlock;\n                                            }\n                                        }\n                                        while(scannedBlock <= blockNumber){\n                                            if (done) {\n                                                return;\n                                            }\n                                            const block = yield this.getBlockWithTransactions(scannedBlock);\n                                            for(let ti = 0; ti < block.transactions.length; ti++){\n                                                const tx = block.transactions[ti];\n                                                // Successfully mined!\n                                                if (tx.hash === transactionHash) {\n                                                    return;\n                                                }\n                                                // Matches our transaction from and nonce; its a replacement\n                                                if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                                    if (done) {\n                                                        return;\n                                                    }\n                                                    // Get the receipt of the replacement\n                                                    const receipt = yield this.waitForTransaction(tx.hash, confirmations);\n                                                    // Already resolved or rejected (prolly a timeout)\n                                                    if (alreadyDone()) {\n                                                        return;\n                                                    }\n                                                    // The reason we were replaced\n                                                    let reason = \"replaced\";\n                                                    if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                                        reason = \"repriced\";\n                                                    } else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                                        reason = \"cancelled\";\n                                                    }\n                                                    // Explain why we were replaced\n                                                    reject(logger.makeError(\"transaction was replaced\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.TRANSACTION_REPLACED, {\n                                                        cancelled: reason === \"replaced\" || reason === \"cancelled\",\n                                                        reason,\n                                                        replacement: this._wrapTransaction(tx),\n                                                        hash: transactionHash,\n                                                        receipt\n                                                    }));\n                                                    return;\n                                                }\n                                            }\n                                            scannedBlock++;\n                                        }\n                                    }\n                                    if (done) {\n                                        return;\n                                    }\n                                    this.once(\"block\", replaceHandler);\n                                }), (error)=>{\n                                if (done) {\n                                    return;\n                                }\n                                this.once(\"block\", replaceHandler);\n                            });\n                        });\n                    if (done) {\n                        return;\n                    }\n                    this.once(\"block\", replaceHandler);\n                    cancelFuncs.push(()=>{\n                        this.removeListener(\"block\", replaceHandler);\n                    });\n                }\n                if (typeof timeout === \"number\" && timeout > 0) {\n                    const timer = setTimeout(()=>{\n                        if (alreadyDone()) {\n                            return;\n                        }\n                        reject(logger.makeError(\"timeout exceeded\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.TIMEOUT, {\n                            timeout: timeout\n                        }));\n                    }, timeout);\n                    if (timer.unref) {\n                        timer.unref();\n                    }\n                    cancelFuncs.push(()=>{\n                        clearTimeout(timer);\n                    });\n                }\n            });\n        });\n    }\n    getBlockNumber() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this._getInternalBlockNumber(0);\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const result = yield this.perform(\"getGasPrice\", {});\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getGasPrice\",\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    getBalance(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getBalance\", params);\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getBalance\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    getTransactionCount(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getTransactionCount\", params);\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result).toNumber();\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getTransactionCount\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    getCode(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getCode\", params);\n            try {\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getCode\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    getStorageAt(addressOrName, position, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag),\n                position: Promise.resolve(position).then((p)=>(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexValue)(p))\n            });\n            const result = yield this.perform(\"getStorageAt\", params);\n            try {\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"getStorageAt\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx, hash, startBlock) {\n        if (hash != null && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(hash) !== 32) {\n            throw new Error(\"invalid response - sendTransaction\");\n        }\n        const result = tx;\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNKNOWN_ERROR, {\n                expectedHash: tx.hash,\n                returnedHash: hash\n            });\n        }\n        result.wait = (confirms, timeout)=>__awaiter(this, void 0, void 0, function*() {\n                if (confirms == null) {\n                    confirms = 1;\n                }\n                if (timeout == null) {\n                    timeout = 0;\n                }\n                // Get the details to detect replacement\n                let replacement = undefined;\n                if (confirms !== 0 && startBlock != null) {\n                    replacement = {\n                        data: tx.data,\n                        from: tx.from,\n                        nonce: tx.nonce,\n                        to: tx.to,\n                        value: tx.value,\n                        startBlock\n                    };\n                }\n                const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n                if (receipt == null && confirms === 0) {\n                    return null;\n                }\n                // No longer pending, allow the polling loop to garbage collect this\n                this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n                if (receipt.status === 0) {\n                    logger.throwError(\"transaction failed\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                        transactionHash: tx.hash,\n                        transaction: tx,\n                        receipt: receipt\n                    });\n                }\n                return receipt;\n            });\n        return result;\n    }\n    sendTransaction(signedTransaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const hexTx = yield Promise.resolve(signedTransaction).then((t)=>(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(t));\n            const tx = this.formatter.transaction(signedTransaction);\n            if (tx.confirmations == null) {\n                tx.confirmations = 0;\n            }\n            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            try {\n                const hash = yield this.perform(\"sendTransaction\", {\n                    signedTransaction: hexTx\n                });\n                return this._wrapTransaction(tx, hash, blockNumber);\n            } catch (error) {\n                error.transaction = tx;\n                error.transactionHash = tx.hash;\n                throw error;\n            }\n        });\n    }\n    _getTransactionRequest(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const values = yield transaction;\n            const tx = {};\n            [\n                \"from\",\n                \"to\"\n            ].forEach((key)=>{\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v)=>v ? this._getAddress(v) : null);\n            });\n            [\n                \"gasLimit\",\n                \"gasPrice\",\n                \"maxFeePerGas\",\n                \"maxPriorityFeePerGas\",\n                \"value\"\n            ].forEach((key)=>{\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v)=>v ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(v) : null);\n            });\n            [\n                \"type\"\n            ].forEach((key)=>{\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v)=>v != null ? v : null);\n            });\n            if (values.accessList) {\n                tx.accessList = this.formatter.accessList(values.accessList);\n            }\n            [\n                \"data\"\n            ].forEach((key)=>{\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v)=>v ? (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(v) : null);\n            });\n            return this.formatter.transactionRequest((yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)(tx)));\n        });\n    }\n    _getFilter(filter) {\n        return __awaiter(this, void 0, void 0, function*() {\n            filter = yield filter;\n            const result = {};\n            if (filter.address != null) {\n                result.address = this._getAddress(filter.address);\n            }\n            [\n                \"blockHash\",\n                \"topics\"\n            ].forEach((key)=>{\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = filter[key];\n            });\n            [\n                \"fromBlock\",\n                \"toBlock\"\n            ].forEach((key)=>{\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = this._getBlockTag(filter[key]);\n            });\n            return this.formatter.filter((yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)(result)));\n        });\n    }\n    _call(transaction, blockTag, attempt) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (attempt >= MAX_CCIP_REDIRECTS) {\n                logger.throwError(\"CCIP read exceeded maximum redirections\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    redirects: attempt,\n                    transaction\n                });\n            }\n            const txSender = transaction.to;\n            const result = yield this.perform(\"call\", {\n                transaction,\n                blockTag\n            });\n            // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)\n            if (attempt >= 0 && blockTag === \"latest\" && txSender != null && result.substring(0, 10) === \"0x556f1830\" && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(result) % 32 === 4) {\n                try {\n                    const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, 4);\n                    // Check the sender of the OffchainLookup matches the transaction\n                    const sender = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 0, 32);\n                    if (!_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(sender).eq(txSender)) {\n                        logger.throwError(\"CCIP Read sender did not match\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction,\n                            data: result\n                        });\n                    }\n                    // Read the URLs from the response\n                    const urls = [];\n                    const urlsOffset = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 32, 64)).toNumber();\n                    const urlsLength = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, urlsOffset, urlsOffset + 32)).toNumber();\n                    const urlsData = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, urlsOffset + 32);\n                    for(let u = 0; u < urlsLength; u++){\n                        const url = _parseString(urlsData, u * 32);\n                        if (url == null) {\n                            logger.throwError(\"CCIP Read contained corrupt URL string\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                                name: \"OffchainLookup\",\n                                signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                                transaction,\n                                data: result\n                            });\n                        }\n                        urls.push(url);\n                    }\n                    // Get the CCIP calldata to forward\n                    const calldata = _parseBytes(data, 64);\n                    // Get the callbackSelector (bytes4)\n                    if (!_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 100, 128)).isZero()) {\n                        logger.throwError(\"CCIP Read callback selector included junk\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction,\n                            data: result\n                        });\n                    }\n                    const callbackSelector = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 96, 100);\n                    // Get the extra data to send back to the contract as context\n                    const extraData = _parseBytes(data, 128);\n                    const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);\n                    if (ccipResult == null) {\n                        logger.throwError(\"CCIP Read disabled or provided no URLs\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction,\n                            data: result\n                        });\n                    }\n                    const tx = {\n                        to: txSender,\n                        data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([\n                            callbackSelector,\n                            encodeBytes([\n                                ccipResult,\n                                extraData\n                            ])\n                        ])\n                    };\n                    return this._call(tx, blockTag, attempt + 1);\n                } catch (error) {\n                    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR) {\n                        throw error;\n                    }\n                }\n            }\n            try {\n                return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"call\",\n                    params: {\n                        transaction,\n                        blockTag\n                    },\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const resolved = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                transaction: this._getTransactionRequest(transaction),\n                blockTag: this._getBlockTag(blockTag),\n                ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)\n            });\n            return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);\n        });\n    }\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                transaction: this._getTransactionRequest(transaction)\n            });\n            const result = yield this.perform(\"estimateGas\", params);\n            try {\n                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result);\n            } catch (error) {\n                return logger.throwError(\"bad result from backend\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {\n                    method: \"estimateGas\",\n                    params,\n                    result,\n                    error\n                });\n            }\n        });\n    }\n    _getAddress(addressOrName) {\n        return __awaiter(this, void 0, void 0, function*() {\n            addressOrName = yield addressOrName;\n            if (typeof addressOrName !== \"string\") {\n                logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n            }\n            const address = yield this.resolveName(addressOrName);\n            if (address == null) {\n                logger.throwError(\"ENS name not configured\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `resolveName(${JSON.stringify(addressOrName)})`\n                });\n            }\n            return address;\n        });\n    }\n    _getBlock(blockHashOrBlockTag, includeTransactions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            blockHashOrBlockTag = yield blockHashOrBlockTag;\n            // If blockTag is a number (not \"latest\", etc), this is the block number\n            let blockNumber = -128;\n            const params = {\n                includeTransactions: !!includeTransactions\n            };\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(blockHashOrBlockTag, 32)) {\n                params.blockHash = blockHashOrBlockTag;\n            } else {\n                try {\n                    params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);\n                    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(params.blockTag)) {\n                        blockNumber = parseInt(params.blockTag.substring(2), 16);\n                    }\n                } catch (error) {\n                    logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n                }\n            }\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(()=>__awaiter(this, void 0, void 0, function*() {\n                    const block = yield this.perform(\"getBlock\", params);\n                    // Block was not found\n                    if (block == null) {\n                        // For blockhashes, if we didn't say it existed, that blockhash may\n                        // not exist. If we did see it though, perhaps from a log, we know\n                        // it exists, and this node is just not caught up yet.\n                        if (params.blockHash != null) {\n                            if (this._emitted[\"b:\" + params.blockHash] == null) {\n                                return null;\n                            }\n                        }\n                        // For block tags, if we are asking for a future block, we return null\n                        if (params.blockTag != null) {\n                            if (blockNumber > this._emitted.block) {\n                                return null;\n                            }\n                        }\n                        // Retry on the next block\n                        return undefined;\n                    }\n                    // Add transactions\n                    if (includeTransactions) {\n                        let blockNumber = null;\n                        for(let i = 0; i < block.transactions.length; i++){\n                            const tx = block.transactions[i];\n                            if (tx.blockNumber == null) {\n                                tx.confirmations = 0;\n                            } else if (tx.confirmations == null) {\n                                if (blockNumber == null) {\n                                    blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                                }\n                                // Add the confirmations using the fast block number (pessimistic)\n                                let confirmations = blockNumber - tx.blockNumber + 1;\n                                if (confirmations <= 0) {\n                                    confirmations = 1;\n                                }\n                                tx.confirmations = confirmations;\n                            }\n                        }\n                        const blockWithTxs = this.formatter.blockWithTransactions(block);\n                        blockWithTxs.transactions = blockWithTxs.transactions.map((tx)=>this._wrapTransaction(tx));\n                        return blockWithTxs;\n                    }\n                    return this.formatter.block(block);\n                }), {\n                oncePoll: this\n            });\n        });\n    }\n    getBlock(blockHashOrBlockTag) {\n        return this._getBlock(blockHashOrBlockTag, false);\n    }\n    getBlockWithTransactions(blockHashOrBlockTag) {\n        return this._getBlock(blockHashOrBlockTag, true);\n    }\n    getTransaction(transactionHash) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = {\n                transactionHash: this.formatter.hash(transactionHash, true)\n            };\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(()=>__awaiter(this, void 0, void 0, function*() {\n                    const result = yield this.perform(\"getTransaction\", params);\n                    if (result == null) {\n                        if (this._emitted[\"t:\" + transactionHash] == null) {\n                            return null;\n                        }\n                        return undefined;\n                    }\n                    const tx = this.formatter.transactionResponse(result);\n                    if (tx.blockNumber == null) {\n                        tx.confirmations = 0;\n                    } else if (tx.confirmations == null) {\n                        const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = blockNumber - tx.blockNumber + 1;\n                        if (confirmations <= 0) {\n                            confirmations = 1;\n                        }\n                        tx.confirmations = confirmations;\n                    }\n                    return this._wrapTransaction(tx);\n                }), {\n                oncePoll: this\n            });\n        });\n    }\n    getTransactionReceipt(transactionHash) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = {\n                transactionHash: this.formatter.hash(transactionHash, true)\n            };\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(()=>__awaiter(this, void 0, void 0, function*() {\n                    const result = yield this.perform(\"getTransactionReceipt\", params);\n                    if (result == null) {\n                        if (this._emitted[\"t:\" + transactionHash] == null) {\n                            return null;\n                        }\n                        return undefined;\n                    }\n                    // \"geth-etc\" returns receipts before they are ready\n                    if (result.blockHash == null) {\n                        return undefined;\n                    }\n                    const receipt = this.formatter.receipt(result);\n                    if (receipt.blockNumber == null) {\n                        receipt.confirmations = 0;\n                    } else if (receipt.confirmations == null) {\n                        const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = blockNumber - receipt.blockNumber + 1;\n                        if (confirmations <= 0) {\n                            confirmations = 1;\n                        }\n                        receipt.confirmations = confirmations;\n                    }\n                    return receipt;\n                }), {\n                oncePoll: this\n            });\n        });\n    }\n    getLogs(filter) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({\n                filter: this._getFilter(filter)\n            });\n            const logs = yield this.perform(\"getLogs\", params);\n            logs.forEach((log)=>{\n                if (log.removed == null) {\n                    log.removed = false;\n                }\n            });\n            return _formatter__WEBPACK_IMPORTED_MODULE_14__.Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n        });\n    }\n    getEtherPrice() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.getNetwork();\n            return this.perform(\"getEtherPrice\", {});\n        });\n    }\n    _getBlockTag(blockTag) {\n        return __awaiter(this, void 0, void 0, function*() {\n            blockTag = yield blockTag;\n            if (typeof blockTag === \"number\" && blockTag < 0) {\n                if (blockTag % 1) {\n                    logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n                }\n                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                blockNumber += blockTag;\n                if (blockNumber < 0) {\n                    blockNumber = 0;\n                }\n                return this.formatter.blockTag(blockNumber);\n            }\n            return this.formatter.blockTag(blockTag);\n        });\n    }\n    getResolver(name) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let currentName = name;\n            while(true){\n                if (currentName === \"\" || currentName === \".\") {\n                    return null;\n                }\n                // Optimization since the eth node cannot change and does\n                // not have a wildcard resolver\n                if (name !== \"eth\" && currentName === \"eth\") {\n                    return null;\n                }\n                // Check the current node for a resolver\n                const addr = yield this._getResolver(currentName, \"getResolver\");\n                // Found a resolver!\n                if (addr != null) {\n                    const resolver = new Resolver(this, addr, name);\n                    // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                    if (currentName !== name && !(yield resolver.supportsWildcard())) {\n                        return null;\n                    }\n                    return resolver;\n                }\n                // Get the parent node\n                currentName = currentName.split(\".\").slice(1).join(\".\");\n            }\n        });\n    }\n    _getResolver(name, operation) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (operation == null) {\n                operation = \"ENS\";\n            }\n            const network = yield this.getNetwork();\n            // No ENS...\n            if (!network.ensAddress) {\n                logger.throwError(\"network does not support ENS\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation,\n                    network: network.name\n                });\n            }\n            try {\n                // keccak256(\"resolver(bytes32)\")\n                const addrData = yield this.call({\n                    to: network.ensAddress,\n                    data: \"0x0178b8bf\" + (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(name).substring(2)\n                });\n                return this.formatter.callAddress(addrData);\n            } catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32)\n            }\n            return null;\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function*() {\n            name = yield name;\n            // If it is already an address, nothing to resolve\n            try {\n                return Promise.resolve(this.formatter.address(name));\n            } catch (error) {\n                // If is is a hexstring, the address is bad (See #694)\n                if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(name)) {\n                    throw error;\n                }\n            }\n            if (typeof name !== \"string\") {\n                logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n            }\n            // Get the addr from the resolver\n            const resolver = yield this.getResolver(name);\n            if (!resolver) {\n                return null;\n            }\n            return yield resolver.getAddress();\n        });\n    }\n    lookupAddress(address) {\n        return __awaiter(this, void 0, void 0, function*() {\n            address = yield address;\n            address = this.formatter.address(address);\n            const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n            const resolverAddr = yield this._getResolver(node, \"lookupAddress\");\n            if (resolverAddr == null) {\n                return null;\n            }\n            // keccak(\"name(bytes32)\")\n            const name = _parseString((yield this.call({\n                to: resolverAddr,\n                data: \"0x691f3431\" + (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(node).substring(2)\n            })), 0);\n            const addr = yield this.resolveName(name);\n            if (addr != address) {\n                return null;\n            }\n            return name;\n        });\n    }\n    getAvatar(nameOrAddress) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let resolver = null;\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(nameOrAddress)) {\n                // Address; reverse lookup\n                const address = this.formatter.address(nameOrAddress);\n                const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n                const resolverAddress = yield this._getResolver(node, \"getAvatar\");\n                if (!resolverAddress) {\n                    return null;\n                }\n                // Try resolving the avatar against the addr.reverse resolver\n                resolver = new Resolver(this, resolverAddress, node);\n                try {\n                    const avatar = yield resolver.getAvatar();\n                    if (avatar) {\n                        return avatar.url;\n                    }\n                } catch (error) {\n                    if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                }\n                // Try getting the name and performing forward lookup; allowing wildcards\n                try {\n                    // keccak(\"name(bytes32)\")\n                    const name = _parseString((yield this.call({\n                        to: resolverAddress,\n                        data: \"0x691f3431\" + (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(node).substring(2)\n                    })), 0);\n                    resolver = yield this.getResolver(name);\n                } catch (error) {\n                    if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                    return null;\n                }\n            } else {\n                // ENS name; forward lookup with wildcard\n                resolver = yield this.getResolver(nameOrAddress);\n                if (!resolver) {\n                    return null;\n                }\n            }\n            const avatar = yield resolver.getAvatar();\n            if (avatar == null) {\n                return null;\n            }\n            return avatar.url;\n        });\n    }\n    perform(method, params) {\n        return logger.throwError(method + \" not implemented\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NOT_IMPLEMENTED, {\n            operation: method\n        });\n    }\n    _startEvent(event) {\n        this.polling = this._events.filter((e)=>e.pollable()).length > 0;\n    }\n    _stopEvent(event) {\n        this.polling = this._events.filter((e)=>e.pollable()).length > 0;\n    }\n    _addEventListener(eventName, listener, once) {\n        const event = new Event(getEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n    }\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    emit(eventName, ...args) {\n        let result = false;\n        let stopped = [];\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event)=>{\n            if (event.tag !== eventTag) {\n                return true;\n            }\n            setTimeout(()=>{\n                event.listener.apply(this, args);\n            }, 0);\n            result = true;\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n            return true;\n        });\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event)=>{\n            return event.tag === eventTag;\n        }).length;\n    }\n    listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event)=>event.listener);\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event)=>event.tag === eventTag).map((event)=>event.listener);\n    }\n    off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event)=>{\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return this;\n    }\n    removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        } else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event)=>{\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return this;\n    }\n} //# sourceMappingURL=base-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vYmFzZS1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ2IsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQ3VFO0FBQ1I7QUFDakI7QUFDTztBQUN1RjtBQUN4RjtBQUNNO0FBQ0w7QUFDb0M7QUFDNUM7QUFDc0I7QUFDZDtBQUN6QjtBQUNtQjtBQUNWO0FBQ3JDLE1BQU1xQyxTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDTztBQUN4QyxNQUFNRyxxQkFBcUI7QUFDM0IsOEJBQThCO0FBQzlCLHFCQUFxQjtBQUNyQixTQUFTQyxXQUFXQyxLQUFLO0lBQ3JCLElBQUlBLFNBQVMsTUFBTTtRQUNmLE9BQU87SUFDWDtJQUNBLElBQUl6QixtRUFBYUEsQ0FBQ3lCLFdBQVcsSUFBSTtRQUM3QkosT0FBT0ssa0JBQWtCLENBQUMsaUJBQWlCLFNBQVNEO0lBQ3hEO0lBQ0EsT0FBT0EsTUFBTUUsV0FBVztBQUM1QjtBQUNBLFNBQVNDLGdCQUFnQkMsTUFBTTtJQUMzQixzREFBc0Q7SUFDdERBLFNBQVNBLE9BQU9DLEtBQUs7SUFDckIsTUFBT0QsT0FBT0UsTUFBTSxHQUFHLEtBQUtGLE1BQU0sQ0FBQ0EsT0FBT0UsTUFBTSxHQUFHLEVBQUUsSUFBSSxLQUFNO1FBQzNERixPQUFPRyxHQUFHO0lBQ2Q7SUFDQSxPQUFPSCxPQUFPSSxHQUFHLENBQUMsQ0FBQ1I7UUFDZixJQUFJUyxNQUFNQyxPQUFPLENBQUNWLFFBQVE7WUFDdEIsOEJBQThCO1lBQzlCLE1BQU1XLFNBQVMsQ0FBQztZQUNoQlgsTUFBTVksT0FBTyxDQUFDLENBQUNaO2dCQUNYVyxNQUFNLENBQUNaLFdBQVdDLE9BQU8sR0FBRztZQUNoQztZQUNBLHlDQUF5QztZQUN6QyxNQUFNYSxTQUFTQyxPQUFPQyxJQUFJLENBQUNKO1lBQzNCRSxPQUFPRyxJQUFJO1lBQ1gsT0FBT0gsT0FBT0ksSUFBSSxDQUFDO1FBQ3ZCLE9BQ0s7WUFDRCxPQUFPbEIsV0FBV0M7UUFDdEI7SUFDSixHQUFHaUIsSUFBSSxDQUFDO0FBQ1o7QUFDQSxTQUFTQyxrQkFBa0JDLElBQUk7SUFDM0IsSUFBSUEsU0FBUyxJQUFJO1FBQ2IsT0FBTyxFQUFFO0lBQ2I7SUFDQSxPQUFPQSxLQUFLQyxLQUFLLENBQUMsTUFBTVosR0FBRyxDQUFDLENBQUNSO1FBQ3pCLElBQUlBLFVBQVUsSUFBSTtZQUNkLE9BQU8sRUFBRTtRQUNiO1FBQ0EsTUFBTXFCLFFBQVFyQixNQUFNb0IsS0FBSyxDQUFDLEtBQUtaLEdBQUcsQ0FBQyxDQUFDUjtZQUNoQyxPQUFRLFVBQVcsU0FBVSxPQUFPQTtRQUN4QztRQUNBLE9BQVEsTUFBT00sTUFBTSxLQUFLLElBQUtlLEtBQUssQ0FBQyxFQUFFLEdBQUdBO0lBQzlDO0FBQ0o7QUFDQSxTQUFTQyxZQUFZQyxTQUFTO0lBQzFCLElBQUksT0FBUUEsY0FBZSxVQUFVO1FBQ2pDQSxZQUFZQSxVQUFVckIsV0FBVztRQUNqQyxJQUFJM0IsbUVBQWFBLENBQUNnRCxlQUFlLElBQUk7WUFDakMsT0FBTyxRQUFRQTtRQUNuQjtRQUNBLElBQUlBLFVBQVVDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRztZQUMvQixPQUFPRDtRQUNYO0lBQ0osT0FDSyxJQUFJZCxNQUFNQyxPQUFPLENBQUNhLFlBQVk7UUFDL0IsT0FBTyxjQUFjcEIsZ0JBQWdCb0I7SUFDekMsT0FDSyxJQUFJekQsdUVBQVNBLENBQUMyRCxXQUFXLENBQUNGLFlBQVk7UUFDdkMzQixPQUFPOEIsSUFBSSxDQUFDO1FBQ1osTUFBTSxJQUFJQyxNQUFNO0lBQ3BCLE9BQ0ssSUFBSUosYUFBYSxPQUFRQSxjQUFlLFVBQVU7UUFDbkQsT0FBTyxZQUFhQSxDQUFBQSxVQUFVSyxPQUFPLElBQUksR0FBRSxJQUFLLE1BQU16QixnQkFBZ0JvQixVQUFVbkIsTUFBTSxJQUFJLEVBQUU7SUFDaEc7SUFDQSxNQUFNLElBQUl1QixNQUFNLHFCQUFxQko7QUFDekM7QUFDQSw4QkFBOEI7QUFDOUIsZ0JBQWdCO0FBQ2hCLFNBQVNNO0lBQ0wsT0FBTyxJQUFLQyxPQUFRRCxPQUFPO0FBQy9CO0FBQ0EsU0FBU0UsTUFBTUMsUUFBUTtJQUNuQixPQUFPLElBQUk3RSxRQUFRLENBQUNEO1FBQ2hCK0UsV0FBVy9FLFNBQVM4RTtJQUN4QjtBQUNKO0FBQ0EsOEJBQThCO0FBQzlCLGtCQUFrQjtBQUNsQjs7Ozs7Ozs7Ozs7Q0FXQyxHQUNELE1BQU1FLGlCQUFpQjtJQUFDO0lBQVM7SUFBVztJQUFXO0NBQU87QUFDdkQsTUFBTUM7SUFDVEMsWUFBWUMsR0FBRyxFQUFFQyxRQUFRLEVBQUVDLElBQUksQ0FBRTtRQUM3QnRELHlFQUFjQSxDQUFDLElBQUksRUFBRSxPQUFPb0Q7UUFDNUJwRCx5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsWUFBWXFEO1FBQ2pDckQseUVBQWNBLENBQUMsSUFBSSxFQUFFLFFBQVFzRDtRQUM3QixJQUFJLENBQUNDLGdCQUFnQixHQUFHLENBQUM7UUFDekIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7SUFDckI7SUFDQSxJQUFJQyxRQUFRO1FBQ1IsT0FBUSxJQUFJLENBQUNDLElBQUk7WUFDYixLQUFLO2dCQUNELE9BQU8sSUFBSSxDQUFDQyxJQUFJO1lBQ3BCLEtBQUs7Z0JBQ0QsT0FBTyxJQUFJLENBQUNDLE1BQU07UUFDMUI7UUFDQSxPQUFPLElBQUksQ0FBQ1IsR0FBRztJQUNuQjtJQUNBLElBQUlNLE9BQU87UUFDUCxPQUFPLElBQUksQ0FBQ04sR0FBRyxDQUFDakIsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0lBQ2pDO0lBQ0EsSUFBSXdCLE9BQU87UUFDUCxNQUFNdkIsUUFBUSxJQUFJLENBQUNnQixHQUFHLENBQUNqQixLQUFLLENBQUM7UUFDN0IsSUFBSUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxNQUFNO1lBQ25CLE9BQU87UUFDWDtRQUNBLE9BQU9BLEtBQUssQ0FBQyxFQUFFO0lBQ25CO0lBQ0EsSUFBSXdCLFNBQVM7UUFDVCxNQUFNeEIsUUFBUSxJQUFJLENBQUNnQixHQUFHLENBQUNqQixLQUFLLENBQUM7UUFDN0IsSUFBSUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxVQUFVO1lBQ3ZCLE9BQU87UUFDWDtRQUNBLE1BQU1PLFVBQVVQLEtBQUssQ0FBQyxFQUFFO1FBQ3hCLE1BQU1qQixTQUFTYyxrQkFBa0JHLEtBQUssQ0FBQyxFQUFFO1FBQ3pDLE1BQU13QixTQUFTLENBQUM7UUFDaEIsSUFBSXpDLE9BQU9FLE1BQU0sR0FBRyxHQUFHO1lBQ25CdUMsT0FBT3pDLE1BQU0sR0FBR0E7UUFDcEI7UUFDQSxJQUFJd0IsV0FBV0EsWUFBWSxLQUFLO1lBQzVCaUIsT0FBT2pCLE9BQU8sR0FBR0E7UUFDckI7UUFDQSxPQUFPaUI7SUFDWDtJQUNBQyxXQUFXO1FBQ1AsT0FBUSxJQUFJLENBQUNULEdBQUcsQ0FBQ2IsT0FBTyxDQUFDLFFBQVEsS0FBS1UsZUFBZVYsT0FBTyxDQUFDLElBQUksQ0FBQ2EsR0FBRyxLQUFLO0lBQzlFO0FBQ0o7O0FBRUEsZ0VBQWdFO0FBQ2hFLE1BQU1VLFlBQVk7SUFDZCxLQUFLO1FBQUVDLFFBQVE7UUFBT0MsT0FBTztRQUFNQyxNQUFNO1FBQU1DLFFBQVE7SUFBSztJQUM1RCxLQUFLO1FBQUVILFFBQVE7UUFBT0MsT0FBTztRQUFNQyxNQUFNO1FBQU1DLFFBQVE7SUFBTTtJQUM3RCxLQUFLO1FBQUVILFFBQVE7UUFBUUMsT0FBTztRQUFNQyxNQUFNO0lBQUs7SUFDL0MsTUFBTTtRQUFFRixRQUFRO1FBQU9JLEtBQUs7SUFBTTtJQUNsQyxNQUFNO1FBQUVKLFFBQVE7UUFBT0ksS0FBSztJQUFNO0lBQ2xDLE9BQU87UUFBRUosUUFBUTtRQUFRSSxLQUFLO0lBQU07QUFDeEM7QUFDQSxTQUFTQyxXQUFXcEcsS0FBSztJQUNyQixPQUFPMEIsZ0VBQVVBLENBQUNSLCtEQUFTQSxDQUFDbUYsSUFBSSxDQUFDckcsT0FBT3NHLFdBQVcsSUFBSTtBQUMzRDtBQUNBLDhFQUE4RTtBQUM5RSxTQUFTQyxhQUFhckMsSUFBSTtJQUN0QixPQUFPakQsd0RBQU1BLENBQUNGLE1BQU0sQ0FBQ0ssNERBQU1BLENBQUM7UUFBQzhDO1FBQU0zQyxrRUFBWUEsQ0FBQ1ksMkRBQU1BLENBQUNBLDJEQUFNQSxDQUFDK0IsUUFBUSxHQUFHO0tBQUc7QUFDaEY7QUFDQSxNQUFNc0MsY0FBYyxJQUFJQyxPQUFPLG1CQUFvQjtBQUNuRCxNQUFNQyxXQUFXO0lBQ2IsSUFBSUQsT0FBTyxvQkFBcUI7SUFDaEMsSUFBSUEsT0FBTyxpQkFBaUI7SUFDNUJEO0lBQ0EsSUFBSUMsT0FBTyxvQ0FBb0M7Q0FDbEQ7QUFDRCxTQUFTRSxhQUFhbEcsTUFBTSxFQUFFbUcsS0FBSztJQUMvQixJQUFJO1FBQ0EsT0FBT3ZFLG9FQUFZQSxDQUFDd0UsWUFBWXBHLFFBQVFtRztJQUM1QyxFQUNBLE9BQU9FLE9BQU8sQ0FBRTtJQUNoQixPQUFPO0FBQ1g7QUFDQSxTQUFTRCxZQUFZcEcsTUFBTSxFQUFFbUcsS0FBSztJQUM5QixJQUFJbkcsV0FBVyxNQUFNO1FBQ2pCLE9BQU87SUFDWDtJQUNBLE1BQU1zRyxTQUFTN0YsK0RBQVNBLENBQUNtRixJQUFJLENBQUM5RSxrRUFBWUEsQ0FBQ2QsUUFBUW1HLE9BQU9BLFFBQVEsS0FBS0ksUUFBUTtJQUMvRSxNQUFNM0QsU0FBU25DLCtEQUFTQSxDQUFDbUYsSUFBSSxDQUFDOUUsa0VBQVlBLENBQUNkLFFBQVFzRyxRQUFRQSxTQUFTLEtBQUtDLFFBQVE7SUFDakYsT0FBT3pGLGtFQUFZQSxDQUFDZCxRQUFRc0csU0FBUyxJQUFJQSxTQUFTLEtBQUsxRDtBQUMzRDtBQUNBLGlFQUFpRTtBQUNqRSxTQUFTNEQsWUFBWUMsSUFBSTtJQUNyQixJQUFJQSxLQUFLQyxLQUFLLENBQUMsc0JBQXNCO1FBQ2pDRCxPQUFPQSxLQUFLRSxTQUFTLENBQUM7SUFDMUIsT0FDSyxJQUFJRixLQUFLQyxLQUFLLENBQUMsZ0JBQWdCO1FBQ2hDRCxPQUFPQSxLQUFLRSxTQUFTLENBQUM7SUFDMUIsT0FDSztRQUNEekUsT0FBT0ssa0JBQWtCLENBQUMsMkJBQTJCLFFBQVFrRTtJQUNqRTtJQUNBLE9BQU8sQ0FBQyw4QkFBOEIsRUFBRUEsS0FBSyxDQUFDO0FBQ2xEO0FBQ0EsU0FBU0csT0FBT3JILEtBQUs7SUFDakIsTUFBTVMsU0FBU1UsOERBQVFBLENBQUNuQjtJQUN4QixJQUFJUyxPQUFPNEMsTUFBTSxHQUFHLElBQUk7UUFDcEIsTUFBTSxJQUFJcUIsTUFBTTtJQUNwQjtJQUNBLE1BQU00QyxTQUFTLElBQUlDLFdBQVc7SUFDOUJELE9BQU9FLEdBQUcsQ0FBQy9HLFFBQVEsS0FBS0EsT0FBTzRDLE1BQU07SUFDckMsT0FBT2lFO0FBQ1g7QUFDQSxTQUFTRyxTQUFTekgsS0FBSztJQUNuQixJQUFJLE1BQU9xRCxNQUFNLEdBQUcsT0FBUSxHQUFHO1FBQzNCLE9BQU9yRDtJQUNYO0lBQ0EsTUFBTVMsU0FBUyxJQUFJOEcsV0FBV0csS0FBS0MsSUFBSSxDQUFDM0gsTUFBTXFELE1BQU0sR0FBRyxNQUFNO0lBQzdENUMsT0FBTytHLEdBQUcsQ0FBQ3hIO0lBQ1gsT0FBT1M7QUFDWDtBQUNBLDhDQUE4QztBQUM5QyxTQUFTbUgsWUFBWUMsS0FBSztJQUN0QixNQUFNcEgsU0FBUyxFQUFFO0lBQ2pCLElBQUlxSCxZQUFZO0lBQ2hCLGlEQUFpRDtJQUNqRCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsTUFBTXhFLE1BQU0sRUFBRTBFLElBQUs7UUFDbkN0SCxPQUFPdUgsSUFBSSxDQUFDO1FBQ1pGLGFBQWE7SUFDakI7SUFDQSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsTUFBTXhFLE1BQU0sRUFBRTBFLElBQUs7UUFDbkMsTUFBTTdELE9BQU8vQyw4REFBUUEsQ0FBQzBHLEtBQUssQ0FBQ0UsRUFBRTtRQUM5QiwwQkFBMEI7UUFDMUJ0SCxNQUFNLENBQUNzSCxFQUFFLEdBQUdWLE9BQU9TO1FBQ25CLHNDQUFzQztRQUN0Q3JILE9BQU91SCxJQUFJLENBQUNYLE9BQU9uRCxLQUFLYixNQUFNO1FBQzlCNUMsT0FBT3VILElBQUksQ0FBQ1AsU0FBU3ZEO1FBQ3JCNEQsYUFBYSxLQUFLSixLQUFLQyxJQUFJLENBQUN6RCxLQUFLYixNQUFNLEdBQUcsTUFBTTtJQUNwRDtJQUNBLE9BQU9oQywrREFBU0EsQ0FBQ1o7QUFDckI7QUFDTyxNQUFNd0g7SUFDVCxvRUFBb0U7SUFDcEU5QyxZQUFZK0MsUUFBUSxFQUFFdkQsT0FBTyxFQUFFd0QsSUFBSSxFQUFFQyxlQUFlLENBQUU7UUFDbERwRyx5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsWUFBWWtHO1FBQ2pDbEcseUVBQWNBLENBQUMsSUFBSSxFQUFFLFFBQVFtRztRQUM3Qm5HLHlFQUFjQSxDQUFDLElBQUksRUFBRSxXQUFXa0csU0FBU0csU0FBUyxDQUFDMUQsT0FBTyxDQUFDQTtRQUMzRDNDLHlFQUFjQSxDQUFDLElBQUksRUFBRSxvQkFBb0JvRztJQUM3QztJQUNBRSxtQkFBbUI7UUFDZixJQUFJLENBQUMsSUFBSSxDQUFDQyxnQkFBZ0IsRUFBRTtZQUN4QiwrREFBK0Q7WUFDL0QsSUFBSSxDQUFDQSxnQkFBZ0IsR0FBRyxJQUFJLENBQUNMLFFBQVEsQ0FBQ00sSUFBSSxDQUFDO2dCQUN2Q0MsSUFBSSxJQUFJLENBQUM5RCxPQUFPO2dCQUNoQlQsTUFBTTtZQUNWLEdBQUd2RCxJQUFJLENBQUMsQ0FBQ0Y7Z0JBQ0wsT0FBT1MsK0RBQVNBLENBQUNtRixJQUFJLENBQUM1RixRQUFRaUksRUFBRSxDQUFDO1lBQ3JDLEdBQUdDLEtBQUssQ0FBQyxDQUFDN0I7Z0JBQ04sSUFBSUEsTUFBTThCLElBQUksS0FBS25HLHlEQUFNQSxDQUFDb0csTUFBTSxDQUFDQyxjQUFjLEVBQUU7b0JBQzdDLE9BQU87Z0JBQ1g7Z0JBQ0EsbUVBQW1FO2dCQUNuRSxJQUFJLENBQUNQLGdCQUFnQixHQUFHO2dCQUN4QixNQUFNekI7WUFDVjtRQUNKO1FBQ0EsT0FBTyxJQUFJLENBQUN5QixnQkFBZ0I7SUFDaEM7SUFDQVEsT0FBT0MsUUFBUSxFQUFFQyxVQUFVLEVBQUU7UUFDekIsT0FBT3ZKLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsMENBQTBDO1lBQzFDLE1BQU13SixLQUFLO2dCQUNQVCxJQUFJLElBQUksQ0FBQzlELE9BQU87Z0JBQ2hCd0UsaUJBQWlCO2dCQUNqQmpGLE1BQU03QywrREFBU0EsQ0FBQztvQkFBQzJIO29CQUFVbEgsOERBQVFBLENBQUMsSUFBSSxDQUFDcUcsSUFBSTtvQkFBSWMsY0FBYztpQkFBTTtZQUN6RTtZQUNBLHdEQUF3RDtZQUN4RCxJQUFJRyxhQUFhO1lBQ2pCLElBQUksTUFBTSxJQUFJLENBQUNkLGdCQUFnQixJQUFJO2dCQUMvQmMsYUFBYTtnQkFDYixtQ0FBbUM7Z0JBQ25DRixHQUFHaEYsSUFBSSxHQUFHN0MsK0RBQVNBLENBQUM7b0JBQUM7b0JBQWN1RyxZQUFZO3dCQUFDL0YsK0RBQVNBLENBQUMsSUFBSSxDQUFDc0csSUFBSTt3QkFBR2UsR0FBR2hGLElBQUk7cUJBQUM7aUJBQUU7WUFDcEY7WUFDQSxJQUFJO2dCQUNBLElBQUl6RCxTQUFTLE1BQU0sSUFBSSxDQUFDeUgsUUFBUSxDQUFDTSxJQUFJLENBQUNVO2dCQUN0QyxJQUFJLCtEQUFVekksUUFBUTRDLE1BQU0sR0FBRyxPQUFRLEdBQUc7b0JBQ3RDVixPQUFPMEcsVUFBVSxDQUFDLHdCQUF3QjVHLHlEQUFNQSxDQUFDb0csTUFBTSxDQUFDQyxjQUFjLEVBQUU7d0JBQ3BFUSxhQUFhSjt3QkFBSWhGLE1BQU16RDtvQkFDM0I7Z0JBQ0o7Z0JBQ0EsSUFBSTJJLFlBQVk7b0JBQ1ozSSxTQUFTb0csWUFBWXBHLFFBQVE7Z0JBQ2pDO2dCQUNBLE9BQU9BO1lBQ1gsRUFDQSxPQUFPcUcsT0FBTztnQkFDVixJQUFJQSxNQUFNOEIsSUFBSSxLQUFLbkcseURBQU1BLENBQUNvRyxNQUFNLENBQUNDLGNBQWMsRUFBRTtvQkFDN0MsT0FBTztnQkFDWDtnQkFDQSxNQUFNaEM7WUFDVjtRQUNKO0lBQ0o7SUFDQXlDLFlBQVlQLFFBQVEsRUFBRUMsVUFBVSxFQUFFO1FBQzlCLE9BQU92SixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLE1BQU1lLFNBQVMsTUFBTSxJQUFJLENBQUNzSSxNQUFNLENBQUNDLFVBQVVDO1lBQzNDLElBQUl4SSxVQUFVLE1BQU07Z0JBQ2hCLE9BQU9vRyxZQUFZcEcsUUFBUTtZQUMvQjtZQUNBLE9BQU87UUFDWDtJQUNKO0lBQ0ErSSxZQUFZQyxRQUFRLEVBQUVDLFFBQVEsRUFBRTtRQUM1QixNQUFNQyxXQUFXN0QsU0FBUyxDQUFDOEQsT0FBT0gsVUFBVTtRQUM1QyxJQUFJRSxZQUFZLE1BQU07WUFDbEJoSCxPQUFPMEcsVUFBVSxDQUFDLENBQUMsdUJBQXVCLEVBQUVJLFNBQVMsQ0FBQyxFQUFFaEgseURBQU1BLENBQUNvRyxNQUFNLENBQUNnQixxQkFBcUIsRUFBRTtnQkFDekZDLFdBQVcsQ0FBQyxXQUFXLEVBQUVMLFNBQVMsQ0FBQyxDQUFDO1lBQ3hDO1FBQ0o7UUFDQSxJQUFJRSxTQUFTeEQsR0FBRyxLQUFLLE9BQU87WUFDeEIsT0FBTyxJQUFJLENBQUMrQixRQUFRLENBQUNHLFNBQVMsQ0FBQzFELE9BQU8sQ0FBQytFO1FBQzNDO1FBQ0EsTUFBTUssUUFBUTVJLDhEQUFRQSxDQUFDdUk7UUFDdkIsbUVBQW1FO1FBQ25FLElBQUlDLFNBQVMzRCxLQUFLLElBQUksTUFBTTtZQUN4QixNQUFNQSxRQUFRMEQsU0FBU3ZDLEtBQUssQ0FBQztZQUM3QixJQUFJbkIsT0FBTztnQkFDUCxNQUFNM0MsU0FBUzJHLFNBQVNoRSxLQUFLLENBQUMsRUFBRSxFQUFFO2dCQUNsQyxJQUFJQSxLQUFLLENBQUMsRUFBRSxDQUFDM0MsTUFBTSxLQUFLQSxTQUFTLEtBQUtBLFVBQVUsS0FBS0EsVUFBVSxJQUFJO29CQUMvRCxPQUFPa0QsYUFBYW5GLDREQUFNQSxDQUFDO3dCQUFDOzRCQUFDdUksU0FBUzNELEtBQUs7eUJBQUM7d0JBQUcsT0FBT0EsS0FBSyxDQUFDLEVBQUU7cUJBQUU7Z0JBQ3BFO1lBQ0o7UUFDSjtRQUNBLHlDQUF5QztRQUN6QyxJQUFJMkQsU0FBUzFELElBQUksSUFBSSxNQUFNO1lBQ3ZCLE1BQU1BLE9BQU95RCxTQUFTdkMsS0FBSyxDQUFDO1lBQzVCLElBQUlsQixNQUFNO2dCQUNOLE1BQU01QyxTQUFTMkcsU0FBUy9ELElBQUksQ0FBQyxFQUFFLEVBQUU7Z0JBQ2pDLElBQUlBLElBQUksQ0FBQyxFQUFFLENBQUM1QyxNQUFNLEtBQUtBLFNBQVMsS0FBS0EsVUFBVSxLQUFLQSxVQUFVLElBQUk7b0JBQzlELE9BQU9rRCxhQUFhbkYsNERBQU1BLENBQUM7d0JBQUM7NEJBQUN1SSxTQUFTMUQsSUFBSTt5QkFBQzt3QkFBRyxPQUFPQSxJQUFJLENBQUMsRUFBRTtxQkFBRTtnQkFDbEU7WUFDSjtRQUNKO1FBQ0EsU0FBUztRQUNULElBQUkwRCxTQUFTekQsTUFBTSxJQUFJLE1BQU07WUFDekIsTUFBTTdDLFNBQVMwRyxLQUFLLENBQUMsRUFBRTtZQUN2QixpRkFBaUY7WUFDakYsSUFBSXJILFVBQVVxSCxLQUFLLENBQUMsRUFBRTtZQUN0QixJQUFJckgsWUFBWSxNQUFNO2dCQUNsQixJQUFJVyxXQUFXLE1BQU1BLFdBQVcsSUFBSTtvQkFDaENYLFVBQVUsQ0FBQztnQkFDZjtZQUNKLE9BQ0s7Z0JBQ0RBLFVBQVUsQ0FBQztZQUNmO1lBQ0EsSUFBSUEsV0FBVyxLQUFLcUgsTUFBTTFHLE1BQU0sS0FBSyxJQUFJQSxVQUFVQSxVQUFVLEtBQUtBLFVBQVUsSUFBSTtnQkFDNUUsTUFBTTRHLFFBQVF6SCxxREFBYyxDQUFDdUgsTUFBTTNHLEtBQUssQ0FBQztnQkFDekM2RyxNQUFNRSxPQUFPLENBQUN6SDtnQkFDZCxPQUFPRixvREFBYSxDQUFDbUgsU0FBU3pELE1BQU0sRUFBRStEO1lBQzFDO1FBQ0o7UUFDQSxPQUFPO0lBQ1g7SUFDQUcsV0FBV1gsUUFBUSxFQUFFO1FBQ2pCLE9BQU8vSixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUkrSixZQUFZLE1BQU07Z0JBQ2xCQSxXQUFXO1lBQ2Y7WUFDQSxnREFBZ0Q7WUFDaEQsSUFBSUEsYUFBYSxJQUFJO2dCQUNqQixJQUFJO29CQUNBLDZCQUE2QjtvQkFDN0IsTUFBTWhKLFNBQVMsTUFBTSxJQUFJLENBQUNzSSxNQUFNLENBQUM7b0JBQ2pDLGFBQWE7b0JBQ2IsSUFBSXRJLFdBQVcsUUFBUUEsV0FBV21CLCtEQUFRQSxFQUFFO3dCQUN4QyxPQUFPO29CQUNYO29CQUNBLE9BQU8sSUFBSSxDQUFDc0csUUFBUSxDQUFDRyxTQUFTLENBQUNnQyxXQUFXLENBQUM1SjtnQkFDL0MsRUFDQSxPQUFPcUcsT0FBTztvQkFDVixJQUFJQSxNQUFNOEIsSUFBSSxLQUFLbkcseURBQU1BLENBQUNvRyxNQUFNLENBQUNDLGNBQWMsRUFBRTt3QkFDN0MsT0FBTztvQkFDWDtvQkFDQSxNQUFNaEM7Z0JBQ1Y7WUFDSjtZQUNBLG9DQUFvQztZQUNwQyxNQUFNNEMsV0FBVyxNQUFNLElBQUksQ0FBQ0gsV0FBVyxDQUFDLGNBQWNuRCxXQUFXcUQ7WUFDakUsYUFBYTtZQUNiLElBQUlDLFlBQVksUUFBUUEsYUFBYSxNQUFNO2dCQUN2QyxPQUFPO1lBQ1g7WUFDQSxzQkFBc0I7WUFDdEIsTUFBTS9FLFVBQVUsSUFBSSxDQUFDNkUsV0FBVyxDQUFDQyxVQUFVQztZQUMzQyxJQUFJL0UsV0FBVyxNQUFNO2dCQUNqQmhDLE9BQU8wRyxVQUFVLENBQUMsQ0FBQyxnQ0FBZ0MsQ0FBQyxFQUFFNUcseURBQU1BLENBQUNvRyxNQUFNLENBQUNnQixxQkFBcUIsRUFBRTtvQkFDdkZDLFdBQVcsQ0FBQyxXQUFXLEVBQUVMLFNBQVMsQ0FBQyxDQUFDO29CQUNwQ0EsVUFBVUE7b0JBQ1Z2RixNQUFNd0Y7Z0JBQ1Y7WUFDSjtZQUNBLE9BQU8vRTtRQUNYO0lBQ0o7SUFDQTJGLFlBQVk7UUFDUixPQUFPNUssVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxNQUFNNkssVUFBVTtnQkFBQztvQkFBRTdFLE1BQU07b0JBQVE4RSxTQUFTLElBQUksQ0FBQ3JDLElBQUk7Z0JBQUM7YUFBRTtZQUN0RCxJQUFJO2dCQUNBLDJCQUEyQjtnQkFDM0Isb0ZBQW9GO2dCQUNwRixNQUFNc0MsU0FBUyxNQUFNLElBQUksQ0FBQ0MsT0FBTyxDQUFDO2dCQUNsQyxJQUFJRCxVQUFVLE1BQU07b0JBQ2hCLE9BQU87Z0JBQ1g7Z0JBQ0EsSUFBSyxJQUFJMUMsSUFBSSxHQUFHQSxJQUFJckIsU0FBU3JELE1BQU0sRUFBRTBFLElBQUs7b0JBQ3RDLE1BQU1aLFFBQVFzRCxPQUFPdEQsS0FBSyxDQUFDVCxRQUFRLENBQUNxQixFQUFFO29CQUN0QyxJQUFJWixTQUFTLE1BQU07d0JBQ2Y7b0JBQ0o7b0JBQ0EsTUFBTXdELFNBQVN4RCxLQUFLLENBQUMsRUFBRSxDQUFDbEUsV0FBVztvQkFDbkMsT0FBUTBIO3dCQUNKLEtBQUs7NEJBQ0RKLFFBQVF2QyxJQUFJLENBQUM7Z0NBQUV0QyxNQUFNO2dDQUFPOEUsU0FBU0M7NEJBQU87NEJBQzVDLE9BQU87Z0NBQUVGO2dDQUFTSyxLQUFLSDs0QkFBTzt3QkFDbEMsS0FBSzs0QkFDREYsUUFBUXZDLElBQUksQ0FBQztnQ0FBRXRDLE1BQU07Z0NBQVE4RSxTQUFTQzs0QkFBTzs0QkFDN0MsT0FBTztnQ0FBRUY7Z0NBQVNLLEtBQUtIOzRCQUFPO3dCQUNsQyxLQUFLOzRCQUNERixRQUFRdkMsSUFBSSxDQUFDO2dDQUFFdEMsTUFBTTtnQ0FBUThFLFNBQVNDOzRCQUFPOzRCQUM3QyxPQUFPO2dDQUFFRjtnQ0FBU0ssS0FBSzNELFlBQVl3RDs0QkFBUTt3QkFDL0MsS0FBSzt3QkFDTCxLQUFLOzRCQUFXO2dDQUNaLG1FQUFtRTtnQ0FDbkUsTUFBTXpCLFdBQVcsV0FBWSxXQUFZLGVBQWU7Z0NBQ3hEdUIsUUFBUXZDLElBQUksQ0FBQztvQ0FBRXRDLE1BQU1pRjtvQ0FBUUgsU0FBU0M7Z0NBQU87Z0NBQzdDLHlCQUF5QjtnQ0FDekIsTUFBTUksUUFBUyxJQUFJLENBQUNDLGdCQUFnQixJQUFLLE9BQU0sSUFBSSxDQUFDVixVQUFVLEVBQUM7Z0NBQy9ELE1BQU1oRyxRQUFRLENBQUMrQyxLQUFLLENBQUMsRUFBRSxJQUFJLEVBQUMsRUFBR2hELEtBQUssQ0FBQztnQ0FDckMsSUFBSUMsTUFBTWYsTUFBTSxLQUFLLEdBQUc7b0NBQ3BCLE9BQU87Z0NBQ1g7Z0NBQ0EsTUFBTTBILE9BQU8sTUFBTSxJQUFJLENBQUM3QyxRQUFRLENBQUNHLFNBQVMsQ0FBQzFELE9BQU8sQ0FBQ1AsS0FBSyxDQUFDLEVBQUU7Z0NBQzNELE1BQU00RyxVQUFVdEosZ0VBQVVBLENBQUNSLCtEQUFTQSxDQUFDbUYsSUFBSSxDQUFDakMsS0FBSyxDQUFDLEVBQUUsRUFBRWtDLFdBQVcsSUFBSTtnQ0FDbkUseUNBQXlDO2dDQUN6QyxJQUFJcUUsV0FBVyxVQUFVO29DQUNyQiwyQkFBMkI7b0NBQzNCLE1BQU1NLGFBQWEsSUFBSSxDQUFDL0MsUUFBUSxDQUFDRyxTQUFTLENBQUNnQyxXQUFXLENBQUMsT0FBTSxJQUFJLENBQUNuQyxRQUFRLENBQUNNLElBQUksQ0FBQzt3Q0FDNUVDLElBQUlzQzt3Q0FBTTdHLE1BQU03QywrREFBU0EsQ0FBQzs0Q0FBQzs0Q0FBYzJKO3lDQUFRO29DQUNyRCxFQUFDO29DQUNELElBQUlILFVBQVVJLFlBQVk7d0NBQ3RCLE9BQU87b0NBQ1g7b0NBQ0FWLFFBQVF2QyxJQUFJLENBQUM7d0NBQUV0QyxNQUFNO3dDQUFTOEUsU0FBU1M7b0NBQVc7Z0NBQ3RELE9BQ0ssSUFBSU4sV0FBVyxXQUFXO29DQUMzQiw0Q0FBNEM7b0NBQzVDLE1BQU1PLFVBQVVoSywrREFBU0EsQ0FBQ21GLElBQUksQ0FBQyxPQUFNLElBQUksQ0FBQzZCLFFBQVEsQ0FBQ00sSUFBSSxDQUFDO3dDQUNwREMsSUFBSXNDO3dDQUFNN0csTUFBTTdDLCtEQUFTQSxDQUFDOzRDQUFDOzRDQUFjSyxnRUFBVUEsQ0FBQ21KLE9BQU87NENBQUtHO3lDQUFRO29DQUM1RSxFQUFDO29DQUNELElBQUlFLFFBQVFDLE1BQU0sSUFBSTt3Q0FDbEIsT0FBTztvQ0FDWDtvQ0FDQVosUUFBUXZDLElBQUksQ0FBQzt3Q0FBRXRDLE1BQU07d0NBQVc4RSxTQUFTVSxRQUFRRSxRQUFRO29DQUFHO2dDQUNoRTtnQ0FDQSwrQ0FBK0M7Z0NBQy9DLE1BQU1sQyxLQUFLO29DQUNQVCxJQUFJLElBQUksQ0FBQ1AsUUFBUSxDQUFDRyxTQUFTLENBQUMxRCxPQUFPLENBQUNQLEtBQUssQ0FBQyxFQUFFO29DQUM1Q0YsTUFBTTdDLCtEQUFTQSxDQUFDO3dDQUFDMkg7d0NBQVVnQztxQ0FBUTtnQ0FDdkM7Z0NBQ0EsSUFBSUssY0FBYzFFLGFBQWEsT0FBTSxJQUFJLENBQUN1QixRQUFRLENBQUNNLElBQUksQ0FBQ1UsR0FBRSxHQUFHO2dDQUM3RCxJQUFJbUMsZUFBZSxNQUFNO29DQUNyQixPQUFPO2dDQUNYO2dDQUNBZCxRQUFRdkMsSUFBSSxDQUFDO29DQUFFdEMsTUFBTTtvQ0FBcUI4RSxTQUFTYTtnQ0FBWTtnQ0FDL0QsNENBQTRDO2dDQUM1QyxJQUFJVixXQUFXLFdBQVc7b0NBQ3RCVSxjQUFjQSxZQUFZQyxPQUFPLENBQUMsUUFBUU4sUUFBUTVELFNBQVMsQ0FBQztvQ0FDNURtRCxRQUFRdkMsSUFBSSxDQUFDO3dDQUFFdEMsTUFBTTt3Q0FBeUI4RSxTQUFTYTtvQ0FBWTtnQ0FDdkU7Z0NBQ0EsZ0NBQWdDO2dDQUNoQyxJQUFJQSxZQUFZbEUsS0FBSyxDQUFDLFlBQVk7b0NBQzlCa0UsY0FBY3BFLFlBQVlvRTtnQ0FDOUI7Z0NBQ0FkLFFBQVF2QyxJQUFJLENBQUM7b0NBQUV0QyxNQUFNO29DQUFnQjhFLFNBQVNhO2dDQUFZO2dDQUMxRCx5QkFBeUI7Z0NBQ3pCLE1BQU1FLFdBQVcsTUFBTWpKLDhEQUFTQSxDQUFDK0k7Z0NBQ2pDLElBQUksQ0FBQ0UsVUFBVTtvQ0FDWCxPQUFPO2dDQUNYO2dDQUNBaEIsUUFBUXZDLElBQUksQ0FBQztvQ0FBRXRDLE1BQU07b0NBQVk4RSxTQUFTZ0IsS0FBS0MsU0FBUyxDQUFDRjtnQ0FBVTtnQ0FDbkUseUJBQXlCO2dDQUN6QixJQUFJRyxXQUFXSCxTQUFTSSxLQUFLO2dDQUM3QixJQUFJLE9BQVFELGFBQWMsVUFBVTtvQ0FDaEMsT0FBTztnQ0FDWDtnQ0FDQSxJQUFJQSxTQUFTdkUsS0FBSyxDQUFDLHlCQUF5QjtnQ0FDeEMsUUFBUTtnQ0FDWixPQUNLO29DQUNELGlDQUFpQztvQ0FDakMsTUFBTXlFLE9BQU9GLFNBQVN2RSxLQUFLLENBQUNYO29DQUM1QixJQUFJb0YsUUFBUSxNQUFNO3dDQUNkLE9BQU87b0NBQ1g7b0NBQ0FyQixRQUFRdkMsSUFBSSxDQUFDO3dDQUFFdEMsTUFBTTt3Q0FBWThFLFNBQVNrQjtvQ0FBUztvQ0FDbkRBLFdBQVd6RSxZQUFZeUU7Z0NBQzNCO2dDQUNBbkIsUUFBUXZDLElBQUksQ0FBQztvQ0FBRXRDLE1BQU07b0NBQU84RSxTQUFTa0I7Z0NBQVM7Z0NBQzlDLE9BQU87b0NBQUVuQjtvQ0FBU0ssS0FBS2M7Z0NBQVM7NEJBQ3BDO29CQUNKO2dCQUNKO1lBQ0osRUFDQSxPQUFPNUUsT0FBTyxDQUFFO1lBQ2hCLE9BQU87UUFDWDtJQUNKO0lBQ0ErRSxpQkFBaUI7UUFDYixPQUFPbk0sVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyw2QkFBNkI7WUFDN0IsTUFBTWdLLFdBQVcsTUFBTSxJQUFJLENBQUNILFdBQVcsQ0FBQztZQUN4QyxpQkFBaUI7WUFDakIsSUFBSUcsWUFBWSxRQUFRQSxhQUFhLE1BQU07Z0JBQ3ZDLE9BQU87WUFDWDtZQUNBLDhCQUE4QjtZQUM5QixNQUFNa0MsT0FBT2xDLFNBQVN2QyxLQUFLLENBQUM7WUFDNUIsSUFBSXlFLE1BQU07Z0JBQ04sTUFBTXZJLFNBQVMyRyxTQUFTNEIsSUFBSSxDQUFDLEVBQUUsRUFBRTtnQkFDakMsSUFBSUEsSUFBSSxDQUFDLEVBQUUsQ0FBQ3ZJLE1BQU0sS0FBS0EsU0FBUyxHQUFHO29CQUMvQixPQUFPLFlBQWFwQyx3REFBTUEsQ0FBQ0YsTUFBTSxDQUFDLE9BQU82SyxJQUFJLENBQUMsRUFBRTtnQkFDcEQ7WUFDSjtZQUNBLGtDQUFrQztZQUNsQyxNQUFNRSxPQUFPcEMsU0FBU3ZDLEtBQUssQ0FBQztZQUM1QixJQUFJMkUsTUFBTTtnQkFDTixNQUFNekksU0FBUzJHLFNBQVM4QixJQUFJLENBQUMsRUFBRSxFQUFFO2dCQUNqQyxJQUFJQSxJQUFJLENBQUMsRUFBRSxDQUFDekksTUFBTSxLQUFLQSxTQUFTLEdBQUc7b0JBQy9CLE9BQU8sWUFBYXBDLHdEQUFNQSxDQUFDRixNQUFNLENBQUMsT0FBTytLLElBQUksQ0FBQyxFQUFFO2dCQUNwRDtZQUNKO1lBQ0EsK0VBQStFO1lBQy9FLE1BQU1DLFFBQVFyQyxTQUFTdkMsS0FBSyxDQUFDO1lBQzdCLElBQUk0RSxPQUFPO2dCQUNQLElBQUlBLEtBQUssQ0FBQyxFQUFFLENBQUMxSSxNQUFNLEtBQU0sS0FBSyxHQUFJO29CQUM5QixPQUFPLFdBQVkwSSxLQUFLLENBQUMsRUFBRTtnQkFDL0I7WUFDSjtZQUNBLE1BQU1DLFNBQVN0QyxTQUFTdkMsS0FBSyxDQUFDO1lBQzlCLElBQUk2RSxRQUFRO2dCQUNSLElBQUlBLE1BQU0sQ0FBQyxFQUFFLENBQUMzSSxNQUFNLEtBQU0sS0FBSyxHQUFJO29CQUMvQiwyRUFBMkU7b0JBQzNFLE1BQU00SSxVQUFVO3dCQUFFLEtBQUs7d0JBQUksS0FBSzt3QkFBSyxLQUFLO29CQUFJO29CQUM5QyxNQUFNdEcsT0FBTzNFLDhEQUFZQSxDQUFDLE9BQU9nTCxNQUFNLENBQUMsRUFBRSxFQUFFVixPQUFPLENBQUMsV0FBVyxDQUFDWSxJQUFPRCxPQUFPLENBQUNDLEVBQUU7b0JBQ2pGLE9BQU8sV0FBWXZHO2dCQUN2QjtZQUNKO1lBQ0EsT0FBT2hELE9BQU8wRyxVQUFVLENBQUMsQ0FBQyx3Q0FBd0MsQ0FBQyxFQUFFNUcseURBQU1BLENBQUNvRyxNQUFNLENBQUNnQixxQkFBcUIsRUFBRTtnQkFDdEdDLFdBQVc7Z0JBQ1g1RixNQUFNd0Y7WUFDVjtRQUNKO0lBQ0o7SUFDQWdCLFFBQVF5QixHQUFHLEVBQUU7UUFDVCxPQUFPek0sVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyw2Q0FBNkM7WUFDN0MsSUFBSTBNLFdBQVdoSyxtRUFBV0EsQ0FBQytKO1lBQzNCLHNFQUFzRTtZQUN0RSx5RUFBeUU7WUFDekVDLFdBQVdoTCw0REFBTUEsQ0FBQztnQkFBQ2dGLFdBQVc7Z0JBQUtBLFdBQVdnRyxTQUFTL0ksTUFBTTtnQkFBRytJO2FBQVM7WUFDekUsOEJBQThCO1lBQzlCLElBQUksU0FBVS9JLE1BQU0sR0FBRyxPQUFRLEdBQUc7Z0JBQzlCK0ksV0FBV2hMLDREQUFNQSxDQUFDO29CQUFDZ0w7b0JBQVUxSyxnRUFBVUEsQ0FBQyxNQUFNLEtBQU15SyxJQUFJOUksTUFBTSxHQUFHO2lCQUFLO1lBQzFFO1lBQ0EsTUFBTXFHLFdBQVcsTUFBTSxJQUFJLENBQUNILFdBQVcsQ0FBQyxjQUFjL0gsNkRBQU9BLENBQUM0SztZQUM5RCxJQUFJMUMsWUFBWSxRQUFRQSxhQUFhLE1BQU07Z0JBQ3ZDLE9BQU87WUFDWDtZQUNBLE9BQU9ySCxvRUFBWUEsQ0FBQ3FIO1FBQ3hCO0lBQ0o7QUFDSjtBQUNBLElBQUkyQyxtQkFBbUI7QUFDdkIsSUFBSUMsYUFBYTtBQUNWLE1BQU1DLHFCQUFxQnpMLHNFQUFRQTtJQUN0Qzs7Ozs7Ozs7S0FRQyxHQUNEcUUsWUFBWXFILE9BQU8sQ0FBRTtRQUNqQixLQUFLO1FBQ0wsMkJBQTJCO1FBQzNCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLEVBQUU7UUFDakIsSUFBSSxDQUFDQyxRQUFRLEdBQUc7WUFBRUMsT0FBTyxDQUFDO1FBQUU7UUFDNUIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDdkUsU0FBUyxHQUFHLFdBQVd3RSxZQUFZO1FBQ3hDLHlEQUF5RDtRQUN6RCx3REFBd0Q7UUFDeEQsa0JBQWtCO1FBQ2xCN0sseUVBQWNBLENBQUMsSUFBSSxFQUFFLGNBQWV3SyxZQUFZO1FBQ2hELElBQUksSUFBSSxDQUFDTSxVQUFVLEVBQUU7WUFDakJOLFVBQVUsSUFBSSxDQUFDTyxhQUFhO1FBQ2hDO1FBQ0EsSUFBSVAsbUJBQW1CdE0sU0FBUztZQUM1QixJQUFJLENBQUM4TSxlQUFlLEdBQUdSO1lBQ3ZCLHdFQUF3RTtZQUN4RUEsUUFBUTdELEtBQUssQ0FBQyxDQUFDN0IsU0FBWTtZQUMzQiwwQ0FBMEM7WUFDMUMsSUFBSSxDQUFDbUcsTUFBTSxHQUFHdEUsS0FBSyxDQUFDLENBQUM3QixTQUFZO1FBQ3JDLE9BQ0s7WUFDRCxNQUFNb0csZUFBZWpMLG9FQUFTQSxDQUFDLFlBQVksY0FBY3VLO1lBQ3pELElBQUlVLGNBQWM7Z0JBQ2RsTCx5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsWUFBWWtMO2dCQUNqQyxJQUFJLENBQUNDLElBQUksQ0FBQyxXQUFXRCxjQUFjO1lBQ3ZDLE9BQ0s7Z0JBQ0R2SyxPQUFPSyxrQkFBa0IsQ0FBQyxtQkFBbUIsV0FBV3dKO1lBQzVEO1FBQ0o7UUFDQSxJQUFJLENBQUNZLHVCQUF1QixHQUFHLENBQUM7UUFDaEMsSUFBSSxDQUFDN0gsZ0JBQWdCLEdBQUcsQ0FBQztRQUN6QixJQUFJLENBQUM4SCxvQkFBb0IsR0FBRztRQUM1QixJQUFJLENBQUNDLGdCQUFnQixHQUFHO1FBQ3hCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO0lBQzFCO0lBQ0FOLFNBQVM7UUFDTCxPQUFPdk4sVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJLElBQUksQ0FBQzhOLFFBQVEsSUFBSSxNQUFNO2dCQUN2QixJQUFJaEIsVUFBVTtnQkFDZCxJQUFJLElBQUksQ0FBQ1EsZUFBZSxFQUFFO29CQUN0QixJQUFJO3dCQUNBUixVQUFVLE1BQU0sSUFBSSxDQUFDUSxlQUFlO29CQUN4QyxFQUNBLE9BQU9sRyxPQUFPLENBQUU7Z0JBQ3BCO2dCQUNBLHNFQUFzRTtnQkFDdEUsSUFBSTBGLFdBQVcsTUFBTTtvQkFDakJBLFVBQVUsTUFBTSxJQUFJLENBQUNPLGFBQWE7Z0JBQ3RDO2dCQUNBLGlFQUFpRTtnQkFDakUsZ0RBQWdEO2dCQUNoRCxJQUFJLENBQUNQLFNBQVM7b0JBQ1Y3SixPQUFPMEcsVUFBVSxDQUFDLHVCQUF1QjVHLHlEQUFNQSxDQUFDb0csTUFBTSxDQUFDNEUsYUFBYSxFQUFFLENBQUM7Z0JBQzNFO2dCQUNBLGlFQUFpRTtnQkFDakUsSUFBSSxJQUFJLENBQUNELFFBQVEsSUFBSSxNQUFNO29CQUN2QixJQUFJLElBQUksQ0FBQ1YsVUFBVSxFQUFFO3dCQUNqQixJQUFJLENBQUNVLFFBQVEsR0FBR2hCO29CQUNwQixPQUNLO3dCQUNEeEsseUVBQWNBLENBQUMsSUFBSSxFQUFFLFlBQVl3SztvQkFDckM7b0JBQ0EsSUFBSSxDQUFDVyxJQUFJLENBQUMsV0FBV1gsU0FBUztnQkFDbEM7WUFDSjtZQUNBLE9BQU8sSUFBSSxDQUFDZ0IsUUFBUTtRQUN4QjtJQUNKO0lBQ0EsaUVBQWlFO0lBQ2pFLGtFQUFrRTtJQUNsRSx5REFBeUQ7SUFDekQsSUFBSUUsUUFBUTtRQUNSLE9BQU9uTCx5REFBSUEsQ0FBQztZQUNSLE9BQU8sSUFBSSxDQUFDMEssTUFBTSxHQUFHdE0sSUFBSSxDQUFDLENBQUM2TDtnQkFDdkIsT0FBT0E7WUFDWCxHQUFHLENBQUMxRjtnQkFDQSxpREFBaUQ7Z0JBQ2pELElBQUlBLE1BQU04QixJQUFJLEtBQUtuRyx5REFBTUEsQ0FBQ29HLE1BQU0sQ0FBQzhFLGFBQWEsSUFBSTdHLE1BQU1yQixLQUFLLEtBQUssYUFBYTtvQkFDM0UsT0FBT21JO2dCQUNYO2dCQUNBLE1BQU05RztZQUNWO1FBQ0o7SUFDSjtJQUNBLDJEQUEyRDtJQUMzRCxPQUFPK0YsZUFBZTtRQUNsQixJQUFJUixvQkFBb0IsTUFBTTtZQUMxQkEsbUJBQW1CLElBQUl6SixrREFBU0E7UUFDcEM7UUFDQSxPQUFPeUo7SUFDWDtJQUNBLDZDQUE2QztJQUM3QyxPQUFPdEssV0FBV3lLLE9BQU8sRUFBRTtRQUN2QixPQUFPekssb0VBQVVBLENBQUMsV0FBWSxPQUFRLGNBQWN5SztJQUN4RDtJQUNBcUIsY0FBYzNFLEVBQUUsRUFBRTRFLFFBQVEsRUFBRUMsSUFBSSxFQUFFO1FBQzlCLE9BQU9yTyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUksSUFBSSxDQUFDa04sZUFBZSxJQUFJbUIsS0FBSzFLLE1BQU0sS0FBSyxHQUFHO2dCQUMzQyxPQUFPO1lBQ1g7WUFDQSxNQUFNMkssU0FBUzlFLEdBQUdULEVBQUUsQ0FBQ3hGLFdBQVc7WUFDaEMsTUFBTWlCLE9BQU80SixTQUFTN0ssV0FBVztZQUNqQyxNQUFNZ0wsZ0JBQWdCLEVBQUU7WUFDeEIsSUFBSyxJQUFJbEcsSUFBSSxHQUFHQSxJQUFJZ0csS0FBSzFLLE1BQU0sRUFBRTBFLElBQUs7Z0JBQ2xDLE1BQU02QyxNQUFNbUQsSUFBSSxDQUFDaEcsRUFBRTtnQkFDbkIsZ0JBQWdCO2dCQUNoQixNQUFNbUcsT0FBT3RELElBQUlVLE9BQU8sQ0FBQyxZQUFZMEMsUUFBUTFDLE9BQU8sQ0FBQyxVQUFVcEg7Z0JBQy9ELG1EQUFtRDtnQkFDbkQsTUFBTWlLLE9BQU8sSUFBSzVKLE9BQU8sQ0FBQyxhQUFhLElBQUssT0FBT2lILEtBQUtDLFNBQVMsQ0FBQztvQkFBRXZIO29CQUFNOEo7Z0JBQU87Z0JBQ2pGLE1BQU12TixTQUFTLE1BQU02Qiw4REFBU0EsQ0FBQztvQkFBRXNJLEtBQUtzRDtvQkFBTUUsa0JBQWtCO2dCQUFLLEdBQUdELE1BQU0sQ0FBQ25PLE9BQU9xTztvQkFDaEZyTyxNQUFNc08sTUFBTSxHQUFHRCxTQUFTRSxVQUFVO29CQUNsQyxPQUFPdk87Z0JBQ1g7Z0JBQ0EsSUFBSVMsT0FBT3lELElBQUksRUFBRTtvQkFDYixPQUFPekQsT0FBT3lELElBQUk7Z0JBQ3RCO2dCQUNBLE1BQU1zSyxlQUFnQi9OLE9BQU9nTyxPQUFPLElBQUk7Z0JBQ3hDLGdEQUFnRDtnQkFDaEQsSUFBSWhPLE9BQU82TixNQUFNLElBQUksT0FBTzdOLE9BQU82TixNQUFNLEdBQUcsS0FBSztvQkFDN0MsT0FBTzNMLE9BQU8wRyxVQUFVLENBQUMsQ0FBQyxzQ0FBc0MsRUFBRW1GLGFBQWEsQ0FBQyxFQUFFL0wseURBQU1BLENBQUNvRyxNQUFNLENBQUM2RixZQUFZLEVBQUU7d0JBQUU5RDt3QkFBSzREO29CQUFhO2dCQUN0STtnQkFDQSwrQ0FBK0M7Z0JBQy9DUCxjQUFjakcsSUFBSSxDQUFDd0c7WUFDdkI7WUFDQSxPQUFPN0wsT0FBTzBHLFVBQVUsQ0FBQyxDQUFDLHFDQUFxQyxFQUFFNEUsY0FBYzFLLEdBQUcsQ0FBQyxDQUFDb0wsSUFBTW5ELEtBQUtDLFNBQVMsQ0FBQ2tELElBQUkzSyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUV2Qix5REFBTUEsQ0FBQ29HLE1BQU0sQ0FBQzZGLFlBQVksRUFBRTtnQkFDbkpYO2dCQUFNRTtZQUNWO1FBQ0o7SUFDSjtJQUNBLGtFQUFrRTtJQUNsRSwrREFBK0Q7SUFDL0RXLHdCQUF3QkMsTUFBTSxFQUFFO1FBQzVCLE9BQU9uUCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLE1BQU0sSUFBSSxDQUFDdU4sTUFBTTtZQUNqQix1Q0FBdUM7WUFDdkMsSUFBSTRCLFNBQVMsR0FBRztnQkFDWixxREFBcUQ7Z0JBQ3JELE1BQU8sSUFBSSxDQUFDQyxvQkFBb0IsQ0FBRTtvQkFDOUIsNENBQTRDO29CQUM1QyxNQUFNQyxzQkFBc0IsSUFBSSxDQUFDRCxvQkFBb0I7b0JBQ3JELElBQUk7d0JBQ0Esb0NBQW9DO3dCQUNwQyxNQUFNck8sU0FBUyxNQUFNc087d0JBQ3JCLElBQUksWUFBYXRPLE9BQU91TyxRQUFRLElBQUtILFFBQVE7NEJBQ3pDLE9BQU9wTyxPQUFPd08sV0FBVzt3QkFDN0I7d0JBRUE7b0JBQ0osRUFDQSxPQUFPbkksT0FBTzt3QkFDVixxREFBcUQ7d0JBQ3JELHNEQUFzRDt3QkFDdEQscURBQXFEO3dCQUNyRCx1REFBdUQ7d0JBQ3ZELElBQUksSUFBSSxDQUFDZ0ksb0JBQW9CLEtBQUtDLHFCQUFxQjs0QkFDbkQ7d0JBQ0o7b0JBQ0o7Z0JBQ0o7WUFDSjtZQUNBLE1BQU1HLFVBQVV0SztZQUNoQixNQUFNdUssMkJBQTJCak4sNEVBQWlCQSxDQUFDO2dCQUMvQytNLGFBQWEsSUFBSSxDQUFDRyxPQUFPLENBQUMsa0JBQWtCLENBQUM7Z0JBQzdDQyxjQUFjLElBQUksQ0FBQ3ROLFVBQVUsR0FBR3BCLElBQUksQ0FBQyxDQUFDNkwsVUFBYSxNQUFPLENBQUMxRixRQUFXQTtZQUMxRSxHQUFHbkcsSUFBSSxDQUFDLENBQUMsRUFBRXNPLFdBQVcsRUFBRUksWUFBWSxFQUFFO2dCQUNsQyxJQUFJQSxjQUFjO29CQUNkLDRDQUE0QztvQkFDNUMsSUFBSSxJQUFJLENBQUNQLG9CQUFvQixLQUFLSywwQkFBMEI7d0JBQ3hELElBQUksQ0FBQ0wsb0JBQW9CLEdBQUc7b0JBQ2hDO29CQUNBLE1BQU1PO2dCQUNWO2dCQUNBLE1BQU1MLFdBQVdwSztnQkFDakJxSyxjQUFjL04sK0RBQVNBLENBQUNtRixJQUFJLENBQUM0SSxhQUFhakksUUFBUTtnQkFDbEQsSUFBSWlJLGNBQWMsSUFBSSxDQUFDN0IsdUJBQXVCLEVBQUU7b0JBQzVDNkIsY0FBYyxJQUFJLENBQUM3Qix1QkFBdUI7Z0JBQzlDO2dCQUNBLElBQUksQ0FBQ0EsdUJBQXVCLEdBQUc2QjtnQkFDL0IsSUFBSSxDQUFDSyxtQkFBbUIsQ0FBQ0wsY0FBYywwQkFBMEI7Z0JBQ2pFLE9BQU87b0JBQUVBO29CQUFhQztvQkFBU0Y7Z0JBQVM7WUFDNUM7WUFDQSxJQUFJLENBQUNGLG9CQUFvQixHQUFHSztZQUM1QixzRUFBc0U7WUFDdEVBLHlCQUF5QnhHLEtBQUssQ0FBQyxDQUFDN0I7Z0JBQzVCLHVFQUF1RTtnQkFDdkUsSUFBSSxJQUFJLENBQUNnSSxvQkFBb0IsS0FBS0ssMEJBQTBCO29CQUN4RCxJQUFJLENBQUNMLG9CQUFvQixHQUFHO2dCQUNoQztZQUNKO1lBQ0EsT0FBTyxDQUFDLE1BQU1LLHdCQUF1QixFQUFHRixXQUFXO1FBQ3ZEO0lBQ0o7SUFDQTFNLE9BQU87UUFDSCxPQUFPN0MsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxNQUFNNlAsU0FBU2pEO1lBQ2YsbUZBQW1GO1lBQ25GLE1BQU1rRCxVQUFVLEVBQUU7WUFDbEIsSUFBSVAsY0FBYztZQUNsQixJQUFJO2dCQUNBQSxjQUFjLE1BQU0sSUFBSSxDQUFDTCx1QkFBdUIsQ0FBQyxNQUFNLElBQUksQ0FBQ2EsZUFBZSxHQUFHO1lBQ2xGLEVBQ0EsT0FBTzNJLE9BQU87Z0JBQ1YsSUFBSSxDQUFDcUcsSUFBSSxDQUFDLFNBQVNyRztnQkFDbkI7WUFDSjtZQUNBLElBQUksQ0FBQ3dJLG1CQUFtQixDQUFDTDtZQUN6QixpRUFBaUU7WUFDakUsSUFBSSxDQUFDOUIsSUFBSSxDQUFDLFFBQVFvQyxRQUFRTjtZQUMxQixxQ0FBcUM7WUFDckMsSUFBSUEsZ0JBQWdCLElBQUksQ0FBQzFKLGdCQUFnQixFQUFFO2dCQUN2QyxJQUFJLENBQUM0SCxJQUFJLENBQUMsV0FBV29DO2dCQUNyQjtZQUNKO1lBQ0EsZ0RBQWdEO1lBQ2hELElBQUksSUFBSSxDQUFDN0MsUUFBUSxDQUFDQyxLQUFLLEtBQUssQ0FBQyxHQUFHO2dCQUM1QixJQUFJLENBQUNELFFBQVEsQ0FBQ0MsS0FBSyxHQUFHc0MsY0FBYztZQUN4QztZQUNBLElBQUl2SCxLQUFLZ0ksR0FBRyxDQUFDLElBQUssQ0FBQ2hELFFBQVEsQ0FBQ0MsS0FBSyxHQUFJc0MsZUFBZSxNQUFNO2dCQUN0RHRNLE9BQU84QixJQUFJLENBQUMsQ0FBQyw0REFBNEQsRUFBRSxJQUFJLENBQUNpSSxRQUFRLENBQUNDLEtBQUssQ0FBQyxZQUFZLEVBQUVzQyxZQUFZLENBQUMsQ0FBQztnQkFDM0gsSUFBSSxDQUFDOUIsSUFBSSxDQUFDLFNBQVN4SyxPQUFPZ04sU0FBUyxDQUFDLCtCQUErQmxOLHlEQUFNQSxDQUFDb0csTUFBTSxDQUFDOEUsYUFBYSxFQUFFO29CQUM1RnNCLGFBQWFBO29CQUNieEosT0FBTztvQkFDUG1LLHFCQUFxQixJQUFJLENBQUNsRCxRQUFRLENBQUNDLEtBQUs7Z0JBQzVDO2dCQUNBLElBQUksQ0FBQ1EsSUFBSSxDQUFDLFNBQVM4QjtZQUN2QixPQUNLO2dCQUNELHFEQUFxRDtnQkFDckQsSUFBSyxJQUFJbEgsSUFBSSxJQUFJLENBQUMyRSxRQUFRLENBQUNDLEtBQUssR0FBRyxHQUFHNUUsS0FBS2tILGFBQWFsSCxJQUFLO29CQUN6RCxJQUFJLENBQUNvRixJQUFJLENBQUMsU0FBU3BGO2dCQUN2QjtZQUNKO1lBQ0EsMkRBQTJEO1lBQzNELElBQUksSUFBSSxDQUFDMkUsUUFBUSxDQUFDQyxLQUFLLEtBQUtzQyxhQUFhO2dCQUNyQyxJQUFJLENBQUN2QyxRQUFRLENBQUNDLEtBQUssR0FBR3NDO2dCQUN0QnBMLE9BQU9DLElBQUksQ0FBQyxJQUFJLENBQUM0SSxRQUFRLEVBQUUvSSxPQUFPLENBQUMsQ0FBQ3dJO29CQUNoQyxrQ0FBa0M7b0JBQ2xDLElBQUlBLFFBQVEsU0FBUzt3QkFDakI7b0JBQ0o7b0JBQ0Esa0RBQWtEO29CQUNsRCxNQUFNMEQsbUJBQW1CLElBQUksQ0FBQ25ELFFBQVEsQ0FBQ1AsSUFBSTtvQkFDM0MsZ0VBQWdFO29CQUNoRSxnRUFBZ0U7b0JBQ2hFLG1CQUFtQjtvQkFDbkIsSUFBSTBELHFCQUFxQixXQUFXO3dCQUNoQztvQkFDSjtvQkFDQSw4REFBOEQ7b0JBQzlELGlEQUFpRDtvQkFDakQsSUFBSVosY0FBY1ksbUJBQW1CLElBQUk7d0JBQ3JDLE9BQU8sSUFBSSxDQUFDbkQsUUFBUSxDQUFDUCxJQUFJO29CQUM3QjtnQkFDSjtZQUNKO1lBQ0Esc0JBQXNCO1lBQ3RCLElBQUksSUFBSSxDQUFDNUcsZ0JBQWdCLEtBQUssQ0FBQyxHQUFHO2dCQUM5QixJQUFJLENBQUNBLGdCQUFnQixHQUFHMEosY0FBYztZQUMxQztZQUNBLGdEQUFnRDtZQUNoRCxJQUFJLENBQUN4QyxPQUFPLENBQUM5SSxPQUFPLENBQUMsQ0FBQzhCO2dCQUNsQixPQUFRQSxNQUFNQyxJQUFJO29CQUNkLEtBQUs7d0JBQU07NEJBQ1AsTUFBTUMsT0FBT0YsTUFBTUUsSUFBSTs0QkFDdkIsSUFBSW1LLFNBQVMsSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQ3BLLE1BQU1oRixJQUFJLENBQUMsQ0FBQ3FQO2dDQUNoRCxJQUFJLENBQUNBLFdBQVdBLFFBQVFmLFdBQVcsSUFBSSxNQUFNO29DQUN6QyxPQUFPO2dDQUNYO2dDQUNBLElBQUksQ0FBQ3ZDLFFBQVEsQ0FBQyxPQUFPL0csS0FBSyxHQUFHcUssUUFBUWYsV0FBVztnQ0FDaEQsSUFBSSxDQUFDOUIsSUFBSSxDQUFDeEgsTUFBTXFLO2dDQUNoQixPQUFPOzRCQUNYLEdBQUdySCxLQUFLLENBQUMsQ0FBQzdCO2dDQUFZLElBQUksQ0FBQ3FHLElBQUksQ0FBQyxTQUFTckc7NEJBQVE7NEJBQ2pEMEksUUFBUXhILElBQUksQ0FBQzhIOzRCQUNiO3dCQUNKO29CQUNBLEtBQUs7d0JBQVU7NEJBQ1gsMkRBQTJEOzRCQUMzRCxJQUFJLENBQUNySyxNQUFNRCxTQUFTLEVBQUU7Z0NBQ2xCQyxNQUFNRCxTQUFTLEdBQUc7Z0NBQ2xCLHlEQUF5RDtnQ0FDekQsOERBQThEO2dDQUM5RCxJQUFJQyxNQUFNRixnQkFBZ0IsS0FBSyxDQUFDLEdBQUc7b0NBQy9CRSxNQUFNRixnQkFBZ0IsR0FBRzBKLGNBQWM7Z0NBQzNDO2dDQUNBLDREQUE0RDtnQ0FDNUQsd0RBQXdEO2dDQUN4RCwwREFBMEQ7Z0NBQzFELDREQUE0RDtnQ0FDNUQsTUFBTXJKLFNBQVNILE1BQU1HLE1BQU07Z0NBQzNCQSxPQUFPcUssU0FBUyxHQUFHeEssTUFBTUYsZ0JBQWdCLEdBQUc7Z0NBQzVDSyxPQUFPc0ssT0FBTyxHQUFHakI7Z0NBQ2pCLGlFQUFpRTtnQ0FDakUseUVBQXlFO2dDQUN6RSxNQUFNa0IsZUFBZXZLLE9BQU9zSyxPQUFPLEdBQUcsSUFBSSxDQUFDN0Msb0JBQW9CO2dDQUMvRCxJQUFJOEMsZUFBZXZLLE9BQU9xSyxTQUFTLEVBQUU7b0NBQ2pDckssT0FBT3FLLFNBQVMsR0FBR0U7Z0NBQ3ZCO2dDQUNBLElBQUl2SyxPQUFPcUssU0FBUyxHQUFHLEdBQUc7b0NBQ3RCckssT0FBT3FLLFNBQVMsR0FBRztnQ0FDdkI7Z0NBQ0EsTUFBTUgsU0FBUyxJQUFJLENBQUNNLE9BQU8sQ0FBQ3hLLFFBQVFqRixJQUFJLENBQUMsQ0FBQzBQO29DQUN0Qyx5QkFBeUI7b0NBQ3pCNUssTUFBTUQsU0FBUyxHQUFHO29DQUNsQixJQUFJNkssS0FBS2hOLE1BQU0sS0FBSyxHQUFHO3dDQUNuQjtvQ0FDSjtvQ0FDQWdOLEtBQUsxTSxPQUFPLENBQUMsQ0FBQzJNO3dDQUNWLHFEQUFxRDt3Q0FDckQsc0NBQXNDO3dDQUN0QyxJQUFJQSxJQUFJckIsV0FBVyxHQUFHeEosTUFBTUYsZ0JBQWdCLEVBQUU7NENBQzFDRSxNQUFNRixnQkFBZ0IsR0FBRytLLElBQUlyQixXQUFXO3dDQUM1Qzt3Q0FDQSxzREFBc0Q7d0NBQ3RELElBQUksQ0FBQ3ZDLFFBQVEsQ0FBQyxPQUFPNEQsSUFBSUMsU0FBUyxDQUFDLEdBQUdELElBQUlyQixXQUFXO3dDQUNyRCxJQUFJLENBQUN2QyxRQUFRLENBQUMsT0FBTzRELElBQUlFLGVBQWUsQ0FBQyxHQUFHRixJQUFJckIsV0FBVzt3Q0FDM0QsSUFBSSxDQUFDOUIsSUFBSSxDQUFDdkgsUUFBUTBLO29DQUN0QjtnQ0FDSixHQUFHM0gsS0FBSyxDQUFDLENBQUM3QjtvQ0FDTixJQUFJLENBQUNxRyxJQUFJLENBQUMsU0FBU3JHO29DQUNuQixvREFBb0Q7b0NBQ3BEckIsTUFBTUQsU0FBUyxHQUFHO2dDQUN0QjtnQ0FDQWdLLFFBQVF4SCxJQUFJLENBQUM4SDs0QkFDakI7NEJBQ0E7d0JBQ0o7Z0JBQ0o7WUFDSjtZQUNBLElBQUksQ0FBQ3ZLLGdCQUFnQixHQUFHMEo7WUFDeEIsb0VBQW9FO1lBQ3BFL08sUUFBUXVRLEdBQUcsQ0FBQ2pCLFNBQVM3TyxJQUFJLENBQUM7Z0JBQ3RCLElBQUksQ0FBQ3dNLElBQUksQ0FBQyxXQUFXb0M7WUFDekIsR0FBRzVHLEtBQUssQ0FBQyxDQUFDN0I7Z0JBQVksSUFBSSxDQUFDcUcsSUFBSSxDQUFDLFNBQVNyRztZQUFRO1lBQ2pEO1FBQ0o7SUFDSjtJQUNBLDhCQUE4QjtJQUM5QjRKLGlCQUFpQnpCLFdBQVcsRUFBRTtRQUMxQixJQUFJLENBQUMxSixnQkFBZ0IsR0FBRzBKLGNBQWM7UUFDdEMsSUFBSSxJQUFJLENBQUMwQixPQUFPLEVBQUU7WUFDZCxJQUFJLENBQUNwTyxJQUFJO1FBQ2I7SUFDSjtJQUNBLElBQUlpSyxVQUFVO1FBQ1YsT0FBTyxJQUFJLENBQUNnQixRQUFRO0lBQ3hCO0lBQ0EsaUVBQWlFO0lBQ2pFLDJEQUEyRDtJQUMzRFQsZ0JBQWdCO1FBQ1osT0FBT3JOLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsT0FBT2lELE9BQU8wRyxVQUFVLENBQUMsK0NBQStDNUcseURBQU1BLENBQUNvRyxNQUFNLENBQUNnQixxQkFBcUIsRUFBRTtnQkFDekdDLFdBQVc7WUFDZjtRQUNKO0lBQ0o7SUFDQS9ILGFBQWE7UUFDVCxPQUFPckMsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxNQUFNOE0sVUFBVSxNQUFNLElBQUksQ0FBQ1MsTUFBTTtZQUNqQyxnRUFBZ0U7WUFDaEUsbUVBQW1FO1lBQ25FLCtCQUErQjtZQUMvQixNQUFNMkQsaUJBQWlCLE1BQU0sSUFBSSxDQUFDN0QsYUFBYTtZQUMvQyxJQUFJUCxRQUFRcUUsT0FBTyxLQUFLRCxlQUFlQyxPQUFPLEVBQUU7Z0JBQzVDLGdFQUFnRTtnQkFDaEUseURBQXlEO2dCQUN6RCxJQUFJLElBQUksQ0FBQy9ELFVBQVUsRUFBRTtvQkFDakIsSUFBSSxDQUFDVSxRQUFRLEdBQUdvRDtvQkFDaEIsb0RBQW9EO29CQUNwRCxJQUFJLENBQUNyTCxnQkFBZ0IsR0FBRyxDQUFDO29CQUN6QixJQUFJLENBQUN1TCxnQkFBZ0IsR0FBRztvQkFDeEIsSUFBSSxDQUFDQyx1QkFBdUIsR0FBRztvQkFDL0IsSUFBSSxDQUFDeEQsY0FBYyxHQUFHO29CQUN0QixJQUFJLENBQUNiLFFBQVEsQ0FBQ0MsS0FBSyxHQUFHLENBQUM7b0JBQ3ZCLElBQUksQ0FBQ1MsdUJBQXVCLEdBQUcsQ0FBQztvQkFDaEMsSUFBSSxDQUFDMEIsb0JBQW9CLEdBQUc7b0JBQzVCLDhEQUE4RDtvQkFDOUQsNERBQTREO29CQUM1RCwwREFBMEQ7b0JBQzFELElBQUksQ0FBQzNCLElBQUksQ0FBQyxXQUFXeUQsZ0JBQWdCcEU7b0JBQ3JDLE1BQU0xSCxNQUFNO29CQUNaLE9BQU8sSUFBSSxDQUFDMEksUUFBUTtnQkFDeEI7Z0JBQ0EsTUFBTTFHLFFBQVFuRSxPQUFPZ04sU0FBUyxDQUFDLDhCQUE4QmxOLHlEQUFNQSxDQUFDb0csTUFBTSxDQUFDOEUsYUFBYSxFQUFFO29CQUN0RmxJLE9BQU87b0JBQ1ArRyxTQUFTQTtvQkFDVHdFLGlCQUFpQko7Z0JBQ3JCO2dCQUNBLElBQUksQ0FBQ3pELElBQUksQ0FBQyxTQUFTckc7Z0JBQ25CLE1BQU1BO1lBQ1Y7WUFDQSxPQUFPMEY7UUFDWDtJQUNKO0lBQ0EsSUFBSXlDLGNBQWM7UUFDZCxJQUFJLENBQUNMLHVCQUF1QixDQUFDLE1BQU0sSUFBSSxDQUFDYSxlQUFlLEdBQUcsR0FBRzlPLElBQUksQ0FBQyxDQUFDc087WUFDL0QsSUFBSSxDQUFDSyxtQkFBbUIsQ0FBQ0w7UUFDN0IsR0FBRyxDQUFDbkksU0FBWTtRQUNoQixPQUFPLElBQUssQ0FBQ2dLLGdCQUFnQixJQUFJLE9BQVEsSUFBSSxDQUFDQSxnQkFBZ0IsR0FBRyxDQUFDO0lBQ3RFO0lBQ0EsSUFBSUgsVUFBVTtRQUNWLE9BQVEsSUFBSSxDQUFDTSxPQUFPLElBQUk7SUFDNUI7SUFDQSxJQUFJTixRQUFRM1EsS0FBSyxFQUFFO1FBQ2YsSUFBSUEsU0FBUyxDQUFDLElBQUksQ0FBQ2lSLE9BQU8sRUFBRTtZQUN4QixJQUFJLENBQUNBLE9BQU8sR0FBR0MsWUFBWTtnQkFBUSxJQUFJLENBQUMzTyxJQUFJO1lBQUksR0FBRyxJQUFJLENBQUNrTixlQUFlO1lBQ3ZFLElBQUksQ0FBQyxJQUFJLENBQUMwQixjQUFjLEVBQUU7Z0JBQ3RCLElBQUksQ0FBQ0EsY0FBYyxHQUFHbk0sV0FBVztvQkFDN0IsSUFBSSxDQUFDekMsSUFBSTtvQkFDVCx1REFBdUQ7b0JBQ3ZELHFEQUFxRDtvQkFDckQsSUFBSSxDQUFDNE8sY0FBYyxHQUFHbk0sV0FBVzt3QkFDN0Isd0RBQXdEO3dCQUN4RCx3REFBd0Q7d0JBQ3hELElBQUksQ0FBQyxJQUFJLENBQUNpTSxPQUFPLEVBQUU7NEJBQ2YsSUFBSSxDQUFDMU8sSUFBSTt3QkFDYjt3QkFDQSwrQ0FBK0M7d0JBQy9DLElBQUksQ0FBQzRPLGNBQWMsR0FBRztvQkFDMUIsR0FBRyxJQUFJLENBQUMxQixlQUFlO2dCQUMzQixHQUFHO1lBQ1A7UUFDSixPQUNLLElBQUksQ0FBQ3pQLFNBQVMsSUFBSSxDQUFDaVIsT0FBTyxFQUFFO1lBQzdCRyxjQUFjLElBQUksQ0FBQ0gsT0FBTztZQUMxQixJQUFJLENBQUNBLE9BQU8sR0FBRztRQUNuQjtJQUNKO0lBQ0EsSUFBSXhCLGtCQUFrQjtRQUNsQixPQUFPLElBQUksQ0FBQ25DLGdCQUFnQjtJQUNoQztJQUNBLElBQUltQyxnQkFBZ0J6UCxLQUFLLEVBQUU7UUFDdkIsSUFBSSxPQUFRQSxVQUFXLFlBQVlBLFNBQVMsS0FBS2dLLFNBQVNKLE9BQU81SixXQUFXQSxPQUFPO1lBQy9FLE1BQU0sSUFBSTBFLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUM0SSxnQkFBZ0IsR0FBR3ROO1FBQ3hCLElBQUksSUFBSSxDQUFDaVIsT0FBTyxFQUFFO1lBQ2RHLGNBQWMsSUFBSSxDQUFDSCxPQUFPO1lBQzFCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQyxZQUFZO2dCQUFRLElBQUksQ0FBQzNPLElBQUk7WUFBSSxHQUFHLElBQUksQ0FBQytLLGdCQUFnQjtRQUM1RTtJQUNKO0lBQ0ErRCxzQkFBc0I7UUFDbEIsTUFBTUMsTUFBTTFNO1FBQ1osNENBQTRDO1FBQzVDLElBQUksTUFBTyxJQUFJLENBQUMySSxjQUFjLEdBQUksSUFBSSxJQUFJLENBQUNELGdCQUFnQixFQUFFO1lBQ3pELElBQUksQ0FBQ0MsY0FBYyxHQUFHK0Q7WUFDdEIsSUFBSSxDQUFDUCx1QkFBdUIsR0FBRyxJQUFJLENBQUNRLGNBQWMsR0FBRzVRLElBQUksQ0FBQyxDQUFDc087Z0JBQ3ZELElBQUksSUFBSSxDQUFDNkIsZ0JBQWdCLElBQUksUUFBUTdCLGNBQWMsSUFBSSxDQUFDNkIsZ0JBQWdCLEVBQUU7b0JBQ3RFLElBQUksQ0FBQ0EsZ0JBQWdCLEdBQUc3QjtnQkFDNUI7Z0JBQ0EsT0FBTyxJQUFJLENBQUM2QixnQkFBZ0I7WUFDaEM7UUFDSjtRQUNBLE9BQU8sSUFBSSxDQUFDQyx1QkFBdUI7SUFDdkM7SUFDQXpCLG9CQUFvQkwsV0FBVyxFQUFFO1FBQzdCLHFDQUFxQztRQUNyQyxJQUFJLElBQUksQ0FBQzZCLGdCQUFnQixJQUFJLFFBQVE3QixjQUFjLElBQUksQ0FBQzZCLGdCQUFnQixFQUFFO1lBQ3RFO1FBQ0o7UUFDQSw2Q0FBNkM7UUFDN0MsSUFBSSxDQUFDdkQsY0FBYyxHQUFHM0k7UUFDdEIsOEJBQThCO1FBQzlCLElBQUksSUFBSSxDQUFDa00sZ0JBQWdCLElBQUksUUFBUTdCLGNBQWMsSUFBSSxDQUFDNkIsZ0JBQWdCLEVBQUU7WUFDdEUsSUFBSSxDQUFDQSxnQkFBZ0IsR0FBRzdCO1lBQ3hCLElBQUksQ0FBQzhCLHVCQUF1QixHQUFHN1EsUUFBUUQsT0FBTyxDQUFDZ1A7UUFDbkQ7SUFDSjtJQUNBdUMsbUJBQW1CaEIsZUFBZSxFQUFFaUIsYUFBYSxFQUFFQyxPQUFPLEVBQUU7UUFDeEQsT0FBT2hTLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsT0FBTyxJQUFJLENBQUNpUyxtQkFBbUIsQ0FBQ25CLGlCQUFpQixpQkFBa0IsT0FBUSxJQUFJaUIsZUFBZUMsV0FBVyxHQUFHO1FBQ2hIO0lBQ0o7SUFDQUMsb0JBQW9CbkIsZUFBZSxFQUFFaUIsYUFBYSxFQUFFQyxPQUFPLEVBQUVFLFdBQVcsRUFBRTtRQUN0RSxPQUFPbFMsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxNQUFNc1EsVUFBVSxNQUFNLElBQUksQ0FBQ0QscUJBQXFCLENBQUNTO1lBQ2pELDBCQUEwQjtZQUMxQixJQUFJLENBQUNSLFVBQVVBLFFBQVF5QixhQUFhLEdBQUcsTUFBTUEsZUFBZTtnQkFDeEQsT0FBT3pCO1lBQ1g7WUFDQSxvQ0FBb0M7WUFDcEMsT0FBTyxJQUFJOVAsUUFBUSxDQUFDRCxTQUFTRTtnQkFDekIsTUFBTTBSLGNBQWMsRUFBRTtnQkFDdEIsSUFBSW5SLE9BQU87Z0JBQ1gsTUFBTW9SLGNBQWM7b0JBQ2hCLElBQUlwUixNQUFNO3dCQUNOLE9BQU87b0JBQ1g7b0JBQ0FBLE9BQU87b0JBQ1BtUixZQUFZbE8sT0FBTyxDQUFDLENBQUNvTzt3QkFBV0E7b0JBQVE7b0JBQ3hDLE9BQU87Z0JBQ1g7Z0JBQ0EsTUFBTUMsZUFBZSxDQUFDaEM7b0JBQ2xCLElBQUlBLFFBQVF5QixhQUFhLEdBQUdBLGVBQWU7d0JBQ3ZDO29CQUNKO29CQUNBLElBQUlLLGVBQWU7d0JBQ2Y7b0JBQ0o7b0JBQ0E3UixRQUFRK1A7Z0JBQ1o7Z0JBQ0EsSUFBSSxDQUFDaUMsRUFBRSxDQUFDekIsaUJBQWlCd0I7Z0JBQ3pCSCxZQUFZN0osSUFBSSxDQUFDO29CQUFRLElBQUksQ0FBQ2tLLGNBQWMsQ0FBQzFCLGlCQUFpQndCO2dCQUFlO2dCQUM3RSxJQUFJSixhQUFhO29CQUNiLElBQUlPLGtCQUFrQlAsWUFBWVEsVUFBVTtvQkFDNUMsSUFBSUMsZUFBZTtvQkFDbkIsTUFBTUMsaUJBQWlCLENBQUNyRCxjQUFnQnZQLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7NEJBQ3BFLElBQUlnQixNQUFNO2dDQUNOOzRCQUNKOzRCQUNBLDhEQUE4RDs0QkFDOUQsZ0VBQWdFOzRCQUNoRSxtQ0FBbUM7NEJBQ25DLE1BQU1vRSxNQUFNOzRCQUNaLElBQUksQ0FBQ3lOLG1CQUFtQixDQUFDWCxZQUFZdkwsSUFBSSxFQUFFMUYsSUFBSSxDQUFDLENBQUM2UixRQUFVOVMsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztvQ0FDdkYsSUFBSWdCLE1BQU07d0NBQ047b0NBQ0o7b0NBQ0EsSUFBSThSLFNBQVNaLFlBQVlZLEtBQUssRUFBRTt3Q0FDNUJMLGtCQUFrQmxEO29DQUN0QixPQUNLO3dDQUNELDJDQUEyQzt3Q0FDM0M7NENBQ0ksTUFBTXdELFFBQVEsTUFBTSxJQUFJLENBQUNDLGNBQWMsQ0FBQ2xDOzRDQUN4QyxJQUFJaUMsU0FBU0EsTUFBTXhELFdBQVcsSUFBSSxNQUFNO2dEQUNwQzs0Q0FDSjt3Q0FDSjt3Q0FDQSwwREFBMEQ7d0NBQzFELDhEQUE4RDt3Q0FDOUQsd0RBQXdEO3dDQUN4RCxtQkFBbUI7d0NBQ25CLElBQUlvRCxnQkFBZ0IsTUFBTTs0Q0FDdEJBLGVBQWVGLGtCQUFrQjs0Q0FDakMsSUFBSUUsZUFBZVQsWUFBWVEsVUFBVSxFQUFFO2dEQUN2Q0MsZUFBZVQsWUFBWVEsVUFBVTs0Q0FDekM7d0NBQ0o7d0NBQ0EsTUFBT0MsZ0JBQWdCcEQsWUFBYTs0Q0FDaEMsSUFBSXZPLE1BQU07Z0RBQ047NENBQ0o7NENBQ0EsTUFBTWlNLFFBQVEsTUFBTSxJQUFJLENBQUNnRyx3QkFBd0IsQ0FBQ047NENBQ2xELElBQUssSUFBSU8sS0FBSyxHQUFHQSxLQUFLakcsTUFBTWtHLFlBQVksQ0FBQ3hQLE1BQU0sRUFBRXVQLEtBQU07Z0RBQ25ELE1BQU0xSixLQUFLeUQsTUFBTWtHLFlBQVksQ0FBQ0QsR0FBRztnREFDakMsc0JBQXNCO2dEQUN0QixJQUFJMUosR0FBR3ZELElBQUksS0FBSzZLLGlCQUFpQjtvREFDN0I7Z0RBQ0o7Z0RBQ0EsNERBQTREO2dEQUM1RCxJQUFJdEgsR0FBRzdDLElBQUksS0FBS3VMLFlBQVl2TCxJQUFJLElBQUk2QyxHQUFHc0osS0FBSyxLQUFLWixZQUFZWSxLQUFLLEVBQUU7b0RBQ2hFLElBQUk5UixNQUFNO3dEQUNOO29EQUNKO29EQUNBLHFDQUFxQztvREFDckMsTUFBTXNQLFVBQVUsTUFBTSxJQUFJLENBQUN3QixrQkFBa0IsQ0FBQ3RJLEdBQUd2RCxJQUFJLEVBQUU4TDtvREFDdkQsa0RBQWtEO29EQUNsRCxJQUFJSyxlQUFlO3dEQUNmO29EQUNKO29EQUNBLDhCQUE4QjtvREFDOUIsSUFBSWdCLFNBQVM7b0RBQ2IsSUFBSTVKLEdBQUdoRixJQUFJLEtBQUswTixZQUFZMU4sSUFBSSxJQUFJZ0YsR0FBR1QsRUFBRSxLQUFLbUosWUFBWW5KLEVBQUUsSUFBSVMsR0FBR2xKLEtBQUssQ0FBQzBJLEVBQUUsQ0FBQ2tKLFlBQVk1UixLQUFLLEdBQUc7d0RBQzVGOFMsU0FBUztvREFDYixPQUNLLElBQUk1SixHQUFHaEYsSUFBSSxLQUFLLFFBQVFnRixHQUFHN0MsSUFBSSxLQUFLNkMsR0FBR1QsRUFBRSxJQUFJUyxHQUFHbEosS0FBSyxDQUFDbUwsTUFBTSxJQUFJO3dEQUNqRTJILFNBQVM7b0RBQ2I7b0RBQ0EsK0JBQStCO29EQUMvQjNTLE9BQU93QyxPQUFPZ04sU0FBUyxDQUFDLDRCQUE0QmxOLHlEQUFNQSxDQUFDb0csTUFBTSxDQUFDa0ssb0JBQW9CLEVBQUU7d0RBQ3BGQyxXQUFZRixXQUFXLGNBQWNBLFdBQVc7d0RBQ2hEQTt3REFDQUcsYUFBYSxJQUFJLENBQUNDLGdCQUFnQixDQUFDaEs7d0RBQ25DdkQsTUFBTTZLO3dEQUNOUjtvREFDSjtvREFDQTtnREFDSjs0Q0FDSjs0Q0FDQXFDO3dDQUNKO29DQUNKO29DQUNBLElBQUkzUixNQUFNO3dDQUNOO29DQUNKO29DQUNBLElBQUksQ0FBQzRFLElBQUksQ0FBQyxTQUFTZ047Z0NBQ3ZCLElBQUksQ0FBQ3hMO2dDQUNELElBQUlwRyxNQUFNO29DQUNOO2dDQUNKO2dDQUNBLElBQUksQ0FBQzRFLElBQUksQ0FBQyxTQUFTZ047NEJBQ3ZCO3dCQUNKO29CQUNBLElBQUk1UixNQUFNO3dCQUNOO29CQUNKO29CQUNBLElBQUksQ0FBQzRFLElBQUksQ0FBQyxTQUFTZ047b0JBQ25CVCxZQUFZN0osSUFBSSxDQUFDO3dCQUNiLElBQUksQ0FBQ2tLLGNBQWMsQ0FBQyxTQUFTSTtvQkFDakM7Z0JBQ0o7Z0JBQ0EsSUFBSSxPQUFRWixZQUFhLFlBQVlBLFVBQVUsR0FBRztvQkFDOUMsTUFBTXlCLFFBQVFuTyxXQUFXO3dCQUNyQixJQUFJOE0sZUFBZTs0QkFDZjt3QkFDSjt3QkFDQTNSLE9BQU93QyxPQUFPZ04sU0FBUyxDQUFDLG9CQUFvQmxOLHlEQUFNQSxDQUFDb0csTUFBTSxDQUFDdUssT0FBTyxFQUFFOzRCQUFFMUIsU0FBU0E7d0JBQVE7b0JBQzFGLEdBQUdBO29CQUNILElBQUl5QixNQUFNRSxLQUFLLEVBQUU7d0JBQ2JGLE1BQU1FLEtBQUs7b0JBQ2Y7b0JBQ0F4QixZQUFZN0osSUFBSSxDQUFDO3dCQUFRc0wsYUFBYUg7b0JBQVE7Z0JBQ2xEO1lBQ0o7UUFDSjtJQUNKO0lBQ0E1QixpQkFBaUI7UUFDYixPQUFPN1IsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxPQUFPLElBQUksQ0FBQ2tQLHVCQUF1QixDQUFDO1FBQ3hDO0lBQ0o7SUFDQTJFLGNBQWM7UUFDVixPQUFPN1QsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxNQUFNLElBQUksQ0FBQ3FDLFVBQVU7WUFDckIsTUFBTXRCLFNBQVMsTUFBTSxJQUFJLENBQUMyTyxPQUFPLENBQUMsZUFBZSxDQUFDO1lBQ2xELElBQUk7Z0JBQ0EsT0FBT2xPLCtEQUFTQSxDQUFDbUYsSUFBSSxDQUFDNUY7WUFDMUIsRUFDQSxPQUFPcUcsT0FBTztnQkFDVixPQUFPbkUsT0FBTzBHLFVBQVUsQ0FBQywyQkFBMkI1Ryx5REFBTUEsQ0FBQ29HLE1BQU0sQ0FBQzZGLFlBQVksRUFBRTtvQkFDNUU4RSxRQUFRO29CQUNSL1M7b0JBQVFxRztnQkFDWjtZQUNKO1FBQ0o7SUFDSjtJQUNBMk0sV0FBV0MsYUFBYSxFQUFFQyxRQUFRLEVBQUU7UUFDaEMsT0FBT2pVLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsTUFBTSxJQUFJLENBQUNxQyxVQUFVO1lBQ3JCLE1BQU02UixTQUFTLE1BQU0xUiw0RUFBaUJBLENBQUM7Z0JBQ25DeUMsU0FBUyxJQUFJLENBQUM2RSxXQUFXLENBQUNrSztnQkFDMUJDLFVBQVUsSUFBSSxDQUFDRSxZQUFZLENBQUNGO1lBQ2hDO1lBQ0EsTUFBTWxULFNBQVMsTUFBTSxJQUFJLENBQUMyTyxPQUFPLENBQUMsY0FBY3dFO1lBQ2hELElBQUk7Z0JBQ0EsT0FBTzFTLCtEQUFTQSxDQUFDbUYsSUFBSSxDQUFDNUY7WUFDMUIsRUFDQSxPQUFPcUcsT0FBTztnQkFDVixPQUFPbkUsT0FBTzBHLFVBQVUsQ0FBQywyQkFBMkI1Ryx5REFBTUEsQ0FBQ29HLE1BQU0sQ0FBQzZGLFlBQVksRUFBRTtvQkFDNUU4RSxRQUFRO29CQUNSSTtvQkFBUW5UO29CQUFRcUc7Z0JBQ3BCO1lBQ0o7UUFDSjtJQUNKO0lBQ0F5TCxvQkFBb0JtQixhQUFhLEVBQUVDLFFBQVEsRUFBRTtRQUN6QyxPQUFPalUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxNQUFNLElBQUksQ0FBQ3FDLFVBQVU7WUFDckIsTUFBTTZSLFNBQVMsTUFBTTFSLDRFQUFpQkEsQ0FBQztnQkFDbkN5QyxTQUFTLElBQUksQ0FBQzZFLFdBQVcsQ0FBQ2tLO2dCQUMxQkMsVUFBVSxJQUFJLENBQUNFLFlBQVksQ0FBQ0Y7WUFDaEM7WUFDQSxNQUFNbFQsU0FBUyxNQUFNLElBQUksQ0FBQzJPLE9BQU8sQ0FBQyx1QkFBdUJ3RTtZQUN6RCxJQUFJO2dCQUNBLE9BQU8xUywrREFBU0EsQ0FBQ21GLElBQUksQ0FBQzVGLFFBQVF1RyxRQUFRO1lBQzFDLEVBQ0EsT0FBT0YsT0FBTztnQkFDVixPQUFPbkUsT0FBTzBHLFVBQVUsQ0FBQywyQkFBMkI1Ryx5REFBTUEsQ0FBQ29HLE1BQU0sQ0FBQzZGLFlBQVksRUFBRTtvQkFDNUU4RSxRQUFRO29CQUNSSTtvQkFBUW5UO29CQUFRcUc7Z0JBQ3BCO1lBQ0o7UUFDSjtJQUNKO0lBQ0FnTixRQUFRSixhQUFhLEVBQUVDLFFBQVEsRUFBRTtRQUM3QixPQUFPalUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxNQUFNLElBQUksQ0FBQ3FDLFVBQVU7WUFDckIsTUFBTTZSLFNBQVMsTUFBTTFSLDRFQUFpQkEsQ0FBQztnQkFDbkN5QyxTQUFTLElBQUksQ0FBQzZFLFdBQVcsQ0FBQ2tLO2dCQUMxQkMsVUFBVSxJQUFJLENBQUNFLFlBQVksQ0FBQ0Y7WUFDaEM7WUFDQSxNQUFNbFQsU0FBUyxNQUFNLElBQUksQ0FBQzJPLE9BQU8sQ0FBQyxXQUFXd0U7WUFDN0MsSUFBSTtnQkFDQSxPQUFPcFMsNkRBQU9BLENBQUNmO1lBQ25CLEVBQ0EsT0FBT3FHLE9BQU87Z0JBQ1YsT0FBT25FLE9BQU8wRyxVQUFVLENBQUMsMkJBQTJCNUcseURBQU1BLENBQUNvRyxNQUFNLENBQUM2RixZQUFZLEVBQUU7b0JBQzVFOEUsUUFBUTtvQkFDUkk7b0JBQVFuVDtvQkFBUXFHO2dCQUNwQjtZQUNKO1FBQ0o7SUFDSjtJQUNBaU4sYUFBYUwsYUFBYSxFQUFFTSxRQUFRLEVBQUVMLFFBQVEsRUFBRTtRQUM1QyxPQUFPalUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxNQUFNLElBQUksQ0FBQ3FDLFVBQVU7WUFDckIsTUFBTTZSLFNBQVMsTUFBTTFSLDRFQUFpQkEsQ0FBQztnQkFDbkN5QyxTQUFTLElBQUksQ0FBQzZFLFdBQVcsQ0FBQ2tLO2dCQUMxQkMsVUFBVSxJQUFJLENBQUNFLFlBQVksQ0FBQ0Y7Z0JBQzVCSyxVQUFVOVQsUUFBUUQsT0FBTyxDQUFDK1QsVUFBVXJULElBQUksQ0FBQyxDQUFDc1QsSUFBTXhTLDhEQUFRQSxDQUFDd1M7WUFDN0Q7WUFDQSxNQUFNeFQsU0FBUyxNQUFNLElBQUksQ0FBQzJPLE9BQU8sQ0FBQyxnQkFBZ0J3RTtZQUNsRCxJQUFJO2dCQUNBLE9BQU9wUyw2REFBT0EsQ0FBQ2Y7WUFDbkIsRUFDQSxPQUFPcUcsT0FBTztnQkFDVixPQUFPbkUsT0FBTzBHLFVBQVUsQ0FBQywyQkFBMkI1Ryx5REFBTUEsQ0FBQ29HLE1BQU0sQ0FBQzZGLFlBQVksRUFBRTtvQkFDNUU4RSxRQUFRO29CQUNSSTtvQkFBUW5UO29CQUFRcUc7Z0JBQ3BCO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsdUVBQXVFO0lBQ3ZFb00saUJBQWlCaEssRUFBRSxFQUFFdkQsSUFBSSxFQUFFeU0sVUFBVSxFQUFFO1FBQ25DLElBQUl6TSxRQUFRLFFBQVFyRSxtRUFBYUEsQ0FBQ3FFLFVBQVUsSUFBSTtZQUM1QyxNQUFNLElBQUlqQixNQUFNO1FBQ3BCO1FBQ0EsTUFBTWpFLFNBQVN5STtRQUNmLHVFQUF1RTtRQUN2RSxJQUFJdkQsUUFBUSxRQUFRdUQsR0FBR3ZELElBQUksS0FBS0EsTUFBTTtZQUNsQ2hELE9BQU8wRyxVQUFVLENBQUMsNERBQTRENUcseURBQU1BLENBQUNvRyxNQUFNLENBQUM0RSxhQUFhLEVBQUU7Z0JBQUV5RyxjQUFjaEwsR0FBR3ZELElBQUk7Z0JBQUV3TyxjQUFjeE87WUFBSztRQUMzSjtRQUNBbEYsT0FBTzJULElBQUksR0FBRyxDQUFDQyxVQUFVM0MsVUFBWWhTLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7Z0JBQ2pFLElBQUkyVSxZQUFZLE1BQU07b0JBQ2xCQSxXQUFXO2dCQUNmO2dCQUNBLElBQUkzQyxXQUFXLE1BQU07b0JBQ2pCQSxVQUFVO2dCQUNkO2dCQUNBLHdDQUF3QztnQkFDeEMsSUFBSXVCLGNBQWNyRjtnQkFDbEIsSUFBSXlHLGFBQWEsS0FBS2pDLGNBQWMsTUFBTTtvQkFDdENhLGNBQWM7d0JBQ1YvTyxNQUFNZ0YsR0FBR2hGLElBQUk7d0JBQ2JtQyxNQUFNNkMsR0FBRzdDLElBQUk7d0JBQ2JtTSxPQUFPdEosR0FBR3NKLEtBQUs7d0JBQ2YvSixJQUFJUyxHQUFHVCxFQUFFO3dCQUNUekksT0FBT2tKLEdBQUdsSixLQUFLO3dCQUNmb1M7b0JBQ0o7Z0JBQ0o7Z0JBQ0EsTUFBTXBDLFVBQVUsTUFBTSxJQUFJLENBQUMyQixtQkFBbUIsQ0FBQ3pJLEdBQUd2RCxJQUFJLEVBQUUwTyxVQUFVM0MsU0FBU3VCO2dCQUMzRSxJQUFJakQsV0FBVyxRQUFRcUUsYUFBYSxHQUFHO29CQUNuQyxPQUFPO2dCQUNYO2dCQUNBLG9FQUFvRTtnQkFDcEUsSUFBSSxDQUFDM0gsUUFBUSxDQUFDLE9BQU94RCxHQUFHdkQsSUFBSSxDQUFDLEdBQUdxSyxRQUFRZixXQUFXO2dCQUNuRCxJQUFJZSxRQUFRMUIsTUFBTSxLQUFLLEdBQUc7b0JBQ3RCM0wsT0FBTzBHLFVBQVUsQ0FBQyxzQkFBc0I1Ryx5REFBTUEsQ0FBQ29HLE1BQU0sQ0FBQ0MsY0FBYyxFQUFFO3dCQUNsRTBILGlCQUFpQnRILEdBQUd2RCxJQUFJO3dCQUN4QjJELGFBQWFKO3dCQUNiOEcsU0FBU0E7b0JBQ2I7Z0JBQ0o7Z0JBQ0EsT0FBT0E7WUFDWDtRQUNBLE9BQU92UDtJQUNYO0lBQ0E2VCxnQkFBZ0JDLGlCQUFpQixFQUFFO1FBQy9CLE9BQU83VSxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLE1BQU0sSUFBSSxDQUFDcUMsVUFBVTtZQUNyQixNQUFNeVMsUUFBUSxNQUFNdFUsUUFBUUQsT0FBTyxDQUFDc1UsbUJBQW1CNVQsSUFBSSxDQUFDOFQsQ0FBQUEsSUFBS2pULDZEQUFPQSxDQUFDaVQ7WUFDekUsTUFBTXZMLEtBQUssSUFBSSxDQUFDYixTQUFTLENBQUNpQixXQUFXLENBQUNpTDtZQUN0QyxJQUFJckwsR0FBR3VJLGFBQWEsSUFBSSxNQUFNO2dCQUMxQnZJLEdBQUd1SSxhQUFhLEdBQUc7WUFDdkI7WUFDQSxNQUFNeEMsY0FBYyxNQUFNLElBQUksQ0FBQ0wsdUJBQXVCLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQ2EsZUFBZTtZQUNyRixJQUFJO2dCQUNBLE1BQU05SixPQUFPLE1BQU0sSUFBSSxDQUFDeUosT0FBTyxDQUFDLG1CQUFtQjtvQkFBRW1GLG1CQUFtQkM7Z0JBQU07Z0JBQzlFLE9BQU8sSUFBSSxDQUFDdEIsZ0JBQWdCLENBQUNoSyxJQUFJdkQsTUFBTXNKO1lBQzNDLEVBQ0EsT0FBT25JLE9BQU87Z0JBQ1ZBLE1BQU13QyxXQUFXLEdBQUdKO2dCQUNwQnBDLE1BQU0wSixlQUFlLEdBQUd0SCxHQUFHdkQsSUFBSTtnQkFDL0IsTUFBTW1CO1lBQ1Y7UUFDSjtJQUNKO0lBQ0E0Tix1QkFBdUJwTCxXQUFXLEVBQUU7UUFDaEMsT0FBTzVKLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsTUFBTWlWLFNBQVMsTUFBTXJMO1lBQ3JCLE1BQU1KLEtBQUssQ0FBQztZQUNaO2dCQUFDO2dCQUFRO2FBQUssQ0FBQ3ZGLE9BQU8sQ0FBQyxDQUFDd0k7Z0JBQ3BCLElBQUl3SSxNQUFNLENBQUN4SSxJQUFJLElBQUksTUFBTTtvQkFDckI7Z0JBQ0o7Z0JBQ0FqRCxFQUFFLENBQUNpRCxJQUFJLEdBQUdqTSxRQUFRRCxPQUFPLENBQUMwVSxNQUFNLENBQUN4SSxJQUFJLEVBQUV4TCxJQUFJLENBQUMsQ0FBQ2lVLElBQU9BLElBQUksSUFBSSxDQUFDcEwsV0FBVyxDQUFDb0wsS0FBSztZQUNsRjtZQUNBO2dCQUFDO2dCQUFZO2dCQUFZO2dCQUFnQjtnQkFBd0I7YUFBUSxDQUFDalIsT0FBTyxDQUFDLENBQUN3STtnQkFDL0UsSUFBSXdJLE1BQU0sQ0FBQ3hJLElBQUksSUFBSSxNQUFNO29CQUNyQjtnQkFDSjtnQkFDQWpELEVBQUUsQ0FBQ2lELElBQUksR0FBR2pNLFFBQVFELE9BQU8sQ0FBQzBVLE1BQU0sQ0FBQ3hJLElBQUksRUFBRXhMLElBQUksQ0FBQyxDQUFDaVUsSUFBT0EsSUFBSTFULCtEQUFTQSxDQUFDbUYsSUFBSSxDQUFDdU8sS0FBSztZQUNoRjtZQUNBO2dCQUFDO2FBQU8sQ0FBQ2pSLE9BQU8sQ0FBQyxDQUFDd0k7Z0JBQ2QsSUFBSXdJLE1BQU0sQ0FBQ3hJLElBQUksSUFBSSxNQUFNO29CQUNyQjtnQkFDSjtnQkFDQWpELEVBQUUsQ0FBQ2lELElBQUksR0FBR2pNLFFBQVFELE9BQU8sQ0FBQzBVLE1BQU0sQ0FBQ3hJLElBQUksRUFBRXhMLElBQUksQ0FBQyxDQUFDaVUsSUFBTyxLQUFNLE9BQVFBLElBQUk7WUFDMUU7WUFDQSxJQUFJRCxPQUFPRSxVQUFVLEVBQUU7Z0JBQ25CM0wsR0FBRzJMLFVBQVUsR0FBRyxJQUFJLENBQUN4TSxTQUFTLENBQUN3TSxVQUFVLENBQUNGLE9BQU9FLFVBQVU7WUFDL0Q7WUFDQTtnQkFBQzthQUFPLENBQUNsUixPQUFPLENBQUMsQ0FBQ3dJO2dCQUNkLElBQUl3SSxNQUFNLENBQUN4SSxJQUFJLElBQUksTUFBTTtvQkFDckI7Z0JBQ0o7Z0JBQ0FqRCxFQUFFLENBQUNpRCxJQUFJLEdBQUdqTSxRQUFRRCxPQUFPLENBQUMwVSxNQUFNLENBQUN4SSxJQUFJLEVBQUV4TCxJQUFJLENBQUMsQ0FBQ2lVLElBQU9BLElBQUlwVCw2REFBT0EsQ0FBQ29ULEtBQUs7WUFDekU7WUFDQSxPQUFPLElBQUksQ0FBQ3ZNLFNBQVMsQ0FBQ3lNLGtCQUFrQixDQUFDLE9BQU01Uyw0RUFBaUJBLENBQUNnSCxHQUFFO1FBQ3ZFO0lBQ0o7SUFDQTZMLFdBQVduUCxNQUFNLEVBQUU7UUFDZixPQUFPbEcsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQ2tHLFNBQVMsTUFBTUE7WUFDZixNQUFNbkYsU0FBUyxDQUFDO1lBQ2hCLElBQUltRixPQUFPakIsT0FBTyxJQUFJLE1BQU07Z0JBQ3hCbEUsT0FBT2tFLE9BQU8sR0FBRyxJQUFJLENBQUM2RSxXQUFXLENBQUM1RCxPQUFPakIsT0FBTztZQUNwRDtZQUNBO2dCQUFDO2dCQUFhO2FBQVMsQ0FBQ2hCLE9BQU8sQ0FBQyxDQUFDd0k7Z0JBQzdCLElBQUl2RyxNQUFNLENBQUN1RyxJQUFJLElBQUksTUFBTTtvQkFDckI7Z0JBQ0o7Z0JBQ0ExTCxNQUFNLENBQUMwTCxJQUFJLEdBQUd2RyxNQUFNLENBQUN1RyxJQUFJO1lBQzdCO1lBQ0E7Z0JBQUM7Z0JBQWE7YUFBVSxDQUFDeEksT0FBTyxDQUFDLENBQUN3STtnQkFDOUIsSUFBSXZHLE1BQU0sQ0FBQ3VHLElBQUksSUFBSSxNQUFNO29CQUNyQjtnQkFDSjtnQkFDQTFMLE1BQU0sQ0FBQzBMLElBQUksR0FBRyxJQUFJLENBQUMwSCxZQUFZLENBQUNqTyxNQUFNLENBQUN1RyxJQUFJO1lBQy9DO1lBQ0EsT0FBTyxJQUFJLENBQUM5RCxTQUFTLENBQUN6QyxNQUFNLENBQUMsT0FBTTFELDRFQUFpQkEsQ0FBQ3pCLE9BQU07UUFDL0Q7SUFDSjtJQUNBdVUsTUFBTTFMLFdBQVcsRUFBRXFLLFFBQVEsRUFBRXNCLE9BQU8sRUFBRTtRQUNsQyxPQUFPdlYsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJdVYsV0FBV3BTLG9CQUFvQjtnQkFDL0JGLE9BQU8wRyxVQUFVLENBQUMsMkNBQTJDNUcseURBQU1BLENBQUNvRyxNQUFNLENBQUM2RixZQUFZLEVBQUU7b0JBQ3JGd0csV0FBV0Q7b0JBQVMzTDtnQkFDeEI7WUFDSjtZQUNBLE1BQU02TCxXQUFXN0wsWUFBWWIsRUFBRTtZQUMvQixNQUFNaEksU0FBUyxNQUFNLElBQUksQ0FBQzJPLE9BQU8sQ0FBQyxRQUFRO2dCQUFFOUY7Z0JBQWFxSztZQUFTO1lBQ2xFLDRFQUE0RTtZQUM1RSxJQUFJc0IsV0FBVyxLQUFLdEIsYUFBYSxZQUFZd0IsWUFBWSxRQUFRMVUsT0FBTzJHLFNBQVMsQ0FBQyxHQUFHLFFBQVEsZ0JBQWlCOUYsbUVBQWFBLENBQUNiLFVBQVUsT0FBTyxHQUFJO2dCQUM3SSxJQUFJO29CQUNBLE1BQU15RCxPQUFPM0Msa0VBQVlBLENBQUNkLFFBQVE7b0JBQ2xDLGlFQUFpRTtvQkFDakUsTUFBTXVOLFNBQVN6TSxrRUFBWUEsQ0FBQzJDLE1BQU0sR0FBRztvQkFDckMsSUFBSSxDQUFDaEQsK0RBQVNBLENBQUNtRixJQUFJLENBQUMySCxRQUFRdEYsRUFBRSxDQUFDeU0sV0FBVzt3QkFDdEN4UyxPQUFPMEcsVUFBVSxDQUFDLGtDQUFrQzVHLHlEQUFNQSxDQUFDb0csTUFBTSxDQUFDQyxjQUFjLEVBQUU7NEJBQzlFWCxNQUFNOzRCQUNOaU4sV0FBVzs0QkFDWDlMOzRCQUFhcEYsTUFBTXpEO3dCQUN2QjtvQkFDSjtvQkFDQSxrQ0FBa0M7b0JBQ2xDLE1BQU1zTixPQUFPLEVBQUU7b0JBQ2YsTUFBTXNILGFBQWFuVSwrREFBU0EsQ0FBQ21GLElBQUksQ0FBQzlFLGtFQUFZQSxDQUFDMkMsTUFBTSxJQUFJLEtBQUs4QyxRQUFRO29CQUN0RSxNQUFNc08sYUFBYXBVLCtEQUFTQSxDQUFDbUYsSUFBSSxDQUFDOUUsa0VBQVlBLENBQUMyQyxNQUFNbVIsWUFBWUEsYUFBYSxLQUFLck8sUUFBUTtvQkFDM0YsTUFBTXVPLFdBQVdoVSxrRUFBWUEsQ0FBQzJDLE1BQU1tUixhQUFhO29CQUNqRCxJQUFLLElBQUlHLElBQUksR0FBR0EsSUFBSUYsWUFBWUUsSUFBSzt3QkFDakMsTUFBTTVLLE1BQU1qRSxhQUFhNE8sVUFBVUMsSUFBSTt3QkFDdkMsSUFBSTVLLE9BQU8sTUFBTTs0QkFDYmpJLE9BQU8wRyxVQUFVLENBQUMsMENBQTBDNUcseURBQU1BLENBQUNvRyxNQUFNLENBQUNDLGNBQWMsRUFBRTtnQ0FDdEZYLE1BQU07Z0NBQ05pTixXQUFXO2dDQUNYOUw7Z0NBQWFwRixNQUFNekQ7NEJBQ3ZCO3dCQUNKO3dCQUNBc04sS0FBSy9GLElBQUksQ0FBQzRDO29CQUNkO29CQUNBLG1DQUFtQztvQkFDbkMsTUFBTWtELFdBQVdqSCxZQUFZM0MsTUFBTTtvQkFDbkMsb0NBQW9DO29CQUNwQyxJQUFJLENBQUNoRCwrREFBU0EsQ0FBQ21GLElBQUksQ0FBQzlFLGtFQUFZQSxDQUFDMkMsTUFBTSxLQUFLLE1BQU1pSCxNQUFNLElBQUk7d0JBQ3hEeEksT0FBTzBHLFVBQVUsQ0FBQyw2Q0FBNkM1Ryx5REFBTUEsQ0FBQ29HLE1BQU0sQ0FBQ0MsY0FBYyxFQUFFOzRCQUN6RlgsTUFBTTs0QkFDTmlOLFdBQVc7NEJBQ1g5TDs0QkFBYXBGLE1BQU16RDt3QkFDdkI7b0JBQ0o7b0JBQ0EsTUFBTWdWLG1CQUFtQmxVLGtFQUFZQSxDQUFDMkMsTUFBTSxJQUFJO29CQUNoRCw2REFBNkQ7b0JBQzdELE1BQU13UixZQUFZN08sWUFBWTNDLE1BQU07b0JBQ3BDLE1BQU15UixhQUFhLE1BQU0sSUFBSSxDQUFDOUgsYUFBYSxDQUFDdkUsYUFBYXdFLFVBQVVDO29CQUNuRSxJQUFJNEgsY0FBYyxNQUFNO3dCQUNwQmhULE9BQU8wRyxVQUFVLENBQUMsMENBQTBDNUcseURBQU1BLENBQUNvRyxNQUFNLENBQUNDLGNBQWMsRUFBRTs0QkFDdEZYLE1BQU07NEJBQ05pTixXQUFXOzRCQUNYOUw7NEJBQWFwRixNQUFNekQ7d0JBQ3ZCO29CQUNKO29CQUNBLE1BQU15SSxLQUFLO3dCQUNQVCxJQUFJME07d0JBQ0pqUixNQUFNN0MsK0RBQVNBLENBQUM7NEJBQUNvVTs0QkFBa0I3TixZQUFZO2dDQUFDK047Z0NBQVlEOzZCQUFVO3lCQUFFO29CQUM1RTtvQkFDQSxPQUFPLElBQUksQ0FBQ1YsS0FBSyxDQUFDOUwsSUFBSXlLLFVBQVVzQixVQUFVO2dCQUM5QyxFQUNBLE9BQU9uTyxPQUFPO29CQUNWLElBQUlBLE1BQU04QixJQUFJLEtBQUtuRyx5REFBTUEsQ0FBQ29HLE1BQU0sQ0FBQzZGLFlBQVksRUFBRTt3QkFDM0MsTUFBTTVIO29CQUNWO2dCQUNKO1lBQ0o7WUFDQSxJQUFJO2dCQUNBLE9BQU90Riw2REFBT0EsQ0FBQ2Y7WUFDbkIsRUFDQSxPQUFPcUcsT0FBTztnQkFDVixPQUFPbkUsT0FBTzBHLFVBQVUsQ0FBQywyQkFBMkI1Ryx5REFBTUEsQ0FBQ29HLE1BQU0sQ0FBQzZGLFlBQVksRUFBRTtvQkFDNUU4RSxRQUFRO29CQUNSSSxRQUFRO3dCQUFFdEs7d0JBQWFxSztvQkFBUztvQkFBR2xUO29CQUFRcUc7Z0JBQy9DO1lBQ0o7UUFDSjtJQUNKO0lBQ0EwQixLQUFLYyxXQUFXLEVBQUVxSyxRQUFRLEVBQUU7UUFDeEIsT0FBT2pVLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsTUFBTSxJQUFJLENBQUNxQyxVQUFVO1lBQ3JCLE1BQU02VCxXQUFXLE1BQU0xVCw0RUFBaUJBLENBQUM7Z0JBQ3JDb0gsYUFBYSxJQUFJLENBQUNvTCxzQkFBc0IsQ0FBQ3BMO2dCQUN6Q3FLLFVBQVUsSUFBSSxDQUFDRSxZQUFZLENBQUNGO2dCQUM1QnhLLGlCQUFpQmpKLFFBQVFELE9BQU8sQ0FBQ3FKLFlBQVlILGVBQWU7WUFDaEU7WUFDQSxPQUFPLElBQUksQ0FBQzZMLEtBQUssQ0FBQ1ksU0FBU3RNLFdBQVcsRUFBRXNNLFNBQVNqQyxRQUFRLEVBQUVpQyxTQUFTek0sZUFBZSxHQUFHLElBQUksQ0FBQztRQUMvRjtJQUNKO0lBQ0EwTSxZQUFZdk0sV0FBVyxFQUFFO1FBQ3JCLE9BQU81SixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLE1BQU0sSUFBSSxDQUFDcUMsVUFBVTtZQUNyQixNQUFNNlIsU0FBUyxNQUFNMVIsNEVBQWlCQSxDQUFDO2dCQUNuQ29ILGFBQWEsSUFBSSxDQUFDb0wsc0JBQXNCLENBQUNwTDtZQUM3QztZQUNBLE1BQU03SSxTQUFTLE1BQU0sSUFBSSxDQUFDMk8sT0FBTyxDQUFDLGVBQWV3RTtZQUNqRCxJQUFJO2dCQUNBLE9BQU8xUywrREFBU0EsQ0FBQ21GLElBQUksQ0FBQzVGO1lBQzFCLEVBQ0EsT0FBT3FHLE9BQU87Z0JBQ1YsT0FBT25FLE9BQU8wRyxVQUFVLENBQUMsMkJBQTJCNUcseURBQU1BLENBQUNvRyxNQUFNLENBQUM2RixZQUFZLEVBQUU7b0JBQzVFOEUsUUFBUTtvQkFDUkk7b0JBQVFuVDtvQkFBUXFHO2dCQUNwQjtZQUNKO1FBQ0o7SUFDSjtJQUNBMEMsWUFBWWtLLGFBQWEsRUFBRTtRQUN2QixPQUFPaFUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQ2dVLGdCQUFnQixNQUFNQTtZQUN0QixJQUFJLE9BQVFBLGtCQUFtQixVQUFVO2dCQUNyQy9RLE9BQU9LLGtCQUFrQixDQUFDLCtCQUErQixRQUFRMFE7WUFDckU7WUFDQSxNQUFNL08sVUFBVSxNQUFNLElBQUksQ0FBQ21SLFdBQVcsQ0FBQ3BDO1lBQ3ZDLElBQUkvTyxXQUFXLE1BQU07Z0JBQ2pCaEMsT0FBTzBHLFVBQVUsQ0FBQywyQkFBMkI1Ryx5REFBTUEsQ0FBQ29HLE1BQU0sQ0FBQ2dCLHFCQUFxQixFQUFFO29CQUM5RUMsV0FBVyxDQUFDLFlBQVksRUFBRTBCLEtBQUtDLFNBQVMsQ0FBQ2lJLGVBQWUsQ0FBQyxDQUFDO2dCQUM5RDtZQUNKO1lBQ0EsT0FBTy9PO1FBQ1g7SUFDSjtJQUNBb1IsVUFBVUMsbUJBQW1CLEVBQUVDLG1CQUFtQixFQUFFO1FBQ2hELE9BQU92VyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLE1BQU0sSUFBSSxDQUFDcUMsVUFBVTtZQUNyQmlVLHNCQUFzQixNQUFNQTtZQUM1Qix3RUFBd0U7WUFDeEUsSUFBSS9HLGNBQWMsQ0FBQztZQUNuQixNQUFNMkUsU0FBUztnQkFDWHFDLHFCQUFxQixDQUFDLENBQUNBO1lBQzNCO1lBQ0EsSUFBSXRVLGlFQUFXQSxDQUFDcVUscUJBQXFCLEtBQUs7Z0JBQ3RDcEMsT0FBT3JELFNBQVMsR0FBR3lGO1lBQ3ZCLE9BQ0s7Z0JBQ0QsSUFBSTtvQkFDQXBDLE9BQU9ELFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQ0UsWUFBWSxDQUFDbUM7b0JBQzFDLElBQUlyVSxpRUFBV0EsQ0FBQ2lTLE9BQU9ELFFBQVEsR0FBRzt3QkFDOUIxRSxjQUFjakYsU0FBUzRKLE9BQU9ELFFBQVEsQ0FBQ3ZNLFNBQVMsQ0FBQyxJQUFJO29CQUN6RDtnQkFDSixFQUNBLE9BQU9OLE9BQU87b0JBQ1ZuRSxPQUFPSyxrQkFBa0IsQ0FBQyxtQ0FBbUMsdUJBQXVCZ1Q7Z0JBQ3hGO1lBQ0o7WUFDQSxPQUFPelQseURBQUlBLENBQUMsSUFBTTdDLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7b0JBQzlDLE1BQU1pTixRQUFRLE1BQU0sSUFBSSxDQUFDeUMsT0FBTyxDQUFDLFlBQVl3RTtvQkFDN0Msc0JBQXNCO29CQUN0QixJQUFJakgsU0FBUyxNQUFNO3dCQUNmLG1FQUFtRTt3QkFDbkUsa0VBQWtFO3dCQUNsRSxzREFBc0Q7d0JBQ3RELElBQUlpSCxPQUFPckQsU0FBUyxJQUFJLE1BQU07NEJBQzFCLElBQUksSUFBSSxDQUFDN0QsUUFBUSxDQUFDLE9BQU9rSCxPQUFPckQsU0FBUyxDQUFDLElBQUksTUFBTTtnQ0FDaEQsT0FBTzs0QkFDWDt3QkFDSjt3QkFDQSxzRUFBc0U7d0JBQ3RFLElBQUlxRCxPQUFPRCxRQUFRLElBQUksTUFBTTs0QkFDekIsSUFBSTFFLGNBQWMsSUFBSSxDQUFDdkMsUUFBUSxDQUFDQyxLQUFLLEVBQUU7Z0NBQ25DLE9BQU87NEJBQ1g7d0JBQ0o7d0JBQ0EsMEJBQTBCO3dCQUMxQixPQUFPaUI7b0JBQ1g7b0JBQ0EsbUJBQW1CO29CQUNuQixJQUFJcUkscUJBQXFCO3dCQUNyQixJQUFJaEgsY0FBYzt3QkFDbEIsSUFBSyxJQUFJbEgsSUFBSSxHQUFHQSxJQUFJNEUsTUFBTWtHLFlBQVksQ0FBQ3hQLE1BQU0sRUFBRTBFLElBQUs7NEJBQ2hELE1BQU1tQixLQUFLeUQsTUFBTWtHLFlBQVksQ0FBQzlLLEVBQUU7NEJBQ2hDLElBQUltQixHQUFHK0YsV0FBVyxJQUFJLE1BQU07Z0NBQ3hCL0YsR0FBR3VJLGFBQWEsR0FBRzs0QkFDdkIsT0FDSyxJQUFJdkksR0FBR3VJLGFBQWEsSUFBSSxNQUFNO2dDQUMvQixJQUFJeEMsZUFBZSxNQUFNO29DQUNyQkEsY0FBYyxNQUFNLElBQUksQ0FBQ0wsdUJBQXVCLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQ2EsZUFBZTtnQ0FDbkY7Z0NBQ0Esa0VBQWtFO2dDQUNsRSxJQUFJZ0MsZ0JBQWdCLGNBQWV2SSxHQUFHK0YsV0FBVyxHQUFJO2dDQUNyRCxJQUFJd0MsaUJBQWlCLEdBQUc7b0NBQ3BCQSxnQkFBZ0I7Z0NBQ3BCO2dDQUNBdkksR0FBR3VJLGFBQWEsR0FBR0E7NEJBQ3ZCO3dCQUNKO3dCQUNBLE1BQU15RSxlQUFlLElBQUksQ0FBQzdOLFNBQVMsQ0FBQzhOLHFCQUFxQixDQUFDeEo7d0JBQzFEdUosYUFBYXJELFlBQVksR0FBR3FELGFBQWFyRCxZQUFZLENBQUN0UCxHQUFHLENBQUMsQ0FBQzJGLEtBQU8sSUFBSSxDQUFDZ0ssZ0JBQWdCLENBQUNoSzt3QkFDeEYsT0FBT2dOO29CQUNYO29CQUNBLE9BQU8sSUFBSSxDQUFDN04sU0FBUyxDQUFDc0UsS0FBSyxDQUFDQTtnQkFDaEMsSUFBSTtnQkFBRXlKLFVBQVUsSUFBSTtZQUFDO1FBQ3pCO0lBQ0o7SUFDQUMsU0FBU0wsbUJBQW1CLEVBQUU7UUFDMUIsT0FBUSxJQUFJLENBQUNELFNBQVMsQ0FBQ0MscUJBQXFCO0lBQ2hEO0lBQ0FyRCx5QkFBeUJxRCxtQkFBbUIsRUFBRTtRQUMxQyxPQUFRLElBQUksQ0FBQ0QsU0FBUyxDQUFDQyxxQkFBcUI7SUFDaEQ7SUFDQXRELGVBQWVsQyxlQUFlLEVBQUU7UUFDNUIsT0FBTzlRLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsTUFBTSxJQUFJLENBQUNxQyxVQUFVO1lBQ3JCeU8sa0JBQWtCLE1BQU1BO1lBQ3hCLE1BQU1vRCxTQUFTO2dCQUFFcEQsaUJBQWlCLElBQUksQ0FBQ25JLFNBQVMsQ0FBQzFDLElBQUksQ0FBQzZLLGlCQUFpQjtZQUFNO1lBQzdFLE9BQU9qTyx5REFBSUEsQ0FBQyxJQUFNN0MsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztvQkFDOUMsTUFBTWUsU0FBUyxNQUFNLElBQUksQ0FBQzJPLE9BQU8sQ0FBQyxrQkFBa0J3RTtvQkFDcEQsSUFBSW5ULFVBQVUsTUFBTTt3QkFDaEIsSUFBSSxJQUFJLENBQUNpTSxRQUFRLENBQUMsT0FBTzhELGdCQUFnQixJQUFJLE1BQU07NEJBQy9DLE9BQU87d0JBQ1g7d0JBQ0EsT0FBTzVDO29CQUNYO29CQUNBLE1BQU0xRSxLQUFLLElBQUksQ0FBQ2IsU0FBUyxDQUFDaU8sbUJBQW1CLENBQUM3VjtvQkFDOUMsSUFBSXlJLEdBQUcrRixXQUFXLElBQUksTUFBTTt3QkFDeEIvRixHQUFHdUksYUFBYSxHQUFHO29CQUN2QixPQUNLLElBQUl2SSxHQUFHdUksYUFBYSxJQUFJLE1BQU07d0JBQy9CLE1BQU14QyxjQUFjLE1BQU0sSUFBSSxDQUFDTCx1QkFBdUIsQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDYSxlQUFlO3dCQUNyRixrRUFBa0U7d0JBQ2xFLElBQUlnQyxnQkFBZ0IsY0FBZXZJLEdBQUcrRixXQUFXLEdBQUk7d0JBQ3JELElBQUl3QyxpQkFBaUIsR0FBRzs0QkFDcEJBLGdCQUFnQjt3QkFDcEI7d0JBQ0F2SSxHQUFHdUksYUFBYSxHQUFHQTtvQkFDdkI7b0JBQ0EsT0FBTyxJQUFJLENBQUN5QixnQkFBZ0IsQ0FBQ2hLO2dCQUNqQyxJQUFJO2dCQUFFa04sVUFBVSxJQUFJO1lBQUM7UUFDekI7SUFDSjtJQUNBckcsc0JBQXNCUyxlQUFlLEVBQUU7UUFDbkMsT0FBTzlRLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsTUFBTSxJQUFJLENBQUNxQyxVQUFVO1lBQ3JCeU8sa0JBQWtCLE1BQU1BO1lBQ3hCLE1BQU1vRCxTQUFTO2dCQUFFcEQsaUJBQWlCLElBQUksQ0FBQ25JLFNBQVMsQ0FBQzFDLElBQUksQ0FBQzZLLGlCQUFpQjtZQUFNO1lBQzdFLE9BQU9qTyx5REFBSUEsQ0FBQyxJQUFNN0MsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztvQkFDOUMsTUFBTWUsU0FBUyxNQUFNLElBQUksQ0FBQzJPLE9BQU8sQ0FBQyx5QkFBeUJ3RTtvQkFDM0QsSUFBSW5ULFVBQVUsTUFBTTt3QkFDaEIsSUFBSSxJQUFJLENBQUNpTSxRQUFRLENBQUMsT0FBTzhELGdCQUFnQixJQUFJLE1BQU07NEJBQy9DLE9BQU87d0JBQ1g7d0JBQ0EsT0FBTzVDO29CQUNYO29CQUNBLG9EQUFvRDtvQkFDcEQsSUFBSW5OLE9BQU84UCxTQUFTLElBQUksTUFBTTt3QkFDMUIsT0FBTzNDO29CQUNYO29CQUNBLE1BQU1vQyxVQUFVLElBQUksQ0FBQzNILFNBQVMsQ0FBQzJILE9BQU8sQ0FBQ3ZQO29CQUN2QyxJQUFJdVAsUUFBUWYsV0FBVyxJQUFJLE1BQU07d0JBQzdCZSxRQUFReUIsYUFBYSxHQUFHO29CQUM1QixPQUNLLElBQUl6QixRQUFReUIsYUFBYSxJQUFJLE1BQU07d0JBQ3BDLE1BQU14QyxjQUFjLE1BQU0sSUFBSSxDQUFDTCx1QkFBdUIsQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDYSxlQUFlO3dCQUNyRixrRUFBa0U7d0JBQ2xFLElBQUlnQyxnQkFBZ0IsY0FBZXpCLFFBQVFmLFdBQVcsR0FBSTt3QkFDMUQsSUFBSXdDLGlCQUFpQixHQUFHOzRCQUNwQkEsZ0JBQWdCO3dCQUNwQjt3QkFDQXpCLFFBQVF5QixhQUFhLEdBQUdBO29CQUM1QjtvQkFDQSxPQUFPekI7Z0JBQ1gsSUFBSTtnQkFBRW9HLFVBQVUsSUFBSTtZQUFDO1FBQ3pCO0lBQ0o7SUFDQWhHLFFBQVF4SyxNQUFNLEVBQUU7UUFDWixPQUFPbEcsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxNQUFNLElBQUksQ0FBQ3FDLFVBQVU7WUFDckIsTUFBTTZSLFNBQVMsTUFBTTFSLDRFQUFpQkEsQ0FBQztnQkFBRTBELFFBQVEsSUFBSSxDQUFDbVAsVUFBVSxDQUFDblA7WUFBUTtZQUN6RSxNQUFNeUssT0FBTyxNQUFNLElBQUksQ0FBQ2pCLE9BQU8sQ0FBQyxXQUFXd0U7WUFDM0N2RCxLQUFLMU0sT0FBTyxDQUFDLENBQUMyTTtnQkFDVixJQUFJQSxJQUFJaUcsT0FBTyxJQUFJLE1BQU07b0JBQ3JCakcsSUFBSWlHLE9BQU8sR0FBRztnQkFDbEI7WUFDSjtZQUNBLE9BQU8zVCxrREFBU0EsQ0FBQzRULE9BQU8sQ0FBQyxJQUFJLENBQUNuTyxTQUFTLENBQUNvTyxTQUFTLENBQUNDLElBQUksQ0FBQyxJQUFJLENBQUNyTyxTQUFTLEdBQUdnSTtRQUM1RTtJQUNKO0lBQ0FzRyxnQkFBZ0I7UUFDWixPQUFPalgsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxNQUFNLElBQUksQ0FBQ3FDLFVBQVU7WUFDckIsT0FBTyxJQUFJLENBQUNxTixPQUFPLENBQUMsaUJBQWlCLENBQUM7UUFDMUM7SUFDSjtJQUNBeUUsYUFBYUYsUUFBUSxFQUFFO1FBQ25CLE9BQU9qVSxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DaVUsV0FBVyxNQUFNQTtZQUNqQixJQUFJLE9BQVFBLGFBQWMsWUFBWUEsV0FBVyxHQUFHO2dCQUNoRCxJQUFJQSxXQUFXLEdBQUc7b0JBQ2RoUixPQUFPSyxrQkFBa0IsQ0FBQyxvQkFBb0IsWUFBWTJRO2dCQUM5RDtnQkFDQSxJQUFJMUUsY0FBYyxNQUFNLElBQUksQ0FBQ0wsdUJBQXVCLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQ2EsZUFBZTtnQkFDbkZSLGVBQWUwRTtnQkFDZixJQUFJMUUsY0FBYyxHQUFHO29CQUNqQkEsY0FBYztnQkFDbEI7Z0JBQ0EsT0FBTyxJQUFJLENBQUM1RyxTQUFTLENBQUNzTCxRQUFRLENBQUMxRTtZQUNuQztZQUNBLE9BQU8sSUFBSSxDQUFDNUcsU0FBUyxDQUFDc0wsUUFBUSxDQUFDQTtRQUNuQztJQUNKO0lBQ0FpRCxZQUFZek8sSUFBSSxFQUFFO1FBQ2QsT0FBT3pJLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSW1YLGNBQWMxTztZQUNsQixNQUFPLEtBQU07Z0JBQ1QsSUFBSTBPLGdCQUFnQixNQUFNQSxnQkFBZ0IsS0FBSztvQkFDM0MsT0FBTztnQkFDWDtnQkFDQSx5REFBeUQ7Z0JBQ3pELCtCQUErQjtnQkFDL0IsSUFBSTFPLFNBQVMsU0FBUzBPLGdCQUFnQixPQUFPO29CQUN6QyxPQUFPO2dCQUNYO2dCQUNBLHdDQUF3QztnQkFDeEMsTUFBTTlMLE9BQU8sTUFBTSxJQUFJLENBQUMrTCxZQUFZLENBQUNELGFBQWE7Z0JBQ2xELG9CQUFvQjtnQkFDcEIsSUFBSTlMLFFBQVEsTUFBTTtvQkFDZCxNQUFNZ00sV0FBVyxJQUFJOU8sU0FBUyxJQUFJLEVBQUU4QyxNQUFNNUM7b0JBQzFDLGdFQUFnRTtvQkFDaEUsSUFBSTBPLGdCQUFnQjFPLFFBQVEsQ0FBRSxPQUFNNE8sU0FBU3pPLGdCQUFnQixFQUFDLEdBQUk7d0JBQzlELE9BQU87b0JBQ1g7b0JBQ0EsT0FBT3lPO2dCQUNYO2dCQUNBLHNCQUFzQjtnQkFDdEJGLGNBQWNBLFlBQVkxUyxLQUFLLENBQUMsS0FBS2YsS0FBSyxDQUFDLEdBQUdZLElBQUksQ0FBQztZQUN2RDtRQUNKO0lBQ0o7SUFDQThTLGFBQWEzTyxJQUFJLEVBQUUyQixTQUFTLEVBQUU7UUFDMUIsT0FBT3BLLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSW9LLGFBQWEsTUFBTTtnQkFDbkJBLFlBQVk7WUFDaEI7WUFDQSxNQUFNMEMsVUFBVSxNQUFNLElBQUksQ0FBQ3pLLFVBQVU7WUFDckMsWUFBWTtZQUNaLElBQUksQ0FBQ3lLLFFBQVF3SyxVQUFVLEVBQUU7Z0JBQ3JCclUsT0FBTzBHLFVBQVUsQ0FBQyxnQ0FBZ0M1Ryx5REFBTUEsQ0FBQ29HLE1BQU0sQ0FBQ2dCLHFCQUFxQixFQUFFO29CQUFFQztvQkFBVzBDLFNBQVNBLFFBQVFyRSxJQUFJO2dCQUFDO1lBQzlIO1lBQ0EsSUFBSTtnQkFDQSxpQ0FBaUM7Z0JBQ2pDLE1BQU04TyxXQUFXLE1BQU0sSUFBSSxDQUFDek8sSUFBSSxDQUFDO29CQUM3QkMsSUFBSStELFFBQVF3SyxVQUFVO29CQUN0QjlTLE1BQU8sZUFBZXBDLDhEQUFRQSxDQUFDcUcsTUFBTWYsU0FBUyxDQUFDO2dCQUNuRDtnQkFDQSxPQUFPLElBQUksQ0FBQ2lCLFNBQVMsQ0FBQ2dDLFdBQVcsQ0FBQzRNO1lBQ3RDLEVBQ0EsT0FBT25RLE9BQU87WUFDVix3REFBd0Q7WUFDNUQ7WUFDQSxPQUFPO1FBQ1g7SUFDSjtJQUNBZ1AsWUFBWTNOLElBQUksRUFBRTtRQUNkLE9BQU96SSxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DeUksT0FBTyxNQUFNQTtZQUNiLGtEQUFrRDtZQUNsRCxJQUFJO2dCQUNBLE9BQU9qSSxRQUFRRCxPQUFPLENBQUMsSUFBSSxDQUFDb0ksU0FBUyxDQUFDMUQsT0FBTyxDQUFDd0Q7WUFDbEQsRUFDQSxPQUFPckIsT0FBTztnQkFDVixzREFBc0Q7Z0JBQ3RELElBQUluRixpRUFBV0EsQ0FBQ3dHLE9BQU87b0JBQ25CLE1BQU1yQjtnQkFDVjtZQUNKO1lBQ0EsSUFBSSxPQUFRcUIsU0FBVSxVQUFVO2dCQUM1QnhGLE9BQU9LLGtCQUFrQixDQUFDLG9CQUFvQixRQUFRbUY7WUFDMUQ7WUFDQSxpQ0FBaUM7WUFDakMsTUFBTTRPLFdBQVcsTUFBTSxJQUFJLENBQUNILFdBQVcsQ0FBQ3pPO1lBQ3hDLElBQUksQ0FBQzRPLFVBQVU7Z0JBQ1gsT0FBTztZQUNYO1lBQ0EsT0FBTyxNQUFNQSxTQUFTM00sVUFBVTtRQUNwQztJQUNKO0lBQ0E4TSxjQUFjdlMsT0FBTyxFQUFFO1FBQ25CLE9BQU9qRixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DaUYsVUFBVSxNQUFNQTtZQUNoQkEsVUFBVSxJQUFJLENBQUMwRCxTQUFTLENBQUMxRCxPQUFPLENBQUNBO1lBQ2pDLE1BQU13UyxPQUFPeFMsUUFBUXlDLFNBQVMsQ0FBQyxHQUFHbkUsV0FBVyxLQUFLO1lBQ2xELE1BQU1tVSxlQUFlLE1BQU0sSUFBSSxDQUFDTixZQUFZLENBQUNLLE1BQU07WUFDbkQsSUFBSUMsZ0JBQWdCLE1BQU07Z0JBQ3RCLE9BQU87WUFDWDtZQUNBLDBCQUEwQjtZQUMxQixNQUFNalAsT0FBT3hCLGFBQWEsT0FBTSxJQUFJLENBQUM2QixJQUFJLENBQUM7Z0JBQ3RDQyxJQUFJMk87Z0JBQ0psVCxNQUFPLGVBQWVwQyw4REFBUUEsQ0FBQ3FWLE1BQU0vUCxTQUFTLENBQUM7WUFDbkQsRUFBQyxHQUFHO1lBQ0osTUFBTTJELE9BQU8sTUFBTSxJQUFJLENBQUMrSyxXQUFXLENBQUMzTjtZQUNwQyxJQUFJNEMsUUFBUXBHLFNBQVM7Z0JBQ2pCLE9BQU87WUFDWDtZQUNBLE9BQU93RDtRQUNYO0lBQ0o7SUFDQW1DLFVBQVUrTSxhQUFhLEVBQUU7UUFDckIsT0FBTzNYLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXFYLFdBQVc7WUFDZixJQUFJcFYsaUVBQVdBLENBQUMwVixnQkFBZ0I7Z0JBQzVCLDBCQUEwQjtnQkFDMUIsTUFBTTFTLFVBQVUsSUFBSSxDQUFDMEQsU0FBUyxDQUFDMUQsT0FBTyxDQUFDMFM7Z0JBQ3ZDLE1BQU1GLE9BQU94UyxRQUFReUMsU0FBUyxDQUFDLEdBQUduRSxXQUFXLEtBQUs7Z0JBQ2xELE1BQU1xVSxrQkFBa0IsTUFBTSxJQUFJLENBQUNSLFlBQVksQ0FBQ0ssTUFBTTtnQkFDdEQsSUFBSSxDQUFDRyxpQkFBaUI7b0JBQ2xCLE9BQU87Z0JBQ1g7Z0JBQ0EsNkRBQTZEO2dCQUM3RFAsV0FBVyxJQUFJOU8sU0FBUyxJQUFJLEVBQUVxUCxpQkFBaUJIO2dCQUMvQyxJQUFJO29CQUNBLE1BQU0xTSxTQUFTLE1BQU1zTSxTQUFTek0sU0FBUztvQkFDdkMsSUFBSUcsUUFBUTt3QkFDUixPQUFPQSxPQUFPRyxHQUFHO29CQUNyQjtnQkFDSixFQUNBLE9BQU85RCxPQUFPO29CQUNWLElBQUlBLE1BQU04QixJQUFJLEtBQUtuRyx5REFBTUEsQ0FBQ29HLE1BQU0sQ0FBQ0MsY0FBYyxFQUFFO3dCQUM3QyxNQUFNaEM7b0JBQ1Y7Z0JBQ0o7Z0JBQ0EseUVBQXlFO2dCQUN6RSxJQUFJO29CQUNBLDBCQUEwQjtvQkFDMUIsTUFBTXFCLE9BQU94QixhQUFhLE9BQU0sSUFBSSxDQUFDNkIsSUFBSSxDQUFDO3dCQUN0Q0MsSUFBSTZPO3dCQUNKcFQsTUFBTyxlQUFlcEMsOERBQVFBLENBQUNxVixNQUFNL1AsU0FBUyxDQUFDO29CQUNuRCxFQUFDLEdBQUc7b0JBQ0oyUCxXQUFXLE1BQU0sSUFBSSxDQUFDSCxXQUFXLENBQUN6TztnQkFDdEMsRUFDQSxPQUFPckIsT0FBTztvQkFDVixJQUFJQSxNQUFNOEIsSUFBSSxLQUFLbkcseURBQU1BLENBQUNvRyxNQUFNLENBQUNDLGNBQWMsRUFBRTt3QkFDN0MsTUFBTWhDO29CQUNWO29CQUNBLE9BQU87Z0JBQ1g7WUFDSixPQUNLO2dCQUNELHlDQUF5QztnQkFDekNpUSxXQUFXLE1BQU0sSUFBSSxDQUFDSCxXQUFXLENBQUNTO2dCQUNsQyxJQUFJLENBQUNOLFVBQVU7b0JBQ1gsT0FBTztnQkFDWDtZQUNKO1lBQ0EsTUFBTXRNLFNBQVMsTUFBTXNNLFNBQVN6TSxTQUFTO1lBQ3ZDLElBQUlHLFVBQVUsTUFBTTtnQkFDaEIsT0FBTztZQUNYO1lBQ0EsT0FBT0EsT0FBT0csR0FBRztRQUNyQjtJQUNKO0lBQ0F3RSxRQUFRb0UsTUFBTSxFQUFFSSxNQUFNLEVBQUU7UUFDcEIsT0FBT2pSLE9BQU8wRyxVQUFVLENBQUNtSyxTQUFTLG9CQUFvQi9RLHlEQUFNQSxDQUFDb0csTUFBTSxDQUFDME8sZUFBZSxFQUFFO1lBQUV6TixXQUFXMEo7UUFBTztJQUM3RztJQUNBZ0UsWUFBWS9SLEtBQUssRUFBRTtRQUNmLElBQUksQ0FBQ2tMLE9BQU8sR0FBSSxJQUFJLENBQUNsRSxPQUFPLENBQUM3RyxNQUFNLENBQUMsQ0FBQ3JGLElBQU1BLEVBQUVzRixRQUFRLElBQUl4QyxNQUFNLEdBQUc7SUFDdEU7SUFDQW9VLFdBQVdoUyxLQUFLLEVBQUU7UUFDZCxJQUFJLENBQUNrTCxPQUFPLEdBQUksSUFBSSxDQUFDbEUsT0FBTyxDQUFDN0csTUFBTSxDQUFDLENBQUNyRixJQUFNQSxFQUFFc0YsUUFBUSxJQUFJeEMsTUFBTSxHQUFHO0lBQ3RFO0lBQ0FxVSxrQkFBa0JwVCxTQUFTLEVBQUVlLFFBQVEsRUFBRUMsSUFBSSxFQUFFO1FBQ3pDLE1BQU1HLFFBQVEsSUFBSVAsTUFBTWIsWUFBWUMsWUFBWWUsVUFBVUM7UUFDMUQsSUFBSSxDQUFDbUgsT0FBTyxDQUFDekUsSUFBSSxDQUFDdkM7UUFDbEIsSUFBSSxDQUFDK1IsV0FBVyxDQUFDL1I7UUFDakIsT0FBTyxJQUFJO0lBQ2Y7SUFDQXdNLEdBQUczTixTQUFTLEVBQUVlLFFBQVEsRUFBRTtRQUNwQixPQUFPLElBQUksQ0FBQ3FTLGlCQUFpQixDQUFDcFQsV0FBV2UsVUFBVTtJQUN2RDtJQUNBQyxLQUFLaEIsU0FBUyxFQUFFZSxRQUFRLEVBQUU7UUFDdEIsT0FBTyxJQUFJLENBQUNxUyxpQkFBaUIsQ0FBQ3BULFdBQVdlLFVBQVU7SUFDdkQ7SUFDQThILEtBQUs3SSxTQUFTLEVBQUUsR0FBR3FULElBQUksRUFBRTtRQUNyQixJQUFJbFgsU0FBUztRQUNiLElBQUltWCxVQUFVLEVBQUU7UUFDaEIsSUFBSUMsV0FBV3hULFlBQVlDO1FBQzNCLElBQUksQ0FBQ21JLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU8sQ0FBQzdHLE1BQU0sQ0FBQyxDQUFDSDtZQUNoQyxJQUFJQSxNQUFNTCxHQUFHLEtBQUt5UyxVQUFVO2dCQUN4QixPQUFPO1lBQ1g7WUFDQTdTLFdBQVc7Z0JBQ1BTLE1BQU1KLFFBQVEsQ0FBQ3pFLEtBQUssQ0FBQyxJQUFJLEVBQUUrVztZQUMvQixHQUFHO1lBQ0hsWCxTQUFTO1lBQ1QsSUFBSWdGLE1BQU1ILElBQUksRUFBRTtnQkFDWnNTLFFBQVE1UCxJQUFJLENBQUN2QztnQkFDYixPQUFPO1lBQ1g7WUFDQSxPQUFPO1FBQ1g7UUFDQW1TLFFBQVFqVSxPQUFPLENBQUMsQ0FBQzhCO1lBQVksSUFBSSxDQUFDZ1MsVUFBVSxDQUFDaFM7UUFBUTtRQUNyRCxPQUFPaEY7SUFDWDtJQUNBcVgsY0FBY3hULFNBQVMsRUFBRTtRQUNyQixJQUFJLENBQUNBLFdBQVc7WUFDWixPQUFPLElBQUksQ0FBQ21JLE9BQU8sQ0FBQ3BKLE1BQU07UUFDOUI7UUFDQSxJQUFJd1UsV0FBV3hULFlBQVlDO1FBQzNCLE9BQU8sSUFBSSxDQUFDbUksT0FBTyxDQUFDN0csTUFBTSxDQUFDLENBQUNIO1lBQ3hCLE9BQVFBLE1BQU1MLEdBQUcsS0FBS3lTO1FBQzFCLEdBQUd4VSxNQUFNO0lBQ2I7SUFDQTBVLFVBQVV6VCxTQUFTLEVBQUU7UUFDakIsSUFBSUEsYUFBYSxNQUFNO1lBQ25CLE9BQU8sSUFBSSxDQUFDbUksT0FBTyxDQUFDbEosR0FBRyxDQUFDLENBQUNrQyxRQUFVQSxNQUFNSixRQUFRO1FBQ3JEO1FBQ0EsSUFBSXdTLFdBQVd4VCxZQUFZQztRQUMzQixPQUFPLElBQUksQ0FBQ21JLE9BQU8sQ0FDZDdHLE1BQU0sQ0FBQyxDQUFDSCxRQUFXQSxNQUFNTCxHQUFHLEtBQUt5UyxVQUNqQ3RVLEdBQUcsQ0FBQyxDQUFDa0MsUUFBVUEsTUFBTUosUUFBUTtJQUN0QztJQUNBMlMsSUFBSTFULFNBQVMsRUFBRWUsUUFBUSxFQUFFO1FBQ3JCLElBQUlBLFlBQVksTUFBTTtZQUNsQixPQUFPLElBQUksQ0FBQzRTLGtCQUFrQixDQUFDM1Q7UUFDbkM7UUFDQSxNQUFNc1QsVUFBVSxFQUFFO1FBQ2xCLElBQUlNLFFBQVE7UUFDWixJQUFJTCxXQUFXeFQsWUFBWUM7UUFDM0IsSUFBSSxDQUFDbUksT0FBTyxHQUFHLElBQUksQ0FBQ0EsT0FBTyxDQUFDN0csTUFBTSxDQUFDLENBQUNIO1lBQ2hDLElBQUlBLE1BQU1MLEdBQUcsS0FBS3lTLFlBQVlwUyxNQUFNSixRQUFRLElBQUlBLFVBQVU7Z0JBQ3RELE9BQU87WUFDWDtZQUNBLElBQUk2UyxPQUFPO2dCQUNQLE9BQU87WUFDWDtZQUNBQSxRQUFRO1lBQ1JOLFFBQVE1UCxJQUFJLENBQUN2QztZQUNiLE9BQU87UUFDWDtRQUNBbVMsUUFBUWpVLE9BQU8sQ0FBQyxDQUFDOEI7WUFBWSxJQUFJLENBQUNnUyxVQUFVLENBQUNoUztRQUFRO1FBQ3JELE9BQU8sSUFBSTtJQUNmO0lBQ0F3UyxtQkFBbUIzVCxTQUFTLEVBQUU7UUFDMUIsSUFBSXNULFVBQVUsRUFBRTtRQUNoQixJQUFJdFQsYUFBYSxNQUFNO1lBQ25Cc1QsVUFBVSxJQUFJLENBQUNuTCxPQUFPO1lBQ3RCLElBQUksQ0FBQ0EsT0FBTyxHQUFHLEVBQUU7UUFDckIsT0FDSztZQUNELE1BQU1vTCxXQUFXeFQsWUFBWUM7WUFDN0IsSUFBSSxDQUFDbUksT0FBTyxHQUFHLElBQUksQ0FBQ0EsT0FBTyxDQUFDN0csTUFBTSxDQUFDLENBQUNIO2dCQUNoQyxJQUFJQSxNQUFNTCxHQUFHLEtBQUt5UyxVQUFVO29CQUN4QixPQUFPO2dCQUNYO2dCQUNBRCxRQUFRNVAsSUFBSSxDQUFDdkM7Z0JBQ2IsT0FBTztZQUNYO1FBQ0o7UUFDQW1TLFFBQVFqVSxPQUFPLENBQUMsQ0FBQzhCO1lBQVksSUFBSSxDQUFDZ1MsVUFBVSxDQUFDaFM7UUFBUTtRQUNyRCxPQUFPLElBQUk7SUFDZjtBQUNKLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1zdGFydGVyLWtpdC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9iYXNlLXByb3ZpZGVyLmpzPzRiYTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IEZvcmtFdmVudCwgUHJvdmlkZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXJcIjtcbmltcG9ydCB7IGVuY29kZSBhcyBiYXNlNjRFbmNvZGUgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmFzZTY0XCI7XG5pbXBvcnQgeyBCYXNlNTggfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmFzZXhcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBjb25jYXQsIGhleENvbmNhdCwgaGV4RGF0YUxlbmd0aCwgaGV4RGF0YVNsaWNlLCBoZXhsaWZ5LCBoZXhWYWx1ZSwgaGV4WmVyb1BhZCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IEhhc2haZXJvIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZG5zRW5jb2RlLCBuYW1laGFzaCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9oYXNoXCI7XG5pbXBvcnQgeyBnZXROZXR3b3JrIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L25ldHdvcmtzXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSwgZ2V0U3RhdGljLCByZXNvbHZlUHJvcGVydGllcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc2hhMlwiO1xuaW1wb3J0IHsgdG9VdGY4Qnl0ZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5pbXBvcnQgeyBmZXRjaEpzb24sIHBvbGwgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvd2ViXCI7XG5pbXBvcnQgYmVjaDMyIGZyb20gXCJiZWNoMzJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IEZvcm1hdHRlciB9IGZyb20gXCIuL2Zvcm1hdHRlclwiO1xuY29uc3QgTUFYX0NDSVBfUkVESVJFQ1RTID0gMTA7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEV2ZW50IFNlcmlhbGl6ZWluZ1xuZnVuY3Rpb24gY2hlY2tUb3BpYyh0b3BpYykge1xuICAgIGlmICh0b3BpYyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG4gICAgaWYgKGhleERhdGFMZW5ndGgodG9waWMpICE9PSAzMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0b3BpY1wiLCBcInRvcGljXCIsIHRvcGljKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvcGljLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVUb3BpY3ModG9waWNzKSB7XG4gICAgLy8gUmVtb3ZlIHRyYWlsaW5nIG51bGwgQU5ELXRvcGljczsgdGhleSBhcmUgcmVkdW5kYW50XG4gICAgdG9waWNzID0gdG9waWNzLnNsaWNlKCk7XG4gICAgd2hpbGUgKHRvcGljcy5sZW5ndGggPiAwICYmIHRvcGljc1t0b3BpY3MubGVuZ3RoIC0gMV0gPT0gbnVsbCkge1xuICAgICAgICB0b3BpY3MucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiB0b3BpY3MubWFwKCh0b3BpYykgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0b3BpYykpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgdHJhY2sgdW5pcXVlIE9SLXRvcGljc1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlID0ge307XG4gICAgICAgICAgICB0b3BpYy5mb3JFYWNoKCh0b3BpYykgPT4ge1xuICAgICAgICAgICAgICAgIHVuaXF1ZVtjaGVja1RvcGljKHRvcGljKV0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBUaGUgb3JkZXIgb2YgT1ItdG9waWNzIGRvZXMgbm90IG1hdHRlclxuICAgICAgICAgICAgY29uc3Qgc29ydGVkID0gT2JqZWN0LmtleXModW5pcXVlKTtcbiAgICAgICAgICAgIHNvcnRlZC5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4gc29ydGVkLmpvaW4oXCJ8XCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrVG9waWModG9waWMpO1xuICAgICAgICB9XG4gICAgfSkuam9pbihcIiZcIik7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVRvcGljcyhkYXRhKSB7XG4gICAgaWYgKGRhdGEgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS5zcGxpdCgvJi9nKS5tYXAoKHRvcGljKSA9PiB7XG4gICAgICAgIGlmICh0b3BpYyA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdG9waWMuc3BsaXQoXCJ8XCIpLm1hcCgodG9waWMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoKHRvcGljID09PSBcIm51bGxcIikgPyBudWxsIDogdG9waWMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgoY29tcHMubGVuZ3RoID09PSAxKSA/IGNvbXBzWzBdIDogY29tcHMpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKSB7XG4gICAgaWYgKHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGhleERhdGFMZW5ndGgoZXZlbnROYW1lKSA9PT0gMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBcInR4OlwiICsgZXZlbnROYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudE5hbWUuaW5kZXhPZihcIjpcIikgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnROYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnROYW1lKSkge1xuICAgICAgICByZXR1cm4gXCJmaWx0ZXI6KjpcIiArIHNlcmlhbGl6ZVRvcGljcyhldmVudE5hbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChGb3JrRXZlbnQuaXNGb3JrRXZlbnQoZXZlbnROYW1lKSkge1xuICAgICAgICBsb2dnZXIud2FybihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudE5hbWUgJiYgdHlwZW9mIChldmVudE5hbWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBcImZpbHRlcjpcIiArIChldmVudE5hbWUuYWRkcmVzcyB8fCBcIipcIikgKyBcIjpcIiArIHNlcmlhbGl6ZVRvcGljcyhldmVudE5hbWUudG9waWNzIHx8IFtdKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBldmVudCAtIFwiICsgZXZlbnROYW1lKTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSGVscGVyIE9iamVjdFxuZnVuY3Rpb24gZ2V0VGltZSgpIHtcbiAgICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbn1cbmZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pO1xuICAgIH0pO1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBQcm92aWRlciBPYmplY3Rcbi8qKlxuICogIEV2ZW50VHlwZVxuICogICAtIFwiYmxvY2tcIlxuICogICAtIFwicG9sbFwiXG4gKiAgIC0gXCJkaWRQb2xsXCJcbiAqICAgLSBcInBlbmRpbmdcIlxuICogICAtIFwiZXJyb3JcIlxuICogICAtIFwibmV0d29ya1wiXG4gKiAgIC0gZmlsdGVyXG4gKiAgIC0gdG9waWNzIGFycmF5XG4gKiAgIC0gdHJhbnNhY3Rpb24gaGFzaFxuICovXG5jb25zdCBQb2xsYWJsZUV2ZW50cyA9IFtcImJsb2NrXCIsIFwibmV0d29ya1wiLCBcInBlbmRpbmdcIiwgXCJwb2xsXCJdO1xuZXhwb3J0IGNsYXNzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcsIGxpc3RlbmVyLCBvbmNlKSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwidGFnXCIsIHRhZyk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwibGlzdGVuZXJcIiwgbGlzdGVuZXIpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIm9uY2VcIiwgb25jZSk7XG4gICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IC0yO1xuICAgICAgICB0aGlzLl9pbmZsaWdodCA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZXZlbnQoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidHhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNoO1xuICAgICAgICAgICAgY2FzZSBcImZpbHRlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50YWc7XG4gICAgfVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcuc3BsaXQoXCI6XCIpWzBdO1xuICAgIH1cbiAgICBnZXQgaGFzaCgpIHtcbiAgICAgICAgY29uc3QgY29tcHMgPSB0aGlzLnRhZy5zcGxpdChcIjpcIik7XG4gICAgICAgIGlmIChjb21wc1swXSAhPT0gXCJ0eFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcHNbMV07XG4gICAgfVxuICAgIGdldCBmaWx0ZXIoKSB7XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50YWcuc3BsaXQoXCI6XCIpO1xuICAgICAgICBpZiAoY29tcHNbMF0gIT09IFwiZmlsdGVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBjb21wc1sxXTtcbiAgICAgICAgY29uc3QgdG9waWNzID0gZGVzZXJpYWxpemVUb3BpY3MoY29tcHNbMl0pO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7fTtcbiAgICAgICAgaWYgKHRvcGljcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmaWx0ZXIudG9waWNzID0gdG9waWNzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRyZXNzICYmIGFkZHJlc3MgIT09IFwiKlwiKSB7XG4gICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICB9XG4gICAgcG9sbGFibGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50YWcuaW5kZXhPZihcIjpcIikgPj0gMCB8fCBQb2xsYWJsZUV2ZW50cy5pbmRleE9mKHRoaXMudGFnKSA+PSAwKTtcbiAgICB9XG59XG47XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2F0b3NoaWxhYnMvc2xpcHMvYmxvYi9tYXN0ZXIvc2xpcC0wMDQ0Lm1kXG5jb25zdCBjb2luSW5mb3MgPSB7XG4gICAgXCIwXCI6IHsgc3ltYm9sOiBcImJ0Y1wiLCBwMnBraDogMHgwMCwgcDJzaDogMHgwNSwgcHJlZml4OiBcImJjXCIgfSxcbiAgICBcIjJcIjogeyBzeW1ib2w6IFwibHRjXCIsIHAycGtoOiAweDMwLCBwMnNoOiAweDMyLCBwcmVmaXg6IFwibHRjXCIgfSxcbiAgICBcIjNcIjogeyBzeW1ib2w6IFwiZG9nZVwiLCBwMnBraDogMHgxZSwgcDJzaDogMHgxNiB9LFxuICAgIFwiNjBcIjogeyBzeW1ib2w6IFwiZXRoXCIsIGlsazogXCJldGhcIiB9LFxuICAgIFwiNjFcIjogeyBzeW1ib2w6IFwiZXRjXCIsIGlsazogXCJldGhcIiB9LFxuICAgIFwiNzAwXCI6IHsgc3ltYm9sOiBcInhkYWlcIiwgaWxrOiBcImV0aFwiIH0sXG59O1xuZnVuY3Rpb24gYnl0ZXMzMmlmeSh2YWx1ZSkge1xuICAgIHJldHVybiBoZXhaZXJvUGFkKEJpZ051bWJlci5mcm9tKHZhbHVlKS50b0hleFN0cmluZygpLCAzMik7XG59XG4vLyBDb21wdXRlIHRoZSBCYXNlNThDaGVjayBlbmNvZGVkIGRhdGEgKGNoZWNrc3VtIGlzIGZpcnN0IDQgYnl0ZXMgb2Ygc2hhMjU2ZClcbmZ1bmN0aW9uIGJhc2U1OEVuY29kZShkYXRhKSB7XG4gICAgcmV0dXJuIEJhc2U1OC5lbmNvZGUoY29uY2F0KFtkYXRhLCBoZXhEYXRhU2xpY2Uoc2hhMjU2KHNoYTI1NihkYXRhKSksIDAsIDQpXSkpO1xufVxuY29uc3QgbWF0Y2hlcklwZnMgPSBuZXcgUmVnRXhwKFwiXihpcGZzKTovXFwvKC4qKSRcIiwgXCJpXCIpO1xuY29uc3QgbWF0Y2hlcnMgPSBbXG4gICAgbmV3IFJlZ0V4cChcIl4oaHR0cHMpOi9cXC8oLiopJFwiLCBcImlcIiksXG4gICAgbmV3IFJlZ0V4cChcIl4oZGF0YSk6KC4qKSRcIiwgXCJpXCIpLFxuICAgIG1hdGNoZXJJcGZzLFxuICAgIG5ldyBSZWdFeHAoXCJeZWlwMTU1OlswLTldKy8oZXJjWzAtOV0rKTooLiopJFwiLCBcImlcIiksXG5dO1xuZnVuY3Rpb24gX3BhcnNlU3RyaW5nKHJlc3VsdCwgc3RhcnQpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdG9VdGY4U3RyaW5nKF9wYXJzZUJ5dGVzKHJlc3VsdCwgc3RhcnQpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIF9wYXJzZUJ5dGVzKHJlc3VsdCwgc3RhcnQpIHtcbiAgICBpZiAocmVzdWx0ID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNldCA9IEJpZ051bWJlci5mcm9tKGhleERhdGFTbGljZShyZXN1bHQsIHN0YXJ0LCBzdGFydCArIDMyKSkudG9OdW1iZXIoKTtcbiAgICBjb25zdCBsZW5ndGggPSBCaWdOdW1iZXIuZnJvbShoZXhEYXRhU2xpY2UocmVzdWx0LCBvZmZzZXQsIG9mZnNldCArIDMyKSkudG9OdW1iZXIoKTtcbiAgICByZXR1cm4gaGV4RGF0YVNsaWNlKHJlc3VsdCwgb2Zmc2V0ICsgMzIsIG9mZnNldCArIDMyICsgbGVuZ3RoKTtcbn1cbi8vIFRyaW0gb2ZmIHRoZSBpcGZzOi8vIHByZWZpeCBhbmQgcmV0dXJuIHRoZSBkZWZhdWx0IGdhdGV3YXkgVVJMXG5mdW5jdGlvbiBnZXRJcGZzTGluayhsaW5rKSB7XG4gICAgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcL2lwZnNcXC8vaSkpIHtcbiAgICAgICAgbGluayA9IGxpbmsuc3Vic3RyaW5nKDEyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGluay5tYXRjaCgvXmlwZnM6XFwvXFwvL2kpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZyg3KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBJUEZTIGZvcm1hdFwiLCBcImxpbmtcIiwgbGluayk7XG4gICAgfVxuICAgIHJldHVybiBgaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzLyR7bGlua31gO1xufVxuZnVuY3Rpb24gbnVtUGFkKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXJyYXlpZnkodmFsdWUpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJuYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgcGFkZGVkLnNldChyZXN1bHQsIDMyIC0gcmVzdWx0Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHBhZGRlZDtcbn1cbmZ1bmN0aW9uIGJ5dGVzUGFkKHZhbHVlKSB7XG4gICAgaWYgKCh2YWx1ZS5sZW5ndGggJSAzMikgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwodmFsdWUubGVuZ3RoIC8gMzIpICogMzIpO1xuICAgIHJlc3VsdC5zZXQodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBBQkkgRW5jb2RlcyBhIHNlcmllcyBvZiAoYnl0ZXMsIGJ5dGVzLCAuLi4pXG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhkYXRhcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBieXRlQ291bnQgPSAwO1xuICAgIC8vIEFkZCBwbGFjZS1ob2xkZXJzIGZvciBwb2ludGVycyBhcyB3ZSBhZGQgaXRlbXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICBieXRlQ291bnQgKz0gMzI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGFycmF5aWZ5KGRhdGFzW2ldKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBieXRlcyBvZmZzZXRcbiAgICAgICAgcmVzdWx0W2ldID0gbnVtUGFkKGJ5dGVDb3VudCk7XG4gICAgICAgIC8vIFRoZSBsZW5ndGggYW5kIHBhZGRlZCB2YWx1ZSBvZiBkYXRhXG4gICAgICAgIHJlc3VsdC5wdXNoKG51bVBhZChkYXRhLmxlbmd0aCkpO1xuICAgICAgICByZXN1bHQucHVzaChieXRlc1BhZChkYXRhKSk7XG4gICAgICAgIGJ5dGVDb3VudCArPSAzMiArIE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIDMyKSAqIDMyO1xuICAgIH1cbiAgICByZXR1cm4gaGV4Q29uY2F0KHJlc3VsdCk7XG59XG5leHBvcnQgY2xhc3MgUmVzb2x2ZXIge1xuICAgIC8vIFRoZSByZXNvbHZlZEFkZHJlc3MgaXMgb25seSBmb3IgY3JlYXRpbmcgYSBSZXZlcnNlTG9va3VwIHJlc29sdmVyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUsIHJlc29sdmVkQWRkcmVzcykge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFkZHJlc3NcIiwgcHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoYWRkcmVzcykpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9yZXNvbHZlZEFkZHJlc3NcIiwgcmVzb2x2ZWRBZGRyZXNzKTtcbiAgICB9XG4gICAgc3VwcG9ydHNXaWxkY2FyZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdXBwb3J0c0VpcDI1NDQpIHtcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzSW50ZXJmYWNlKGJ5dGVzNCA9IHNlbGVjdG9yKFwicmVzb2x2ZShieXRlcyxieXRlcylcIikpXG4gICAgICAgICAgICB0aGlzLl9zdXBwb3J0c0VpcDI1NDQgPSB0aGlzLnByb3ZpZGVyLmNhbGwoe1xuICAgICAgICAgICAgICAgIHRvOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZGF0YTogXCIweDAxZmZjOWE3OTA2MWI5MjMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiXG4gICAgICAgICAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KS5lcSgxKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmV0aHJvdyB0aGUgZXJyb3I6IGxpbmsgaXMgZG93biwgZXRjLiBMZXQgZnV0dXJlIGF0dGVtcHRzIHJldHJ5LlxuICAgICAgICAgICAgICAgIHRoaXMuX3N1cHBvcnRzRWlwMjU0NCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3VwcG9ydHNFaXAyNTQ0O1xuICAgIH1cbiAgICBfZmV0Y2goc2VsZWN0b3IsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIGUuZy4ga2VjY2FrMjU2KFwiYWRkcihieXRlczMyLHVpbnQyNTYpXCIpXG4gICAgICAgICAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgICAgICAgICB0bzogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIGNjaXBSZWFkRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBoZXhDb25jYXQoW3NlbGVjdG9yLCBuYW1laGFzaCh0aGlzLm5hbWUpLCAocGFyYW1ldGVycyB8fCBcIjB4XCIpXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBXaWxkY2FyZCBzdXBwb3J0OyB1c2UgRUlQLTI1NDQgdG8gcmVzb2x2ZSB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgbGV0IHBhcnNlQnl0ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh5aWVsZCB0aGlzLnN1cHBvcnRzV2lsZGNhcmQoKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlQnl0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIHNlbGVjdG9yKFwicmVzb2x2ZShieXRlcyxieXRlcylcIilcbiAgICAgICAgICAgICAgICB0eC5kYXRhID0gaGV4Q29uY2F0KFtcIjB4OTA2MWI5MjNcIiwgZW5jb2RlQnl0ZXMoW2Ruc0VuY29kZSh0aGlzLm5hbWUpLCB0eC5kYXRhXSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHlpZWxkIHRoaXMucHJvdmlkZXIuY2FsbCh0eCk7XG4gICAgICAgICAgICAgICAgaWYgKChhcnJheWlmeShyZXN1bHQpLmxlbmd0aCAlIDMyKSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInJlc29sdmVyIHRocmV3IGVycm9yXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCwgZGF0YTogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VCeXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfcGFyc2VCeXRlcyhyZXN1bHQsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2ZldGNoQnl0ZXMoc2VsZWN0b3IsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMuX2ZldGNoKHNlbGVjdG9yLCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcGFyc2VCeXRlcyhyZXN1bHQsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0QWRkcmVzcyhjb2luVHlwZSwgaGV4Qnl0ZXMpIHtcbiAgICAgICAgY29uc3QgY29pbkluZm8gPSBjb2luSW5mb3NbU3RyaW5nKGNvaW5UeXBlKV07XG4gICAgICAgIGlmIChjb2luSW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihgdW5zdXBwb3J0ZWQgY29pbiB0eXBlOiAke2NvaW5UeXBlfWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBgZ2V0QWRkcmVzcygke2NvaW5UeXBlfSlgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29pbkluZm8uaWxrID09PSBcImV0aFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhoZXhCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeShoZXhCeXRlcyk7XG4gICAgICAgIC8vIFAyUEtIOiBPUF9EVVAgT1BfSEFTSDE2MCA8cHViS2V5SGFzaD4gT1BfRVFVQUxWRVJJRlkgT1BfQ0hFQ0tTSUdcbiAgICAgICAgaWYgKGNvaW5JbmZvLnAycGtoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHAycGtoID0gaGV4Qnl0ZXMubWF0Y2goL14weDc2YTkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKTg4YWMkLyk7XG4gICAgICAgICAgICBpZiAocDJwa2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChwMnBraFsxXSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChwMnBraFsyXS5sZW5ndGggPT09IGxlbmd0aCAqIDIgJiYgbGVuZ3RoID49IDEgJiYgbGVuZ3RoIDw9IDc1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNThFbmNvZGUoY29uY2F0KFtbY29pbkluZm8ucDJwa2hdLCAoXCIweFwiICsgcDJwa2hbMl0pXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQMlNIOiBPUF9IQVNIMTYwIDxzY3JpcHRIYXNoPiBPUF9FUVVBTFxuICAgICAgICBpZiAoY29pbkluZm8ucDJzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBwMnNoID0gaGV4Qnl0ZXMubWF0Y2goL14weGE5KFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKik4NyQvKTtcbiAgICAgICAgICAgIGlmIChwMnNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQocDJzaFsxXSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChwMnNoWzJdLmxlbmd0aCA9PT0gbGVuZ3RoICogMiAmJiBsZW5ndGggPj0gMSAmJiBsZW5ndGggPD0gNzUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U1OEVuY29kZShjb25jYXQoW1tjb2luSW5mby5wMnNoXSwgKFwiMHhcIiArIHAyc2hbMl0pXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBCZWNoMzJcbiAgICAgICAgaWYgKGNvaW5JbmZvLnByZWZpeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBieXRlc1sxXTtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAxNDEubWVkaWF3aWtpI3dpdG5lc3MtcHJvZ3JhbVxuICAgICAgICAgICAgbGV0IHZlcnNpb24gPSBieXRlc1swXTtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAweDAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCAhPT0gMjAgJiYgbGVuZ3RoICE9PSAzMikge1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZlcnNpb24gPj0gMCAmJiBieXRlcy5sZW5ndGggPT09IDIgKyBsZW5ndGggJiYgbGVuZ3RoID49IDEgJiYgbGVuZ3RoIDw9IDc1KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd29yZHMgPSBiZWNoMzIudG9Xb3JkcyhieXRlcy5zbGljZSgyKSk7XG4gICAgICAgICAgICAgICAgd29yZHMudW5zaGlmdCh2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVjaDMyLmVuY29kZShjb2luSW5mby5wcmVmaXgsIHdvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0QWRkcmVzcyhjb2luVHlwZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGNvaW5UeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb2luVHlwZSA9IDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgRXRoZXJldW0sIHVzZSB0aGUgc3RhbmRhcmQgYGFkZHIoYnl0ZXMzMilgXG4gICAgICAgICAgICBpZiAoY29pblR5cGUgPT09IDYwKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VjY2FrMjU2KFwiYWRkcihieXRlczMyKVwiKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLl9mZXRjaChcIjB4M2IzYjU3ZGVcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gXCIweFwiIHx8IHJlc3VsdCA9PT0gSGFzaFplcm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5jYWxsQWRkcmVzcyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGtlY2NhazI1NihcImFkZHIoYnl0ZXMzMix1aW50MjU2XCIpXG4gICAgICAgICAgICBjb25zdCBoZXhCeXRlcyA9IHlpZWxkIHRoaXMuX2ZldGNoQnl0ZXMoXCIweGYxY2I3ZTA2XCIsIGJ5dGVzMzJpZnkoY29pblR5cGUpKTtcbiAgICAgICAgICAgIC8vIE5vIGFkZHJlc3NcbiAgICAgICAgICAgIGlmIChoZXhCeXRlcyA9PSBudWxsIHx8IGhleEJ5dGVzID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGFkZHJlc3NcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLl9nZXRBZGRyZXNzKGNvaW5UeXBlLCBoZXhCeXRlcyk7XG4gICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoYGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgY29pbiBkYXRhYCwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBgZ2V0QWRkcmVzcygke2NvaW5UeXBlfSlgLFxuICAgICAgICAgICAgICAgICAgICBjb2luVHlwZTogY29pblR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGhleEJ5dGVzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEF2YXRhcigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmthZ2UgPSBbeyB0eXBlOiBcIm5hbWVcIiwgY29udGVudDogdGhpcy5uYW1lIH1dO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyB0ZXN0IGRhdGEgZm9yIHJpY21vby5ldGhcbiAgICAgICAgICAgICAgICAvL2NvbnN0IGF2YXRhciA9IFwiZWlwMTU1OjEvZXJjNzIxOjB4MjY1Mzg1YzdmNDEzMjIyOEEwZDU0RUIxQTllNzQ2MGI5MWMwY0M2OC8yOTIzM1wiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF2YXRhciA9IHlpZWxkIHRoaXMuZ2V0VGV4dChcImF2YXRhclwiKTtcbiAgICAgICAgICAgICAgICBpZiAoYXZhdGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBhdmF0YXIubWF0Y2gobWF0Y2hlcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzY2hlbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJodHRwc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIGNvbnRlbnQ6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGF2YXRhciB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImRhdGFcIiwgY29udGVudDogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogYXZhdGFyIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaXBmc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiaXBmc1wiLCBjb250ZW50OiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBnZXRJcGZzTGluayhhdmF0YXIpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJjNzIxXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJjMTE1NVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBFUkMgdHlwZSwgdXNlIHRva2VuVVJJKHVpbnQyNTYpIG9yIHVybCh1aW50MjU2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKHNjaGVtZSA9PT0gXCJlcmM3MjFcIikgPyBcIjB4Yzg3YjU2ZGRcIiA6IFwiMHgwZTg5MzQxY1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IHNjaGVtZSwgY29udGVudDogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvd25lciBvZiB0aGlzIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvd25lciA9ICh0aGlzLl9yZXNvbHZlZEFkZHJlc3MgfHwgKHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcHMgPSAobWF0Y2hbMl0gfHwgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZHIgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGNvbXBzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbklkID0gaGV4WmVyb1BhZChCaWdOdW1iZXIuZnJvbShjb21wc1sxXSkudG9IZXhTdHJpbmcoKSwgMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhpcyBhY2NvdW50IG93bnMgdGhlIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJlcmM3MjFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvd25lck9mKHVpbnQyNTYgdG9rZW5JZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5Pd25lciA9IHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmNhbGxBZGRyZXNzKHlpZWxkIHRoaXMucHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogYWRkciwgZGF0YTogaGV4Q29uY2F0KFtcIjB4NjM1MjIxMWVcIiwgdG9rZW5JZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG93bmVyICE9PSB0b2tlbk93bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm93bmVyXCIsIGNvbnRlbnQ6IHRva2VuT3duZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtZSA9PT0gXCJlcmMxMTU1XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFsYW5jZU9mKGFkZHJlc3Mgb3duZXIsIHVpbnQyNTYgdG9rZW5JZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IEJpZ051bWJlci5mcm9tKHlpZWxkIHRoaXMucHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogYWRkciwgZGF0YTogaGV4Q29uY2F0KFtcIjB4MDBmZGQ1OGVcIiwgaGV4WmVyb1BhZChvd25lciwgMzIpLCB0b2tlbklkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFsYW5jZS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJiYWxhbmNlXCIsIGNvbnRlbnQ6IGJhbGFuY2UudG9TdHJpbmcoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgdG9rZW4gY29udHJhY3QgZm9yIHRoZSBtZXRhZGF0YSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoY29tcHNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBoZXhDb25jYXQoW3NlbGVjdG9yLCB0b2tlbklkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YVVybCA9IF9wYXJzZVN0cmluZyh5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwodHgpLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmwtYmFzZVwiLCBjb250ZW50OiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFUkMtMTE1NSBhbGxvd3MgYSBnZW5lcmljIHtpZH0gaW4gdGhlIFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVXJsID0gbWV0YWRhdGFVcmwucmVwbGFjZShcIntpZH1cIiwgdG9rZW5JZC5zdWJzdHJpbmcoMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybC1leHBhbmRlZFwiLCBjb250ZW50OiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElQRlMgbWV0YWRhdGEgbGlua3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwubWF0Y2goL15pcGZzOi9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVVybCA9IGdldElwZnNMaW5rKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmxcIiwgY29udGVudDogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0b2tlbiBtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0geWllbGQgZmV0Y2hKc29uKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhXCIsIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQdWxsIHRoZSBpbWFnZSBVUkwgb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlVXJsID0gbWV0YWRhdGEuaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaW1hZ2VVcmwpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VVcmwubWF0Y2goL14oaHR0cHM6XFwvXFwvfGRhdGE6KS9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElQRlMgbGluayB0byBnYXRld2F5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlwZnMgPSBpbWFnZVVybC5tYXRjaChtYXRjaGVySXBmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcGZzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsLWlwZnNcIiwgY29udGVudDogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVXJsID0gZ2V0SXBmc0xpbmsoaW1hZ2VVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCBjb250ZW50OiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGltYWdlVXJsIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb250ZW50SGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIGtlY2NhazI1NihcImNvbnRlbnRoYXNoKClcIilcbiAgICAgICAgICAgIGNvbnN0IGhleEJ5dGVzID0geWllbGQgdGhpcy5fZmV0Y2hCeXRlcyhcIjB4YmMxYzU4ZDFcIik7XG4gICAgICAgICAgICAvLyBObyBjb250ZW50aGFzaFxuICAgICAgICAgICAgaWYgKGhleEJ5dGVzID09IG51bGwgfHwgaGV4Qnl0ZXMgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSVBGUyAoQ0lEOiAxLCBUeXBlOiBEQUctUEIpXG4gICAgICAgICAgICBjb25zdCBpcGZzID0gaGV4Qnl0ZXMubWF0Y2goL14weGUzMDEwMTcwKChbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXSopKSQvKTtcbiAgICAgICAgICAgIGlmIChpcGZzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoaXBmc1szXSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChpcGZzWzRdLmxlbmd0aCA9PT0gbGVuZ3RoICogMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpcGZzOi9cXC9cIiArIEJhc2U1OC5lbmNvZGUoXCIweFwiICsgaXBmc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSVBOUyAoQ0lEOiAxLCBUeXBlOiBsaWJwMnAta2V5KVxuICAgICAgICAgICAgY29uc3QgaXBucyA9IGhleEJ5dGVzLm1hdGNoKC9eMHhlNTAxMDE3MigoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKSkkLyk7XG4gICAgICAgICAgICBpZiAoaXBucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGlwbnNbM10sIDE2KTtcbiAgICAgICAgICAgICAgICBpZiAoaXBuc1s0XS5sZW5ndGggPT09IGxlbmd0aCAqIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaXBuczovXFwvXCIgKyBCYXNlNTguZW5jb2RlKFwiMHhcIiArIGlwbnNbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN3YXJtIChDSUQ6IDEsIFR5cGU6IHN3YXJtLW1hbmlmZXN0OyBoYXNoL2xlbmd0aCBoYXJkLWNvZGVkIHRvIGtlY2NhazI1Ni8zMilcbiAgICAgICAgICAgIGNvbnN0IHN3YXJtID0gaGV4Qnl0ZXMubWF0Y2goL14weGU0MDEwMWZhMDExYjIwKFswLTlhLWZdKikkLyk7XG4gICAgICAgICAgICBpZiAoc3dhcm0pIHtcbiAgICAgICAgICAgICAgICBpZiAoc3dhcm1bMV0ubGVuZ3RoID09PSAoMzIgKiAyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJieno6L1xcL1wiICsgc3dhcm1bMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2t5bmV0ID0gaGV4Qnl0ZXMubWF0Y2goL14weDkwYjJjNjA1KFswLTlhLWZdKikkLyk7XG4gICAgICAgICAgICBpZiAoc2t5bmV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNreW5ldFsxXS5sZW5ndGggPT09ICgzNCAqIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVSTCBTYWZlIGJhc2U2NDsgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM0NjQ4I3NlY3Rpb24tNVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmxTYWZlID0geyBcIj1cIjogXCJcIiwgXCIrXCI6IFwiLVwiLCBcIi9cIjogXCJfXCIgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IGJhc2U2NEVuY29kZShcIjB4XCIgKyBza3luZXRbMV0pLnJlcGxhY2UoL1s9K1xcL10vZywgKGEpID0+ICh1cmxTYWZlW2FdKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInNpYTovXFwvXCIgKyBoYXNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihgaW52YWxpZCBvciB1bnN1cHBvcnRlZCBjb250ZW50IGhhc2ggZGF0YWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldENvbnRlbnRIYXNoKClcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBoZXhCeXRlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRUZXh0KGtleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gVGhlIGtleSBlbmNvZGVkIGFzIHBhcmFtZXRlciB0byBmZXRjaEJ5dGVzXG4gICAgICAgICAgICBsZXQga2V5Qnl0ZXMgPSB0b1V0ZjhCeXRlcyhrZXkpO1xuICAgICAgICAgICAgLy8gVGhlIG5vZGVoYXNoIGNvbnN1bWVzIHRoZSBmaXJzdCBzbG90LCBzbyB0aGUgc3RyaW5nIHBvaW50ZXIgdGFyZ2V0c1xuICAgICAgICAgICAgLy8gb2Zmc2V0IDY0LCB3aXRoIHRoZSBsZW5ndGggYXQgb2Zmc2V0IDY0IGFuZCBkYXRhIHN0YXJ0aW5nIGF0IG9mZnNldCA5NlxuICAgICAgICAgICAga2V5Qnl0ZXMgPSBjb25jYXQoW2J5dGVzMzJpZnkoNjQpLCBieXRlczMyaWZ5KGtleUJ5dGVzLmxlbmd0aCksIGtleUJ5dGVzXSk7XG4gICAgICAgICAgICAvLyBQYWQgdG8gd29yZC1zaXplICgzMiBieXRlcylcbiAgICAgICAgICAgIGlmICgoa2V5Qnl0ZXMubGVuZ3RoICUgMzIpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAga2V5Qnl0ZXMgPSBjb25jYXQoW2tleUJ5dGVzLCBoZXhaZXJvUGFkKFwiMHhcIiwgMzIgLSAoa2V5Lmxlbmd0aCAlIDMyKSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhleEJ5dGVzID0geWllbGQgdGhpcy5fZmV0Y2hCeXRlcyhcIjB4NTlkMWQ0M2NcIiwgaGV4bGlmeShrZXlCeXRlcykpO1xuICAgICAgICAgICAgaWYgKGhleEJ5dGVzID09IG51bGwgfHwgaGV4Qnl0ZXMgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyhoZXhCeXRlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmxldCBkZWZhdWx0Rm9ybWF0dGVyID0gbnVsbDtcbmxldCBuZXh0UG9sbElkID0gMTtcbmV4cG9ydCBjbGFzcyBCYXNlUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogIHJlYWR5XG4gICAgICpcbiAgICAgKiAgQSBQcm9taXNlPE5ldHdvcms+IHRoYXQgcmVzb2x2ZXMgb25seSBvbmNlIHRoZSBwcm92aWRlciBpcyByZWFkeS5cbiAgICAgKlxuICAgICAqICBTdWItY2xhc3NlcyB0aGF0IGNhbGwgdGhlIHN1cGVyIHdpdGggYSBuZXR3b3JrIHdpdGhvdXQgYSBjaGFpbklkXG4gICAgICogIE1VU1Qgc2V0IHRoaXMuIFN0YW5kYXJkIG5hbWVkIG5ldHdvcmtzIGhhdmUgYSBrbm93biBjaGFpbklkLlxuICAgICAqXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmV0d29yaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBFdmVudHMgYmVpbmcgbGlzdGVuZWQgdG9cbiAgICAgICAgdGhpcy5fZXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuX2VtaXR0ZWQgPSB7IGJsb2NrOiAtMiB9O1xuICAgICAgICB0aGlzLmRpc2FibGVDY2lwUmVhZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvcm1hdHRlciA9IG5ldy50YXJnZXQuZ2V0Rm9ybWF0dGVyKCk7XG4gICAgICAgIC8vIElmIG5ldHdvcmsgaXMgYW55LCB0aGlzIFByb3ZpZGVyIGFsbG93cyB0aGUgdW5kZXJseWluZ1xuICAgICAgICAvLyBuZXR3b3JrIHRvIGNoYW5nZSBkeW5hbWljYWxseSwgYW5kIHdlIGF1dG8tZGV0ZWN0IHRoZVxuICAgICAgICAvLyBjdXJyZW50IG5ldHdvcmtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhbnlOZXR3b3JrXCIsIChuZXR3b3JrID09PSBcImFueVwiKSk7XG4gICAgICAgIGlmICh0aGlzLmFueU5ldHdvcmspIHtcbiAgICAgICAgICAgIG5ldHdvcmsgPSB0aGlzLmRldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV0d29yayBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX25ldHdvcmtQcm9taXNlID0gbmV0d29yaztcbiAgICAgICAgICAgIC8vIFNxdWFzaCBhbnkgXCJ1bmhhbmRsZWQgcHJvbWlzZVwiIGVycm9yczsgdGhhdCBkbyBub3QgbmVlZCB0byBiZSBoYW5kbGVkXG4gICAgICAgICAgICBuZXR3b3JrLmNhdGNoKChlcnJvcikgPT4geyB9KTtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgaW5pdGlhbCBuZXR3b3JrIHNldHRpbmcgKGFzeW5jKVxuICAgICAgICAgICAgdGhpcy5fcmVhZHkoKS5jYXRjaCgoZXJyb3IpID0+IHsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrbm93bk5ldHdvcmsgPSBnZXRTdGF0aWMobmV3LnRhcmdldCwgXCJnZXROZXR3b3JrXCIpKG5ldHdvcmspO1xuICAgICAgICAgICAgaWYgKGtub3duTmV0d29yaykge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX25ldHdvcmtcIiwga25vd25OZXR3b3JrKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIGtub3duTmV0d29yaywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyID0gLTEwMjQ7XG4gICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IC0yO1xuICAgICAgICB0aGlzLl9tYXhGaWx0ZXJCbG9ja1JhbmdlID0gMTA7XG4gICAgICAgIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCA9IDQwMDA7XG4gICAgICAgIHRoaXMuX2Zhc3RRdWVyeURhdGUgPSAwO1xuICAgIH1cbiAgICBfcmVhZHkoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ldHdvcmsgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uZXR3b3JrUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29yayA9IHlpZWxkIHRoaXMuX25ldHdvcmtQcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRyeSB0aGUgUHJvdmlkZXIncyBuZXR3b3JrIGRldGVjdGlvbiAodGhpcyBNVVNUIHRocm93IGlmIGl0IGNhbm5vdClcbiAgICAgICAgICAgICAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSB5aWVsZCB0aGlzLmRldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuOyBldmVyeSBQcm92aWRlciBzdWItY2xhc3Mgc2hvdWxkIGhhdmVcbiAgICAgICAgICAgICAgICAvLyBzdWdnZXN0ZWQgYSBuZXR3b3JrIGJ5IGhlcmUgKG9yIGhhdmUgdGhyb3duKS5cbiAgICAgICAgICAgICAgICBpZiAoIW5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJubyBuZXR3b3JrIGRldGVjdGVkXCIsIExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUiwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQb3NzaWJsZSB0aGlzIGNhbGwgc3RhY2tlZCBzbyBkbyBub3QgY2FsbCBkZWZpbmVSZWFkT25seSBhZ2FpblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYW55TmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV0d29yayA9IG5ldHdvcms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9uZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25ldHdvcms7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUaGlzIHdpbGwgYWx3YXlzIHJldHVybiB0aGUgbW9zdCByZWNlbnRseSBlc3RhYmxpc2hlZCBuZXR3b3JrLlxuICAgIC8vIEZvciBcImFueVwiLCB0aGlzIGNhbiBjaGFuZ2UgKGEgXCJuZXR3b3JrXCIgZXZlbnQgaXMgZW1pdHRlZCBiZWZvcmVcbiAgICAvLyBhbnkgY2hhbmdlIGlzIHJlZmxlY3RlZCk7IG90aGVyd2lzZSB0aGlzIGNhbm5vdCBjaGFuZ2VcbiAgICBnZXQgcmVhZHkoKSB7XG4gICAgICAgIHJldHVybiBwb2xsKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkeSgpLnRoZW4oKG5ldHdvcmspID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZXR3b3JrIGlzbid0IHJ1bm5pbmcgeWV0LCB3ZSB3aWxsIHdhaXRcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SICYmIGVycm9yLmV2ZW50ID09PSBcIm5vTmV0d29ya1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgYW5kIGp1c3QgY3JlYXRlIGEgc2luZ2xldG9uIGZvcm1hdHRlclxuICAgIHN0YXRpYyBnZXRGb3JtYXR0ZXIoKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Rm9ybWF0dGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmF1bHRGb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRGb3JtYXR0ZXI7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBSZW1vdmUgdGhpcyBhbmQganVzdCB1c2UgZ2V0TmV0d29ya1xuICAgIHN0YXRpYyBnZXROZXR3b3JrKG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIGdldE5ldHdvcmsoKG5ldHdvcmsgPT0gbnVsbCkgPyBcImhvbWVzdGVhZFwiIDogbmV0d29yayk7XG4gICAgfVxuICAgIGNjaXBSZWFkRmV0Y2godHgsIGNhbGxkYXRhLCB1cmxzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlQ2NpcFJlYWQgfHwgdXJscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlbmRlciA9IHR4LnRvLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY2FsbGRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IHVybHNbaV07XG4gICAgICAgICAgICAgICAgLy8gVVJMIGV4cGFuc2lvblxuICAgICAgICAgICAgICAgIGNvbnN0IGhyZWYgPSB1cmwucmVwbGFjZShcIntzZW5kZXJ9XCIsIHNlbmRlcikucmVwbGFjZShcIntkYXRhfVwiLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBubyB7ZGF0YX0gaXMgcHJlc2VudCwgdXNlIFBPU1Q7IG90aGVyd2lzZSBHRVRcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uID0gKHVybC5pbmRleE9mKFwie2RhdGF9XCIpID49IDApID8gbnVsbCA6IEpTT04uc3RyaW5naWZ5KHsgZGF0YSwgc2VuZGVyIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIGZldGNoSnNvbih7IHVybDogaHJlZiwgZXJyb3JQYXNzVGhyb3VnaDogdHJ1ZSB9LCBqc29uLCAodmFsdWUsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAocmVzdWx0Lm1lc3NhZ2UgfHwgXCJ1bmtub3duIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIC8vIDR4eCBpbmRpY2F0ZXMgdGhlIHJlc3VsdCBpcyBub3QgcHJlc2VudDsgc3RvcFxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID49IDQwMCAmJiByZXN1bHQuc3RhdHVzIDwgNTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihgcmVzcG9uc2Ugbm90IGZvdW5kIGR1cmluZyBDQ0lQIGZldGNoOiAke2Vycm9yTWVzc2FnZX1gLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwgeyB1cmwsIGVycm9yTWVzc2FnZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gNXh4IGluZGljYXRlcyBzZXJ2ZXIgaXNzdWU7IHRyeSB0aGUgbmV4dCB1cmxcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2VzLnB1c2goZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIENDSVAgZmV0Y2g6ICR7ZXJyb3JNZXNzYWdlcy5tYXAoKG0pID0+IEpTT04uc3RyaW5naWZ5KG0pKS5qb2luKFwiLCBcIil9YCwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICB1cmxzLCBlcnJvck1lc3NhZ2VzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEZldGNoZXMgdGhlIGJsb2NrTnVtYmVyLCBidXQgd2lsbCByZXVzZSBhbnkgcmVzdWx0IHRoYXQgaXMgbGVzc1xuICAgIC8vIHRoYW4gbWF4QWdlIG9sZCBvciBoYXMgYmVlbiByZXF1ZXN0ZWQgc2luY2UgdGhlIGxhc3QgcmVxdWVzdFxuICAgIF9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKG1heEFnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5fcmVhZHkoKTtcbiAgICAgICAgICAgIC8vIEFsbG93aW5nIHN0YWxlIGRhdGEgdXAgdG8gbWF4QWdlIG9sZFxuICAgICAgICAgICAgaWYgKG1heEFnZSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXaGlsZSB0aGVyZSBhcmUgcGVuZGluZyBpbnRlcm5hbCBibG9jayByZXF1ZXN0cy4uLlxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLlwicmVtZW1iZXJcIiB3aGljaCBmZXRjaCB3ZSBzdGFydGVkIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxCbG9ja051bWJlciA9IHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcmVzdWx0IGlzIG5vdCB0b28gc3RhbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIGludGVybmFsQmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGdldFRpbWUoKSAtIHJlc3VsdC5yZXNwVGltZSkgPD0gbWF4QWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvbyBvbGQ7IGZldGNoIGEgbmV3IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmZXRjaCByZWplY3RlZDsgaWYgd2UgYXJlIHRoZSBmaXJzdCB0byBnZXQgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWplY3Rpb24sIGRyb3AgdGhyb3VnaCBzbyB3ZSByZXBsYWNlIGl0IHdpdGggYSBuZXdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZldGNoOyBhbGwgb3RoZXJzIGJsb2NrZWQgd2lsbCB0aGVuIGdldCB0aGF0IGZldGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB3b24ndCBtYXRjaCB0aGUgb25lIHRoZXkgXCJyZW1lbWJlcmVkXCIgYW5kIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID09PSBpbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXFUaW1lID0gZ2V0VGltZSgpO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyID0gcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnBlcmZvcm0oXCJnZXRCbG9ja051bWJlclwiLCB7fSksXG4gICAgICAgICAgICAgICAgbmV0d29ya0Vycm9yOiB0aGlzLmdldE5ldHdvcmsoKS50aGVuKChuZXR3b3JrKSA9PiAobnVsbCksIChlcnJvcikgPT4gKGVycm9yKSlcbiAgICAgICAgICAgIH0pLnRoZW4oKHsgYmxvY2tOdW1iZXIsIG5ldHdvcmtFcnJvciB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5ldHdvcmtFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbnJlbWVtYmVyIHRoaXMgYmFkIGludGVybmFsIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9PT0gY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXR3b3JrRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BUaW1lID0gZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gQmlnTnVtYmVyLmZyb20oYmxvY2tOdW1iZXIpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyIDwgdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IHRoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRGYXN0QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpOyAvLyBAVE9ETzogU3RpbGwgbmVlZCB0aGlzP1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGJsb2NrTnVtYmVyLCByZXFUaW1lLCByZXNwVGltZSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgLy8gU3dhbGxvdyB1bmhhbmRsZWQgZXhjZXB0aW9uczsgaWYgbmVlZGVkIHRoZXkgYXJlIGhhbmRsZWQgZWxzZSB3aGVyZVxuICAgICAgICAgICAgY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IG51bGwgdGhlIGRlYWQgKHJlamVjdGVkKSBmZXRjaCwgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiB1cGRhdGVkXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPT09IGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoeWllbGQgY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyKS5ibG9ja051bWJlcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvbGwoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwb2xsSWQgPSBuZXh0UG9sbElkKys7XG4gICAgICAgICAgICAvLyBUcmFjayBhbGwgcnVubmluZyBwcm9taXNlcywgc28gd2UgY2FuIHRyaWdnZXIgYSBwb3N0LXBvbGwgb25jZSB0aGV5IGFyZSBjb21wbGV0ZVxuICAgICAgICAgICAgY29uc3QgcnVubmVycyA9IFtdO1xuICAgICAgICAgICAgbGV0IGJsb2NrTnVtYmVyID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIHRoaXMucG9sbGluZ0ludGVydmFsIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2V0RmFzdEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIC8vIEVtaXQgYSBwb2xsIGV2ZW50IGFmdGVyIHdlIGhhdmUgdGhlIGxhdGVzdCAoZmFzdCkgYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJwb2xsXCIsIHBvbGxJZCwgYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGJsb2NrIGhhcyBub3QgY2hhbmdlZCwgbWVoLlxuICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09PSB0aGlzLl9sYXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkaWRQb2xsXCIsIHBvbGxJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmlyc3QgcG9sbGluZyBjeWNsZSwgdHJpZ2dlciBhIFwiYmxvY2tcIiBldmVudHNcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkLmJsb2NrID09PSAtMikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSBibG9ja051bWJlciAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoKHRoaXMuX2VtaXR0ZWQuYmxvY2spIC0gYmxvY2tOdW1iZXIpID4gMTAwMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBuZXR3b3JrIGJsb2NrIHNrZXcgZGV0ZWN0ZWQ7IHNraXBwaW5nIGJsb2NrIGV2ZW50cyAoZW1pdHRlZD0ke3RoaXMuX2VtaXR0ZWQuYmxvY2t9IGJsb2NrTnVtYmVyJHtibG9ja051bWJlcn0pYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgbG9nZ2VyLm1ha2VFcnJvcihcIm5ldHdvcmsgYmxvY2sgc2tldyBkZXRlY3RlZFwiLCBMb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IGJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogXCJibG9ja1NrZXdcIixcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNCbG9ja051bWJlcjogdGhpcy5fZW1pdHRlZC5ibG9ja1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJibG9ja1wiLCBibG9ja051bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RpZnkgYWxsIGxpc3RlbmVyIGZvciBlYWNoIGJsb2NrIHRoYXQgaGFzIHBhc3NlZFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9lbWl0dGVkLmJsb2NrICsgMTsgaSA8PSBibG9ja051bWJlcjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImJsb2NrXCIsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBlbWl0dGVkIGJsb2NrIHdhcyB1cGRhdGVkLCBjaGVjayBmb3Igb2Jzb2xldGUgZXZlbnRzXG4gICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZC5ibG9jayAhPT0gYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkLmJsb2NrID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5fZW1pdHRlZCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBibG9jayBldmVudCBkb2VzIG5vdCBleHBpcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGJsb2NrIHdlIHdlcmUgYXQgd2hlbiB3ZSBlbWl0dGVkIHRoaXMgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRCbG9ja051bWJlciA9IHRoaXMuX2VtaXR0ZWRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2Fubm90IGdhcmJhZ2UgY29sbGVjdCBwZW5kaW5nIHRyYW5zYWN0aW9ucyBvciBibG9ja3MgaGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHNob3VsZCBiZSBnYXJiYWdlIGNvbGxlY3RlZCBieSB0aGUgUHJvdmlkZXIgd2hlbiBzZXR0aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIFwicGVuZGluZ1wiIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRCbG9ja051bWJlciA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFdmljdCBhbnkgdHJhbnNhY3Rpb24gaGFzaGVzIG9yIGJsb2NrIGhhc2hlcyBvdmVyIDEyIGJsb2Nrc1xuICAgICAgICAgICAgICAgICAgICAvLyBvbGQsIHNpbmNlIHRoZXkgc2hvdWxkIG5vdCByZXR1cm4gbnVsbCBhbnl3YXlzXG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciAtIGV2ZW50QmxvY2tOdW1iZXIgPiAxMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2VtaXR0ZWRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmlyc3QgcG9sbGluZyBjeWNsZVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RCbG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlciAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5kIGFsbCB0cmFuc2FjdGlvbiBoYXNoZXMgd2UgYXJlIHdhaXRpbmcgb25cbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidHhcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IGV2ZW50Lmhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcnVubmVyID0gdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCkudGhlbigocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVjZWlwdCB8fCByZWNlaXB0LmJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgaGFzaF0gPSByZWNlaXB0LmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChoYXNoLCByZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4geyB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVycy5wdXNoKHJ1bm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZmlsdGVyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgYWxsb3cgYSBzaW5nbGUgZ2V0TG9ncyB0byBiZSBpbi1mbGlnaHQgYXQgYSB0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50Ll9pbmZsaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Ll9pbmZsaWdodCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgZmlsdGVyIGZvciB0aGlzIGV2ZW50LCBzbyB3ZSB3YW50IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdHJpY3QgZXZlbnRzIHRvIGV2ZW50cyB0aGF0IGhhcHBlbmVkIG5vIGVhcmxpZXIgdGhhbiBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuX2xhc3RCbG9ja051bWJlciA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuX2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIGZyb20gdGhlIGxhc3QgKmtub3duKiBldmVudDsgZHVlIHRvIGxvYWQtYmFsYW5jaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHNvbWUgbm9kZXMgcmV0dXJuaW5nIHVwZGF0ZWQgYmxvY2sgbnVtYmVycyBiZWZvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmRleGluZyBldmVudHMsIGEgbG9ncyByZXN1bHQgd2l0aCAwIGVudHJpZXMgY2Fubm90IGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1c3RlZCBhbmQgd2UgbXVzdCByZXRyeSBhIHJhbmdlIHdoaWNoIGluY2x1ZGVzIGl0IGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gZXZlbnQuZmlsdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSBldmVudC5fbGFzdEJsb2NrTnVtYmVyICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIudG9CbG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgZml0bGVyIHJhbmdlcyBmcm9tIGdyb3dpbmcgdG9vIHdpbGQsIHNpbmNlIGl0IGlzIHF1aXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGlrZWx5IHRoZXJlIGp1c3QgaGF2ZW4ndCBiZWVuIGFueSBldmVudHMgdG8gbW92ZSB0aGUgbGFzdEJsb2NrTnVtYmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pbkZyb21CbG9jayA9IGZpbHRlci50b0Jsb2NrIC0gdGhpcy5fbWF4RmlsdGVyQmxvY2tSYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluRnJvbUJsb2NrID4gZmlsdGVyLmZyb21CbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gbWluRnJvbUJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLmZyb21CbG9jayA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bm5lciA9IHRoaXMuZ2V0TG9ncyhmaWx0ZXIpLnRoZW4oKGxvZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgdGhlIG5leHQgZ2V0TG9nc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5faW5mbGlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9ncy5mb3JFYWNoKChsb2cpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgd2hlbiB3ZSBnZXQgYW4gZXZlbnQgZm9yIGEgZ2l2ZW4gYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gd2UgdHJ1c3QgdGhlIGV2ZW50cyBhcmUgaW5kZXhlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZy5ibG9ja051bWJlciA+IGV2ZW50Ll9sYXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5fbGFzdEJsb2NrTnVtYmVyID0gbG9nLmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHN0YWxsIHJlcXVlc3RzIHRvIGZldGNoIGJsb2NrcyBhbmQgdHhzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkW1wiYjpcIiArIGxvZy5ibG9ja0hhc2hdID0gbG9nLmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZFtcInQ6XCIgKyBsb2cudHJhbnNhY3Rpb25IYXNoXSA9IGxvZy5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChmaWx0ZXIsIGxvZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGFub3RoZXIgZ2V0TG9ncyAodGhlIHJhbmdlIHdhcyBub3QgdXBkYXRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuX2luZmxpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVycy5wdXNoKHJ1bm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAvLyBPbmNlIGFsbCBldmVudHMgZm9yIHRoaXMgbG9vcCBoYXZlIGJlZW4gcHJvY2Vzc2VkLCBlbWl0IFwiZGlkUG9sbFwiXG4gICAgICAgICAgICBQcm9taXNlLmFsbChydW5uZXJzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkaWRQb2xsXCIsIHBvbGxJZCk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpOyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIERlcHJlY2F0ZWQ7IGRvIG5vdCB1c2UgdGhpc1xuICAgIHJlc2V0RXZlbnRzQmxvY2soYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSAxO1xuICAgICAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ldHdvcms7XG4gICAgfVxuICAgIC8vIFRoaXMgbWV0aG9kIHNob3VsZCBxdWVyeSB0aGUgbmV0d29yayBpZiB0aGUgdW5kZXJseWluZyBuZXR3b3JrXG4gICAgLy8gY2FuIGNoYW5nZSwgc3VjaCBhcyB3aGVuIGNvbm5lY3RlZCB0byBhIEpTT04tUlBDIGJhY2tlbmRcbiAgICBkZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwicHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBuZXR3b3JrIGRldGVjdGlvblwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJwcm92aWRlci5kZXRlY3ROZXR3b3JrXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSB5aWVsZCB0aGlzLl9yZWFkeSgpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGFyZSBzdGlsbCBjb25uZWN0ZWQgdG8gdGhlIHNhbWUgbmV0d29yazsgdGhpcyBpc1xuICAgICAgICAgICAgLy8gb25seSBhbiBleHRlcm5hbCBjYWxsIGZvciBiYWNrZW5kcyB3aGljaCBjYW4gaGF2ZSB0aGUgdW5kZXJseWluZ1xuICAgICAgICAgICAgLy8gbmV0d29yayBjaGFuZ2Ugc3BvbnRhbmVvdXNseVxuICAgICAgICAgICAgY29uc3QgY3VycmVudE5ldHdvcmsgPSB5aWVsZCB0aGlzLmRldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrLmNoYWluSWQgIT09IGN1cnJlbnROZXR3b3JrLmNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgYWxsb3dpbmcgbmV0d29yayBjaGFuZ2VzLCB0aGluZ3MgY2FuIGdldCBjb21wbGV4IGZhc3Q7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZyBpZiB5b3UgdXNlIFwiYW55XCJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbnlOZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25ldHdvcmsgPSBjdXJyZW50TmV0d29yaztcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgYWxsIGludGVybmFsIGJsb2NrIG51bWJlciBndWFyZHMgYW5kIGNhY2hlc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zhc3RRdWVyeURhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkLmJsb2NrID0gLTI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXIgPSAtMTAyNDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBcIm5ldHdvcmtcIiBldmVudCBNVVNUIGhhcHBlbiBiZWZvcmUgdGhpcyBtZXRob2QgcmVzb2x2ZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gYW55IGV2ZW50cyBoYXZlIGEgY2hhbmNlIHRvIHVucmVnaXN0ZXIsIHNvIHdlIHN0YWxsIGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZGl0aW9uYWwgZXZlbnQgbG9vcCBiZWZvcmUgcmV0dXJuaW5nIGZyb20gL3RoaXMvIGNhbGxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBjdXJyZW50TmV0d29yaywgbmV0d29yayk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHN0YWxsKDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbmV0d29yaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBsb2dnZXIubWFrZUVycm9yKFwidW5kZXJseWluZyBuZXR3b3JrIGNoYW5nZWRcIiwgTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImNoYW5nZWRcIixcbiAgICAgICAgICAgICAgICAgICAgbmV0d29yazogbmV0d29yayxcbiAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWROZXR3b3JrOiBjdXJyZW50TmV0d29ya1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGJsb2NrTnVtYmVyKCkge1xuICAgICAgICB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIHRoaXMucG9sbGluZ0ludGVydmFsIC8gMikudGhlbigoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcik7XG4gICAgICAgIH0sIChlcnJvcikgPT4geyB9KTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgIT0gbnVsbCkgPyB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgOiAtMTtcbiAgICB9XG4gICAgZ2V0IHBvbGxpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fcG9sbGVyICE9IG51bGwpO1xuICAgIH1cbiAgICBzZXQgcG9sbGluZyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgIXRoaXMuX3BvbGxlcikge1xuICAgICAgICAgICAgdGhpcy5fcG9sbGVyID0gc2V0SW50ZXJ2YWwoKCkgPT4geyB0aGlzLnBvbGwoKTsgfSwgdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9ib290c3RyYXBQb2xsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9vdHN0cmFwUG9sbCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYmxvY2sgYWRkaXRpb25hbCBwb2xscyB1bnRpbCB0aGUgcG9sbGluZyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBkb25lLCB0byBwcmV2ZW50IG92ZXJ3aGVsbWluZyB0aGUgcG9sbCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ib290c3RyYXBQb2xsID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwb2xsaW5nIHdhcyBkaXNhYmxlZCwgc29tZXRoaW5nIG1heSByZXF1aXJlIGEgcG9rZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2Ugc3RhcnRpbmcgdGhlIGJvb3RzdHJhcCBwb2xsIGFuZCBpdCB3YXMgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcG9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciBvdXQgdGhlIGJvb3RzdHJhcCBzbyB3ZSBjYW4gZG8gYW5vdGhlclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYm9vdHN0cmFwUG9sbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdmFsdWUgJiYgdGhpcy5fcG9sbGVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3BvbGxlcik7XG4gICAgICAgICAgICB0aGlzLl9wb2xsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2xsaW5nSW50ZXJ2YWw7XG4gICAgfVxuICAgIHNldCBwb2xsaW5nSW50ZXJ2YWwodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcIm51bWJlclwiIHx8IHZhbHVlIDw9IDAgfHwgcGFyc2VJbnQoU3RyaW5nKHZhbHVlKSkgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9sbGluZyBpbnRlcnZhbFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3BvbGxlcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9wb2xsZXIpO1xuICAgICAgICAgICAgdGhpcy5fcG9sbGVyID0gc2V0SW50ZXJ2YWwoKCkgPT4geyB0aGlzLnBvbGwoKTsgfSwgdGhpcy5fcG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0RmFzdEJsb2NrTnVtYmVyKCkge1xuICAgICAgICBjb25zdCBub3cgPSBnZXRUaW1lKCk7XG4gICAgICAgIC8vIFN0YWxlIGJsb2NrIG51bWJlciwgcmVxdWVzdCBhIG5ld2VyIHZhbHVlXG4gICAgICAgIGlmICgobm93IC0gdGhpcy5fZmFzdFF1ZXJ5RGF0ZSkgPiAyICogdGhpcy5fcG9sbGluZ0ludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gbm93O1xuICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZSA9IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKChibG9ja051bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgPT0gbnVsbCB8fCBibG9ja051bWJlciA+IHRoaXMuX2Zhc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zhc3RCbG9ja051bWJlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlO1xuICAgIH1cbiAgICBfc2V0RmFzdEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIC8vIE9sZGVyIGJsb2NrLCBtYXliZSBhIHN0YWxlIHJlcXVlc3RcbiAgICAgICAgaWYgKHRoaXMuX2Zhc3RCbG9ja051bWJlciAhPSBudWxsICYmIGJsb2NrTnVtYmVyIDwgdGhpcy5fZmFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB0aW1lIHdlIHVwZGF0ZWQgdGhlIGJsb2NrbnVtYmVyXG4gICAgICAgIHRoaXMuX2Zhc3RRdWVyeURhdGUgPSBnZXRUaW1lKCk7XG4gICAgICAgIC8vIE5ld2VyIGJsb2NrIG51bWJlciwgdXNlICBpdFxuICAgICAgICBpZiAodGhpcy5fZmFzdEJsb2NrTnVtYmVyID09IG51bGwgfHwgYmxvY2tOdW1iZXIgPiB0aGlzLl9mYXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShibG9ja051bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2FpdEZvclRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCwgY29uZmlybWF0aW9ucywgdGltZW91dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dhaXRGb3JUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gsIChjb25maXJtYXRpb25zID09IG51bGwpID8gMSA6IGNvbmZpcm1hdGlvbnMsIHRpbWVvdXQgfHwgMCwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfd2FpdEZvclRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCwgY29uZmlybWF0aW9ucywgdGltZW91dCwgcmVwbGFjZWFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSB5aWVsZCB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAgICAgLy8gUmVjZWlwdCBpcyBhbHJlYWR5IGdvb2RcbiAgICAgICAgICAgIGlmICgocmVjZWlwdCA/IHJlY2VpcHQuY29uZmlybWF0aW9ucyA6IDApID49IGNvbmZpcm1hdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBvbGwgdW50aWwgdGhlIHJlY2VpcHQgaXMgZ29vZC4uLlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxGdW5jcyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxyZWFkeURvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsRnVuY3MuZm9yRWFjaCgoZnVuYykgPT4geyBmdW5jKCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5lZEhhbmRsZXIgPSAocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdC5jb25maXJtYXRpb25zIDwgY29uZmlybWF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5RG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZWNlaXB0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMub24odHJhbnNhY3Rpb25IYXNoLCBtaW5lZEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmNzLnB1c2goKCkgPT4geyB0aGlzLnJlbW92ZUxpc3RlbmVyKHRyYW5zYWN0aW9uSGFzaCwgbWluZWRIYW5kbGVyKTsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0QmxvY2tOdW1iZXIgPSByZXBsYWNlYWJsZS5zdGFydEJsb2NrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2Nhbm5lZEJsb2NrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZUhhbmRsZXIgPSAoYmxvY2tOdW1iZXIpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2FpdCAxIHNlY29uZDsgdGhpcyBpcyBvbmx5IHVzZWQgaW4gdGhlIGNhc2Ugb2YgYSBmYXVsdCwgc29cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHdpbGwgdHJhZGUgb2ZmIGEgbGl0dGxlIGJpdCBvZiBsYXRlbmN5IGZvciBtb3JlIGNvbnNpc3RlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdHMgYW5kIGZld2VyIEpTT04tUlBDIGNhbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBzdGFsbCgxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VHJhbnNhY3Rpb25Db3VudChyZXBsYWNlYWJsZS5mcm9tKS50aGVuKChub25jZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vbmNlIDw9IHJlcGxhY2VhYmxlLm5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIHRyYW5zYWN0aW9uIHdhcyBtaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtaW5lZCA9IHlpZWxkIHRoaXMuZ2V0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW5lZCAmJiBtaW5lZC5ibG9ja051bWJlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IHRpbWUgc2Nhbm5pbmcuIFdlIHN0YXJ0IGEgbGl0dGxlIGVhcmxpZXIgZm9yIHNvbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lnZ2xlIHJvb20gaGVyZSB0byBoYW5kbGUgdGhlIGV2ZW50dWFsbHkgY29uc2lzdGVudCBuYXR1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgYmxvY2tjaGFpbiAoZS5nLiB0aGUgZ2V0VHJhbnNhY3Rpb25Db3VudCB3YXMgZm9yIGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlmZmVyZW50IGJsb2NrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nhbm5lZEJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5uZWRCbG9jayA9IGxhc3RCbG9ja051bWJlciAtIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nhbm5lZEJsb2NrIDwgcmVwbGFjZWFibGUuc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5uZWRCbG9jayA9IHJlcGxhY2VhYmxlLnN0YXJ0QmxvY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHNjYW5uZWRCbG9jayA8PSBibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IHlpZWxkIHRoaXMuZ2V0QmxvY2tXaXRoVHJhbnNhY3Rpb25zKHNjYW5uZWRCbG9jayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0aSA9IDA7IHRpIDwgYmxvY2sudHJhbnNhY3Rpb25zLmxlbmd0aDsgdGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYmxvY2sudHJhbnNhY3Rpb25zW3RpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWNjZXNzZnVsbHkgbWluZWQhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lmhhc2ggPT09IHRyYW5zYWN0aW9uSGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZXMgb3VyIHRyYW5zYWN0aW9uIGZyb20gYW5kIG5vbmNlOyBpdHMgYSByZXBsYWNlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5mcm9tID09PSByZXBsYWNlYWJsZS5mcm9tICYmIHR4Lm5vbmNlID09PSByZXBsYWNlYWJsZS5ub25jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcmVjZWlwdCBvZiB0aGUgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IHlpZWxkIHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKHR4Lmhhc2gsIGNvbmZpcm1hdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IHJlc29sdmVkIG9yIHJlamVjdGVkIChwcm9sbHkgYSB0aW1lb3V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeURvbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb24gd2Ugd2VyZSByZXBsYWNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVhc29uID0gXCJyZXBsYWNlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZGF0YSA9PT0gcmVwbGFjZWFibGUuZGF0YSAmJiB0eC50byA9PT0gcmVwbGFjZWFibGUudG8gJiYgdHgudmFsdWUuZXEocmVwbGFjZWFibGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcInJlcHJpY2VkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHguZGF0YSA9PT0gXCIweFwiICYmIHR4LmZyb20gPT09IHR4LnRvICYmIHR4LnZhbHVlLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcImNhbmNlbGxlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGxhaW4gd2h5IHdlIHdlcmUgcmVwbGFjZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGxvZ2dlci5tYWtlRXJyb3IoXCJ0cmFuc2FjdGlvbiB3YXMgcmVwbGFjZWRcIiwgTG9nZ2VyLmVycm9ycy5UUkFOU0FDVElPTl9SRVBMQUNFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGVkOiAocmVhc29uID09PSBcInJlcGxhY2VkXCIgfHwgcmVhc29uID09PSBcImNhbmNlbGxlZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50OiB0aGlzLl93cmFwVHJhbnNhY3Rpb24odHgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogdHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FubmVkQmxvY2srKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25jZShcImJsb2NrXCIsIHJlcGxhY2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25jZShcImJsb2NrXCIsIHJlcGxhY2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJibG9ja1wiLCByZXBsYWNlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmNzLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcImJsb2NrXCIsIHJlcGxhY2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHRpbWVvdXQpID09PSBcIm51bWJlclwiICYmIHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeURvbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChsb2dnZXIubWFrZUVycm9yKFwidGltZW91dCBleGNlZWRlZFwiLCBMb2dnZXIuZXJyb3JzLlRJTUVPVVQsIHsgdGltZW91dDogdGltZW91dCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIudW5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyLnVucmVmKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsRnVuY3MucHVzaCgoKSA9PiB7IGNsZWFyVGltZW91dCh0aW1lcik7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QmxvY2tOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEdhc1ByaWNlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRHYXNQcmljZVwiLCB7fSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldEdhc1ByaWNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCwgZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEJhbGFuY2UoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSksXG4gICAgICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrVGFnKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRCYWxhbmNlXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldEJhbGFuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRUcmFuc2FjdGlvbkNvdW50KGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KS50b051bWJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uQ291bnRcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb2RlKGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0Q29kZVwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldENvZGVcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRTdG9yYWdlQXQoYWRkcmVzc09yTmFtZSwgcG9zaXRpb24sIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZyksXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFByb21pc2UucmVzb2x2ZShwb3NpdGlvbikudGhlbigocCkgPT4gaGV4VmFsdWUocCkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldFN0b3JhZ2VBdFwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldFN0b3JhZ2VBdFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMsIHJlc3VsdCwgZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBieSBhbnkgc3ViY2xhc3Mgd3JhcHBpbmcgYSBUcmFuc2FjdGlvblJlc3BvbnNlXG4gICAgX3dyYXBUcmFuc2FjdGlvbih0eCwgaGFzaCwgc3RhcnRCbG9jaykge1xuICAgICAgICBpZiAoaGFzaCAhPSBudWxsICYmIGhleERhdGFMZW5ndGgoaGFzaCkgIT09IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlIC0gc2VuZFRyYW5zYWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHR4O1xuICAgICAgICAvLyBDaGVjayB0aGUgaGFzaCB3ZSBleHBlY3QgaXMgdGhlIHNhbWUgYXMgdGhlIGhhc2ggdGhlIHNlcnZlciByZXBvcnRlZFxuICAgICAgICBpZiAoaGFzaCAhPSBudWxsICYmIHR4Lmhhc2ggIT09IGhhc2gpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiVHJhbnNhY3Rpb24gaGFzaCBtaXNtYXRjaCBmcm9tIFByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbi5cIiwgTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7IGV4cGVjdGVkSGFzaDogdHguaGFzaCwgcmV0dXJuZWRIYXNoOiBoYXNoIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC53YWl0ID0gKGNvbmZpcm1zLCB0aW1lb3V0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlybXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpcm1zID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lb3V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgZGV0YWlscyB0byBkZXRlY3QgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgIGxldCByZXBsYWNlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChjb25maXJtcyAhPT0gMCAmJiBzdGFydEJsb2NrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogdHguZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgbm9uY2U6IHR4Lm5vbmNlLFxuICAgICAgICAgICAgICAgICAgICB0bzogdHgudG8sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRCbG9ja1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWNlaXB0ID0geWllbGQgdGhpcy5fd2FpdEZvclRyYW5zYWN0aW9uKHR4Lmhhc2gsIGNvbmZpcm1zLCB0aW1lb3V0LCByZXBsYWNlbWVudCk7XG4gICAgICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsICYmIGNvbmZpcm1zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBObyBsb25nZXIgcGVuZGluZywgYWxsb3cgdGhlIHBvbGxpbmcgbG9vcCB0byBnYXJiYWdlIGNvbGxlY3QgdGhpc1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlZFtcInQ6XCIgKyB0eC5oYXNoXSA9IHJlY2VpcHQuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICBpZiAocmVjZWlwdC5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInRyYW5zYWN0aW9uIGZhaWxlZFwiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogdHguaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHR4LFxuICAgICAgICAgICAgICAgICAgICByZWNlaXB0OiByZWNlaXB0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHNlbmRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBoZXhUeCA9IHlpZWxkIFByb21pc2UucmVzb2x2ZShzaWduZWRUcmFuc2FjdGlvbikudGhlbih0ID0+IGhleGxpZnkodCkpO1xuICAgICAgICAgICAgY29uc3QgdHggPSB0aGlzLmZvcm1hdHRlci50cmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICBpZiAodHguY29uZmlybWF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IHlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IHlpZWxkIHRoaXMucGVyZm9ybShcInNlbmRUcmFuc2FjdGlvblwiLCB7IHNpZ25lZFRyYW5zYWN0aW9uOiBoZXhUeCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4LCBoYXNoLCBibG9ja051bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbiA9IHR4O1xuICAgICAgICAgICAgICAgIGVycm9yLnRyYW5zYWN0aW9uSGFzaCA9IHR4Lmhhc2g7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB5aWVsZCB0cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0ge307XG4gICAgICAgICAgICBbXCJmcm9tXCIsIFwidG9cIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eFtrZXldID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlc1trZXldKS50aGVuKCh2KSA9PiAodiA/IHRoaXMuX2dldEFkZHJlc3ModikgOiBudWxsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFtcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJtYXhGZWVQZXJHYXNcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcInZhbHVlXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbigodikgPT4gKHYgPyBCaWdOdW1iZXIuZnJvbSh2KSA6IG51bGwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgW1widHlwZVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR4W2tleV0gPSBQcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4oKHYpID0+ICgodiAhPSBudWxsKSA/IHYgOiBudWxsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMuYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgICAgIHR4LmFjY2Vzc0xpc3QgPSB0aGlzLmZvcm1hdHRlci5hY2Nlc3NMaXN0KHZhbHVlcy5hY2Nlc3NMaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFtcImRhdGFcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eFtrZXldID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlc1trZXldKS50aGVuKCh2KSA9PiAodiA/IGhleGxpZnkodikgOiBudWxsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci50cmFuc2FjdGlvblJlcXVlc3QoeWllbGQgcmVzb2x2ZVByb3BlcnRpZXModHgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRGaWx0ZXIoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBmaWx0ZXIgPSB5aWVsZCBmaWx0ZXI7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIuYWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFkZHJlc3MgPSB0aGlzLl9nZXRBZGRyZXNzKGZpbHRlci5hZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFtcImJsb2NrSGFzaFwiLCBcInRvcGljc1wiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZmlsdGVyW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFtcImZyb21CbG9ja1wiLCBcInRvQmxvY2tcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHRoaXMuX2dldEJsb2NrVGFnKGZpbHRlcltrZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLmZpbHRlcih5aWVsZCByZXNvbHZlUHJvcGVydGllcyhyZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9jYWxsKHRyYW5zYWN0aW9uLCBibG9ja1RhZywgYXR0ZW1wdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGF0dGVtcHQgPj0gTUFYX0NDSVBfUkVESVJFQ1RTKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJDQ0lQIHJlYWQgZXhjZWVkZWQgbWF4aW11bSByZWRpcmVjdGlvbnNcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RzOiBhdHRlbXB0LCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHhTZW5kZXIgPSB0cmFuc2FjdGlvbi50bztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImNhbGxcIiwgeyB0cmFuc2FjdGlvbiwgYmxvY2tUYWcgfSk7XG4gICAgICAgICAgICAvLyBDQ0lQIFJlYWQgcmVxdWVzdCB2aWEgT2ZmY2hhaW5Mb29rdXAoYWRkcmVzcyxzdHJpbmdbXSxieXRlcyxieXRlczQsYnl0ZXMpXG4gICAgICAgICAgICBpZiAoYXR0ZW1wdCA+PSAwICYmIGJsb2NrVGFnID09PSBcImxhdGVzdFwiICYmIHR4U2VuZGVyICE9IG51bGwgJiYgcmVzdWx0LnN1YnN0cmluZygwLCAxMCkgPT09IFwiMHg1NTZmMTgzMFwiICYmIChoZXhEYXRhTGVuZ3RoKHJlc3VsdCkgJSAzMiA9PT0gNCkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gaGV4RGF0YVNsaWNlKHJlc3VsdCwgNCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBzZW5kZXIgb2YgdGhlIE9mZmNoYWluTG9va3VwIG1hdGNoZXMgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbmRlciA9IGhleERhdGFTbGljZShkYXRhLCAwLCAzMik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghQmlnTnVtYmVyLmZyb20oc2VuZGVyKS5lcSh0eFNlbmRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQ0NJUCBSZWFkIHNlbmRlciBkaWQgbm90IG1hdGNoXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIk9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLCBkYXRhOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgdGhlIFVSTHMgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJscyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmxzT2Zmc2V0ID0gQmlnTnVtYmVyLmZyb20oaGV4RGF0YVNsaWNlKGRhdGEsIDMyLCA2NCkpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybHNMZW5ndGggPSBCaWdOdW1iZXIuZnJvbShoZXhEYXRhU2xpY2UoZGF0YSwgdXJsc09mZnNldCwgdXJsc09mZnNldCArIDMyKSkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsc0RhdGEgPSBoZXhEYXRhU2xpY2UoZGF0YSwgdXJsc09mZnNldCArIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCB1cmxzTGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IF9wYXJzZVN0cmluZyh1cmxzRGF0YSwgdSAqIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQ0NJUCBSZWFkIGNvbnRhaW5lZCBjb3JydXB0IFVSTCBzdHJpbmdcIiwgTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJPZmZjaGFpbkxvb2t1cChhZGRyZXNzLHN0cmluZ1tdLGJ5dGVzLGJ5dGVzNCxieXRlcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sIGRhdGE6IHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdXJscy5wdXNoKHVybCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBDQ0lQIGNhbGxkYXRhIHRvIGZvcndhcmRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGRhdGEgPSBfcGFyc2VCeXRlcyhkYXRhLCA2NCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY2FsbGJhY2tTZWxlY3RvciAoYnl0ZXM0KVxuICAgICAgICAgICAgICAgICAgICBpZiAoIUJpZ051bWJlci5mcm9tKGhleERhdGFTbGljZShkYXRhLCAxMDAsIDEyOCkpLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNDSVAgUmVhZCBjYWxsYmFjayBzZWxlY3RvciBpbmNsdWRlZCBqdW5rXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIk9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLCBkYXRhOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrU2VsZWN0b3IgPSBoZXhEYXRhU2xpY2UoZGF0YSwgOTYsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZXh0cmEgZGF0YSB0byBzZW5kIGJhY2sgdG8gdGhlIGNvbnRyYWN0IGFzIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0cmFEYXRhID0gX3BhcnNlQnl0ZXMoZGF0YSwgMTI4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2NpcFJlc3VsdCA9IHlpZWxkIHRoaXMuY2NpcFJlYWRGZXRjaCh0cmFuc2FjdGlvbiwgY2FsbGRhdGEsIHVybHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2NpcFJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNDSVAgUmVhZCBkaXNhYmxlZCBvciBwcm92aWRlZCBubyBVUkxzXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIk9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLCBkYXRhOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG86IHR4U2VuZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaGV4Q29uY2F0KFtjYWxsYmFja1NlbGVjdG9yLCBlbmNvZGVCeXRlcyhbY2NpcFJlc3VsdCwgZXh0cmFEYXRhXSldKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbCh0eCwgYmxvY2tUYWcsIGF0dGVtcHQgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHsgdHJhbnNhY3Rpb24sIGJsb2NrVGFnIH0sIHJlc3VsdCwgZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhbGwodHJhbnNhY3Rpb24sIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QodHJhbnNhY3Rpb24pLFxuICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZyksXG4gICAgICAgICAgICAgICAgY2NpcFJlYWRFbmFibGVkOiBQcm9taXNlLnJlc29sdmUodHJhbnNhY3Rpb24uY2NpcFJlYWRFbmFibGVkKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbChyZXNvbHZlZC50cmFuc2FjdGlvbiwgcmVzb2x2ZWQuYmxvY2tUYWcsIHJlc29sdmVkLmNjaXBSZWFkRW5hYmxlZCA/IDAgOiAtMSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRoaXMuX2dldFRyYW5zYWN0aW9uUmVxdWVzdCh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZXN0aW1hdGVHYXNcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXN0aW1hdGVHYXNcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBhZGRyZXNzT3JOYW1lID0geWllbGQgYWRkcmVzc09yTmFtZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3NPck5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzcyBvciBFTlMgbmFtZVwiLCBcIm5hbWVcIiwgYWRkcmVzc09yTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgdGhpcy5yZXNvbHZlTmFtZShhZGRyZXNzT3JOYW1lKTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkVOUyBuYW1lIG5vdCBjb25maWd1cmVkXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogYHJlc29sdmVOYW1lKCR7SlNPTi5zdHJpbmdpZnkoYWRkcmVzc09yTmFtZSl9KWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcsIGluY2x1ZGVUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgYmxvY2tIYXNoT3JCbG9ja1RhZyA9IHlpZWxkIGJsb2NrSGFzaE9yQmxvY2tUYWc7XG4gICAgICAgICAgICAvLyBJZiBibG9ja1RhZyBpcyBhIG51bWJlciAobm90IFwibGF0ZXN0XCIsIGV0YyksIHRoaXMgaXMgdGhlIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgbGV0IGJsb2NrTnVtYmVyID0gLTEyODtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlVHJhbnNhY3Rpb25zOiAhIWluY2x1ZGVUcmFuc2FjdGlvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYmxvY2tIYXNoT3JCbG9ja1RhZywgMzIpKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmJsb2NrSGFzaCA9IGJsb2NrSGFzaE9yQmxvY2tUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuYmxvY2tUYWcgPSB5aWVsZCB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja0hhc2hPckJsb2NrVGFnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKHBhcmFtcy5ibG9ja1RhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gcGFyc2VJbnQocGFyYW1zLmJsb2NrVGFnLnN1YnN0cmluZygyKSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBibG9jayBoYXNoIG9yIGJsb2NrIHRhZ1wiLCBcImJsb2NrSGFzaE9yQmxvY2tUYWdcIiwgYmxvY2tIYXNoT3JCbG9ja1RhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvbGwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0QmxvY2tcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAvLyBCbG9jayB3YXMgbm90IGZvdW5kXG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGJsb2NraGFzaGVzLCBpZiB3ZSBkaWRuJ3Qgc2F5IGl0IGV4aXN0ZWQsIHRoYXQgYmxvY2toYXNoIG1heVxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgZXhpc3QuIElmIHdlIGRpZCBzZWUgaXQgdGhvdWdoLCBwZXJoYXBzIGZyb20gYSBsb2csIHdlIGtub3dcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgZXhpc3RzLCBhbmQgdGhpcyBub2RlIGlzIGp1c3Qgbm90IGNhdWdodCB1cCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tIYXNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkW1wiYjpcIiArIHBhcmFtcy5ibG9ja0hhc2hdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgYmxvY2sgdGFncywgaWYgd2UgYXJlIGFza2luZyBmb3IgYSBmdXR1cmUgYmxvY2ssIHdlIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tUYWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID4gdGhpcy5fZW1pdHRlZC5ibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHJ5IG9uIHRoZSBuZXh0IGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZVRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmxvY2tOdW1iZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrLnRyYW5zYWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSBibG9jay50cmFuc2FjdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHguY29uZmlybWF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29uZmlybWF0aW9ucyB1c2luZyB0aGUgZmFzdCBibG9jayBudW1iZXIgKHBlc3NpbWlzdGljKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb25maXJtYXRpb25zID0gKGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja1dpdGhUeHMgPSB0aGlzLmZvcm1hdHRlci5ibG9ja1dpdGhUcmFuc2FjdGlvbnMoYmxvY2spO1xuICAgICAgICAgICAgICAgICAgICBibG9ja1dpdGhUeHMudHJhbnNhY3Rpb25zID0gYmxvY2tXaXRoVHhzLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB0aGlzLl93cmFwVHJhbnNhY3Rpb24odHgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrV2l0aFR4cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLmJsb2NrKGJsb2NrKTtcbiAgICAgICAgICAgIH0pLCB7IG9uY2VQb2xsOiB0aGlzIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2dldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcsIGZhbHNlKSk7XG4gICAgfVxuICAgIGdldEJsb2NrV2l0aFRyYW5zYWN0aW9ucyhibG9ja0hhc2hPckJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZywgdHJ1ZSkpO1xuICAgIH1cbiAgICBnZXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoID0geWllbGQgdHJhbnNhY3Rpb25IYXNoO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geyB0cmFuc2FjdGlvbkhhc2g6IHRoaXMuZm9ybWF0dGVyLmhhc2godHJhbnNhY3Rpb25IYXNoLCB0cnVlKSB9O1xuICAgICAgICAgICAgcmV0dXJuIHBvbGwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldFRyYW5zYWN0aW9uXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkW1widDpcIiArIHRyYW5zYWN0aW9uSGFzaF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdHggPSB0aGlzLmZvcm1hdHRlci50cmFuc2FjdGlvblJlc3BvbnNlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKHR4LmJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LmNvbmZpcm1hdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IHlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjb25maXJtYXRpb25zIHVzaW5nIHRoZSBmYXN0IGJsb2NrIG51bWJlciAocGVzc2ltaXN0aWMpXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb25maXJtYXRpb25zID0gKGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IGNvbmZpcm1hdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICAgICAgfSksIHsgb25jZVBvbGw6IHRoaXMgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCA9IHlpZWxkIHRyYW5zYWN0aW9uSGFzaDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgdHJhbnNhY3Rpb25IYXNoOiB0aGlzLmZvcm1hdHRlci5oYXNoKHRyYW5zYWN0aW9uSGFzaCwgdHJ1ZSkgfTtcbiAgICAgICAgICAgIHJldHVybiBwb2xsKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgdHJhbnNhY3Rpb25IYXNoXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBcImdldGgtZXRjXCIgcmV0dXJucyByZWNlaXB0cyBiZWZvcmUgdGhleSBhcmUgcmVhZHlcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmJsb2NrSGFzaCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSB0aGlzLmZvcm1hdHRlci5yZWNlaXB0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQuYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZWNlaXB0LmNvbmZpcm1hdGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWNlaXB0LmNvbmZpcm1hdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IHlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjb25maXJtYXRpb25zIHVzaW5nIHRoZSBmYXN0IGJsb2NrIG51bWJlciAocGVzc2ltaXN0aWMpXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb25maXJtYXRpb25zID0gKGJsb2NrTnVtYmVyIC0gcmVjZWlwdC5ibG9ja051bWJlcikgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWNlaXB0LmNvbmZpcm1hdGlvbnMgPSBjb25maXJtYXRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgICAgIH0pLCB7IG9uY2VQb2xsOiB0aGlzIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TG9ncyhmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoeyBmaWx0ZXI6IHRoaXMuX2dldEZpbHRlcihmaWx0ZXIpIH0pO1xuICAgICAgICAgICAgY29uc3QgbG9ncyA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldExvZ3NcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIGxvZ3MuZm9yRWFjaCgobG9nKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZy5yZW1vdmVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLnJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLmZvcm1hdHRlci5maWx0ZXJMb2cuYmluZCh0aGlzLmZvcm1hdHRlcikpKGxvZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RXRoZXJQcmljZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybShcImdldEV0aGVyUHJpY2VcIiwge30pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEJsb2NrVGFnKGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9IHlpZWxkIGJsb2NrVGFnO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpID09PSBcIm51bWJlclwiICYmIGJsb2NrVGFnIDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChibG9ja1RhZyAlIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgQmxvY2tUYWdcIiwgXCJibG9ja1RhZ1wiLCBibG9ja1RhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBibG9ja051bWJlciA9IHlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlciArPSBibG9ja1RhZztcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLmJsb2NrVGFnKGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5ibG9ja1RhZyhibG9ja1RhZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRSZXNvbHZlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudE5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5hbWUgPT09IFwiXCIgfHwgY3VycmVudE5hbWUgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPcHRpbWl6YXRpb24gc2luY2UgdGhlIGV0aCBub2RlIGNhbm5vdCBjaGFuZ2UgYW5kIGRvZXNcbiAgICAgICAgICAgICAgICAvLyBub3QgaGF2ZSBhIHdpbGRjYXJkIHJlc29sdmVyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgIT09IFwiZXRoXCIgJiYgY3VycmVudE5hbWUgPT09IFwiZXRoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBjdXJyZW50IG5vZGUgZm9yIGEgcmVzb2x2ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyID0geWllbGQgdGhpcy5fZ2V0UmVzb2x2ZXIoY3VycmVudE5hbWUsIFwiZ2V0UmVzb2x2ZXJcIik7XG4gICAgICAgICAgICAgICAgLy8gRm91bmQgYSByZXNvbHZlciFcbiAgICAgICAgICAgICAgICBpZiAoYWRkciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gbmV3IFJlc29sdmVyKHRoaXMsIGFkZHIsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBMZWdhY3kgcmVzb2x2ZXIgZm91bmQsIHVzaW5nIEVJUC0yNTQ0IHNvIGl0IGlzbid0IHNhZmUgdG8gdXNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TmFtZSAhPT0gbmFtZSAmJiAhKHlpZWxkIHJlc29sdmVyLnN1cHBvcnRzV2lsZGNhcmQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgICAgIGN1cnJlbnROYW1lID0gY3VycmVudE5hbWUuc3BsaXQoXCIuXCIpLnNsaWNlKDEpLmpvaW4oXCIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldFJlc29sdmVyKG5hbWUsIG9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gXCJFTlNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIC8vIE5vIEVOUy4uLlxuICAgICAgICAgICAgaWYgKCFuZXR3b3JrLmVuc0FkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFTlNcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uLCBuZXR3b3JrOiBuZXR3b3JrLm5hbWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGtlY2NhazI1NihcInJlc29sdmVyKGJ5dGVzMzIpXCIpXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkckRhdGEgPSB5aWVsZCB0aGlzLmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICB0bzogbmV0d29yay5lbnNBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiAoXCIweDAxNzhiOGJmXCIgKyBuYW1laGFzaChuYW1lKS5zdWJzdHJpbmcoMikpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLmNhbGxBZGRyZXNzKGFkZHJEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIEVOUyByZWdpc3RyeSBjYW5ub3QgdGhyb3cgZXJyb3JzIG9uIHJlc29sdmVyKGJ5dGVzMzIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc29sdmVOYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIG5hbWUgPSB5aWVsZCBuYW1lO1xuICAgICAgICAgICAgLy8gSWYgaXQgaXMgYWxyZWFkeSBhbiBhZGRyZXNzLCBub3RoaW5nIHRvIHJlc29sdmVcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmZvcm1hdHRlci5hZGRyZXNzKG5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIGlzIGlzIGEgaGV4c3RyaW5nLCB0aGUgYWRkcmVzcyBpcyBiYWQgKFNlZSAjNjk0KVxuICAgICAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIChuYW1lKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgYWRkciBmcm9tIHRoZSByZXNvbHZlclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSB5aWVsZCB0aGlzLmdldFJlc29sdmVyKG5hbWUpO1xuICAgICAgICAgICAgaWYgKCFyZXNvbHZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc29sdmVyLmdldEFkZHJlc3MoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxvb2t1cEFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IHlpZWxkIGFkZHJlc3M7XG4gICAgICAgICAgICBhZGRyZXNzID0gdGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCI7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlckFkZHIgPSB5aWVsZCB0aGlzLl9nZXRSZXNvbHZlcihub2RlLCBcImxvb2t1cEFkZHJlc3NcIik7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZXJBZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGtlY2NhayhcIm5hbWUoYnl0ZXMzMilcIilcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBfcGFyc2VTdHJpbmcoeWllbGQgdGhpcy5jYWxsKHtcbiAgICAgICAgICAgICAgICB0bzogcmVzb2x2ZXJBZGRyLFxuICAgICAgICAgICAgICAgIGRhdGE6IChcIjB4NjkxZjM0MzFcIiArIG5hbWVoYXNoKG5vZGUpLnN1YnN0cmluZygyKSlcbiAgICAgICAgICAgIH0pLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSB5aWVsZCB0aGlzLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGFkZHIgIT0gYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRBdmF0YXIobmFtZU9yQWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHJlc29sdmVyID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhuYW1lT3JBZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIC8vIEFkZHJlc3M7IHJldmVyc2UgbG9va3VwXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuZm9ybWF0dGVyLmFkZHJlc3MobmFtZU9yQWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCkgKyBcIi5hZGRyLnJldmVyc2VcIjtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlckFkZHJlc3MgPSB5aWVsZCB0aGlzLl9nZXRSZXNvbHZlcihub2RlLCBcImdldEF2YXRhclwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVyQWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHJlc29sdmluZyB0aGUgYXZhdGFyIGFnYWluc3QgdGhlIGFkZHIucmV2ZXJzZSByZXNvbHZlclxuICAgICAgICAgICAgICAgIHJlc29sdmVyID0gbmV3IFJlc29sdmVyKHRoaXMsIHJlc29sdmVyQWRkcmVzcywgbm9kZSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXZhdGFyID0geWllbGQgcmVzb2x2ZXIuZ2V0QXZhdGFyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdmF0YXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdmF0YXIudXJsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIG5hbWUgYW5kIHBlcmZvcm1pbmcgZm9yd2FyZCBsb29rdXA7IGFsbG93aW5nIHdpbGRjYXJkc1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlY2NhayhcIm5hbWUoYnl0ZXMzMilcIilcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IF9wYXJzZVN0cmluZyh5aWVsZCB0aGlzLmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG86IHJlc29sdmVyQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChcIjB4NjkxZjM0MzFcIiArIG5hbWVoYXNoKG5vZGUpLnN1YnN0cmluZygyKSlcbiAgICAgICAgICAgICAgICAgICAgfSksIDApO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlciA9IHlpZWxkIHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRU5TIG5hbWU7IGZvcndhcmQgbG9va3VwIHdpdGggd2lsZGNhcmRcbiAgICAgICAgICAgICAgICByZXNvbHZlciA9IHlpZWxkIHRoaXMuZ2V0UmVzb2x2ZXIobmFtZU9yQWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdmF0YXIgPSB5aWVsZCByZXNvbHZlci5nZXRBdmF0YXIoKTtcbiAgICAgICAgICAgIGlmIChhdmF0YXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF2YXRhci51cmw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwZXJmb3JtKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihtZXRob2QgKyBcIiBub3QgaW1wbGVtZW50ZWRcIiwgTG9nZ2VyLmVycm9ycy5OT1RfSU1QTEVNRU5URUQsIHsgb3BlcmF0aW9uOiBtZXRob2QgfSk7XG4gICAgfVxuICAgIF9zdGFydEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMucG9sbGluZyA9ICh0aGlzLl9ldmVudHMuZmlsdGVyKChlKSA9PiBlLnBvbGxhYmxlKCkpLmxlbmd0aCA+IDApO1xuICAgIH1cbiAgICBfc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMucG9sbGluZyA9ICh0aGlzLl9ldmVudHMuZmlsdGVyKChlKSA9PiBlLnBvbGxhYmxlKCkpLmxlbmd0aCA+IDApO1xuICAgIH1cbiAgICBfYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvbmNlKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KGdldEV2ZW50VGFnKGV2ZW50TmFtZSksIGxpc3RlbmVyLCBvbmNlKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgICB0aGlzLl9zdGFydEV2ZW50KGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH1cbiAgICBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfVxuICAgIGVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBbXTtcbiAgICAgICAgbGV0IGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5saXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChldmVudC5vbmNlKSB7XG4gICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0b3BwZWQuZm9yRWFjaCgoZXZlbnQpID0+IHsgdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTsgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmICghZXZlbnROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoZXZlbnQudGFnID09PSBldmVudFRhZyk7XG4gICAgICAgIH0pLmxlbmd0aDtcbiAgICB9XG4gICAgbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoZXZlbnROYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubWFwKChldmVudCkgPT4gZXZlbnQubGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHNcbiAgICAgICAgICAgIC5maWx0ZXIoKGV2ZW50KSA9PiAoZXZlbnQudGFnID09PSBldmVudFRhZykpXG4gICAgICAgICAgICAubWFwKChldmVudCkgPT4gZXZlbnQubGlzdGVuZXIpO1xuICAgIH1cbiAgICBvZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RvcHBlZCA9IFtdO1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnIHx8IGV2ZW50Lmxpc3RlbmVyICE9IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBzdG9wcGVkLmZvckVhY2goKGV2ZW50KSA9PiB7IHRoaXMuX3N0b3BFdmVudChldmVudCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgICBsZXQgc3RvcHBlZCA9IFtdO1xuICAgICAgICBpZiAoZXZlbnROYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0b3BwZWQgPSB0aGlzLl9ldmVudHM7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhZyAhPT0gZXZlbnRUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcHBlZC5mb3JFYWNoKChldmVudCkgPT4geyB0aGlzLl9zdG9wRXZlbnQoZXZlbnQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiRm9ya0V2ZW50IiwiUHJvdmlkZXIiLCJlbmNvZGUiLCJiYXNlNjRFbmNvZGUiLCJCYXNlNTgiLCJCaWdOdW1iZXIiLCJhcnJheWlmeSIsImNvbmNhdCIsImhleENvbmNhdCIsImhleERhdGFMZW5ndGgiLCJoZXhEYXRhU2xpY2UiLCJoZXhsaWZ5IiwiaGV4VmFsdWUiLCJoZXhaZXJvUGFkIiwiaXNIZXhTdHJpbmciLCJIYXNoWmVybyIsImRuc0VuY29kZSIsIm5hbWVoYXNoIiwiZ2V0TmV0d29yayIsImRlZmluZVJlYWRPbmx5IiwiZ2V0U3RhdGljIiwicmVzb2x2ZVByb3BlcnRpZXMiLCJzaGEyNTYiLCJ0b1V0ZjhCeXRlcyIsInRvVXRmOFN0cmluZyIsImZldGNoSnNvbiIsInBvbGwiLCJiZWNoMzIiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiRm9ybWF0dGVyIiwiTUFYX0NDSVBfUkVESVJFQ1RTIiwiY2hlY2tUb3BpYyIsInRvcGljIiwidGhyb3dBcmd1bWVudEVycm9yIiwidG9Mb3dlckNhc2UiLCJzZXJpYWxpemVUb3BpY3MiLCJ0b3BpY3MiLCJzbGljZSIsImxlbmd0aCIsInBvcCIsIm1hcCIsIkFycmF5IiwiaXNBcnJheSIsInVuaXF1ZSIsImZvckVhY2giLCJzb3J0ZWQiLCJPYmplY3QiLCJrZXlzIiwic29ydCIsImpvaW4iLCJkZXNlcmlhbGl6ZVRvcGljcyIsImRhdGEiLCJzcGxpdCIsImNvbXBzIiwiZ2V0RXZlbnRUYWciLCJldmVudE5hbWUiLCJpbmRleE9mIiwiaXNGb3JrRXZlbnQiLCJ3YXJuIiwiRXJyb3IiLCJhZGRyZXNzIiwiZ2V0VGltZSIsIkRhdGUiLCJzdGFsbCIsImR1cmF0aW9uIiwic2V0VGltZW91dCIsIlBvbGxhYmxlRXZlbnRzIiwiRXZlbnQiLCJjb25zdHJ1Y3RvciIsInRhZyIsImxpc3RlbmVyIiwib25jZSIsIl9sYXN0QmxvY2tOdW1iZXIiLCJfaW5mbGlnaHQiLCJldmVudCIsInR5cGUiLCJoYXNoIiwiZmlsdGVyIiwicG9sbGFibGUiLCJjb2luSW5mb3MiLCJzeW1ib2wiLCJwMnBraCIsInAyc2giLCJwcmVmaXgiLCJpbGsiLCJieXRlczMyaWZ5IiwiZnJvbSIsInRvSGV4U3RyaW5nIiwiYmFzZTU4RW5jb2RlIiwibWF0Y2hlcklwZnMiLCJSZWdFeHAiLCJtYXRjaGVycyIsIl9wYXJzZVN0cmluZyIsInN0YXJ0IiwiX3BhcnNlQnl0ZXMiLCJlcnJvciIsIm9mZnNldCIsInRvTnVtYmVyIiwiZ2V0SXBmc0xpbmsiLCJsaW5rIiwibWF0Y2giLCJzdWJzdHJpbmciLCJudW1QYWQiLCJwYWRkZWQiLCJVaW50OEFycmF5Iiwic2V0IiwiYnl0ZXNQYWQiLCJNYXRoIiwiY2VpbCIsImVuY29kZUJ5dGVzIiwiZGF0YXMiLCJieXRlQ291bnQiLCJpIiwicHVzaCIsIlJlc29sdmVyIiwicHJvdmlkZXIiLCJuYW1lIiwicmVzb2x2ZWRBZGRyZXNzIiwiZm9ybWF0dGVyIiwic3VwcG9ydHNXaWxkY2FyZCIsIl9zdXBwb3J0c0VpcDI1NDQiLCJjYWxsIiwidG8iLCJlcSIsImNhdGNoIiwiY29kZSIsImVycm9ycyIsIkNBTExfRVhDRVBUSU9OIiwiX2ZldGNoIiwic2VsZWN0b3IiLCJwYXJhbWV0ZXJzIiwidHgiLCJjY2lwUmVhZEVuYWJsZWQiLCJwYXJzZUJ5dGVzIiwidGhyb3dFcnJvciIsInRyYW5zYWN0aW9uIiwiX2ZldGNoQnl0ZXMiLCJfZ2V0QWRkcmVzcyIsImNvaW5UeXBlIiwiaGV4Qnl0ZXMiLCJjb2luSW5mbyIsIlN0cmluZyIsIlVOU1VQUE9SVEVEX09QRVJBVElPTiIsIm9wZXJhdGlvbiIsImJ5dGVzIiwicGFyc2VJbnQiLCJ3b3JkcyIsInRvV29yZHMiLCJ1bnNoaWZ0IiwiZ2V0QWRkcmVzcyIsImNhbGxBZGRyZXNzIiwiZ2V0QXZhdGFyIiwibGlua2FnZSIsImNvbnRlbnQiLCJhdmF0YXIiLCJnZXRUZXh0Iiwic2NoZW1lIiwidXJsIiwib3duZXIiLCJfcmVzb2x2ZWRBZGRyZXNzIiwiYWRkciIsInRva2VuSWQiLCJ0b2tlbk93bmVyIiwiYmFsYW5jZSIsImlzWmVybyIsInRvU3RyaW5nIiwibWV0YWRhdGFVcmwiLCJyZXBsYWNlIiwibWV0YWRhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiaW1hZ2VVcmwiLCJpbWFnZSIsImlwZnMiLCJnZXRDb250ZW50SGFzaCIsImlwbnMiLCJzd2FybSIsInNreW5ldCIsInVybFNhZmUiLCJhIiwia2V5Iiwia2V5Qnl0ZXMiLCJkZWZhdWx0Rm9ybWF0dGVyIiwibmV4dFBvbGxJZCIsIkJhc2VQcm92aWRlciIsIm5ldHdvcmsiLCJfZXZlbnRzIiwiX2VtaXR0ZWQiLCJibG9jayIsImRpc2FibGVDY2lwUmVhZCIsImdldEZvcm1hdHRlciIsImFueU5ldHdvcmsiLCJkZXRlY3ROZXR3b3JrIiwiX25ldHdvcmtQcm9taXNlIiwiX3JlYWR5Iiwia25vd25OZXR3b3JrIiwiZW1pdCIsIl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyIiwiX21heEZpbHRlckJsb2NrUmFuZ2UiLCJfcG9sbGluZ0ludGVydmFsIiwiX2Zhc3RRdWVyeURhdGUiLCJfbmV0d29yayIsIlVOS05PV05fRVJST1IiLCJyZWFkeSIsIk5FVFdPUktfRVJST1IiLCJ1bmRlZmluZWQiLCJjY2lwUmVhZEZldGNoIiwiY2FsbGRhdGEiLCJ1cmxzIiwic2VuZGVyIiwiZXJyb3JNZXNzYWdlcyIsImhyZWYiLCJqc29uIiwiZXJyb3JQYXNzVGhyb3VnaCIsInJlc3BvbnNlIiwic3RhdHVzIiwic3RhdHVzQ29kZSIsImVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiLCJTRVJWRVJfRVJST1IiLCJtIiwiX2dldEludGVybmFsQmxvY2tOdW1iZXIiLCJtYXhBZ2UiLCJfaW50ZXJuYWxCbG9ja051bWJlciIsImludGVybmFsQmxvY2tOdW1iZXIiLCJyZXNwVGltZSIsImJsb2NrTnVtYmVyIiwicmVxVGltZSIsImNoZWNrSW50ZXJuYWxCbG9ja051bWJlciIsInBlcmZvcm0iLCJuZXR3b3JrRXJyb3IiLCJfc2V0RmFzdEJsb2NrTnVtYmVyIiwicG9sbElkIiwicnVubmVycyIsInBvbGxpbmdJbnRlcnZhbCIsImFicyIsIm1ha2VFcnJvciIsInByZXZpb3VzQmxvY2tOdW1iZXIiLCJldmVudEJsb2NrTnVtYmVyIiwicnVubmVyIiwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0IiwicmVjZWlwdCIsImZyb21CbG9jayIsInRvQmxvY2siLCJtaW5Gcm9tQmxvY2siLCJnZXRMb2dzIiwibG9ncyIsImxvZyIsImJsb2NrSGFzaCIsInRyYW5zYWN0aW9uSGFzaCIsImFsbCIsInJlc2V0RXZlbnRzQmxvY2siLCJwb2xsaW5nIiwiY3VycmVudE5ldHdvcmsiLCJjaGFpbklkIiwiX2Zhc3RCbG9ja051bWJlciIsIl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlIiwiZGV0ZWN0ZWROZXR3b3JrIiwiX3BvbGxlciIsInNldEludGVydmFsIiwiX2Jvb3RzdHJhcFBvbGwiLCJjbGVhckludGVydmFsIiwiX2dldEZhc3RCbG9ja051bWJlciIsIm5vdyIsImdldEJsb2NrTnVtYmVyIiwid2FpdEZvclRyYW5zYWN0aW9uIiwiY29uZmlybWF0aW9ucyIsInRpbWVvdXQiLCJfd2FpdEZvclRyYW5zYWN0aW9uIiwicmVwbGFjZWFibGUiLCJjYW5jZWxGdW5jcyIsImFscmVhZHlEb25lIiwiZnVuYyIsIm1pbmVkSGFuZGxlciIsIm9uIiwicmVtb3ZlTGlzdGVuZXIiLCJsYXN0QmxvY2tOdW1iZXIiLCJzdGFydEJsb2NrIiwic2Nhbm5lZEJsb2NrIiwicmVwbGFjZUhhbmRsZXIiLCJnZXRUcmFuc2FjdGlvbkNvdW50Iiwibm9uY2UiLCJtaW5lZCIsImdldFRyYW5zYWN0aW9uIiwiZ2V0QmxvY2tXaXRoVHJhbnNhY3Rpb25zIiwidGkiLCJ0cmFuc2FjdGlvbnMiLCJyZWFzb24iLCJUUkFOU0FDVElPTl9SRVBMQUNFRCIsImNhbmNlbGxlZCIsInJlcGxhY2VtZW50IiwiX3dyYXBUcmFuc2FjdGlvbiIsInRpbWVyIiwiVElNRU9VVCIsInVucmVmIiwiY2xlYXJUaW1lb3V0IiwiZ2V0R2FzUHJpY2UiLCJtZXRob2QiLCJnZXRCYWxhbmNlIiwiYWRkcmVzc09yTmFtZSIsImJsb2NrVGFnIiwicGFyYW1zIiwiX2dldEJsb2NrVGFnIiwiZ2V0Q29kZSIsImdldFN0b3JhZ2VBdCIsInBvc2l0aW9uIiwicCIsImV4cGVjdGVkSGFzaCIsInJldHVybmVkSGFzaCIsIndhaXQiLCJjb25maXJtcyIsInNlbmRUcmFuc2FjdGlvbiIsInNpZ25lZFRyYW5zYWN0aW9uIiwiaGV4VHgiLCJ0IiwiX2dldFRyYW5zYWN0aW9uUmVxdWVzdCIsInZhbHVlcyIsInYiLCJhY2Nlc3NMaXN0IiwidHJhbnNhY3Rpb25SZXF1ZXN0IiwiX2dldEZpbHRlciIsIl9jYWxsIiwiYXR0ZW1wdCIsInJlZGlyZWN0cyIsInR4U2VuZGVyIiwic2lnbmF0dXJlIiwidXJsc09mZnNldCIsInVybHNMZW5ndGgiLCJ1cmxzRGF0YSIsInUiLCJjYWxsYmFja1NlbGVjdG9yIiwiZXh0cmFEYXRhIiwiY2NpcFJlc3VsdCIsInJlc29sdmVkIiwiZXN0aW1hdGVHYXMiLCJyZXNvbHZlTmFtZSIsIl9nZXRCbG9jayIsImJsb2NrSGFzaE9yQmxvY2tUYWciLCJpbmNsdWRlVHJhbnNhY3Rpb25zIiwiYmxvY2tXaXRoVHhzIiwiYmxvY2tXaXRoVHJhbnNhY3Rpb25zIiwib25jZVBvbGwiLCJnZXRCbG9jayIsInRyYW5zYWN0aW9uUmVzcG9uc2UiLCJyZW1vdmVkIiwiYXJyYXlPZiIsImZpbHRlckxvZyIsImJpbmQiLCJnZXRFdGhlclByaWNlIiwiZ2V0UmVzb2x2ZXIiLCJjdXJyZW50TmFtZSIsIl9nZXRSZXNvbHZlciIsInJlc29sdmVyIiwiZW5zQWRkcmVzcyIsImFkZHJEYXRhIiwibG9va3VwQWRkcmVzcyIsIm5vZGUiLCJyZXNvbHZlckFkZHIiLCJuYW1lT3JBZGRyZXNzIiwicmVzb2x2ZXJBZGRyZXNzIiwiTk9UX0lNUExFTUVOVEVEIiwiX3N0YXJ0RXZlbnQiLCJfc3RvcEV2ZW50IiwiX2FkZEV2ZW50TGlzdGVuZXIiLCJhcmdzIiwic3RvcHBlZCIsImV2ZW50VGFnIiwibGlzdGVuZXJDb3VudCIsImxpc3RlbmVycyIsIm9mZiIsInJlbW92ZUFsbExpc3RlbmVycyIsImZvdW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/providers/lib.esm/base-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/providers/lib.esm/formatter.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/formatter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Formatter: () => (/* binding */ Formatter),\n/* harmony export */   isCommunityResourcable: () => (/* binding */ isCommunityResourcable),\n/* harmony export */   isCommunityResource: () => (/* binding */ isCommunityResource),\n/* harmony export */   showThrottleMessage: () => (/* binding */ showThrottleMessage)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/./node_modules/@ethersproject/constants/lib.esm/addresses.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/./node_modules/@ethersproject/transactions/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nclass Formatter {\n    constructor(){\n        this.formats = this.getDefaultFormats();\n    }\n    getDefaultFormats() {\n        const formats = {};\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n        const strictData = (v)=>{\n            return this.data(v, true);\n        };\n        formats.transaction = {\n            hash: hash,\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n            confirmations: Formatter.allowNull(number, null),\n            from: address,\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n            creates: Formatter.allowNull(address, null),\n            raw: Formatter.allowNull(data)\n        };\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null)\n        };\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash\n        };\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n        formats.block = {\n            hash: Formatter.allowNull(hash),\n            parentHash: hash,\n            number: number,\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n            miner: Formatter.allowNull(address),\n            extraData: data,\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n        formats.blockWithTransactions = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.shallowCopy)(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined)\n        };\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n            topics: Formatter.arrayOf(hash),\n            transactionHash: hash,\n            logIndex: number\n        };\n        return formats;\n    }\n    accessList(accessList) {\n        return (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__.accessListify)(accessList || []);\n    }\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number) {\n        if (number === \"0x\") {\n            return 0;\n        }\n        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(number).toNumber();\n    }\n    type(number) {\n        if (number === \"0x\" || number == null) {\n            return 0;\n        }\n        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(number).toNumber();\n    }\n    // Strict! Used on input.\n    bigNumber(value) {\n        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value);\n    }\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value) {\n        if (typeof value === \"boolean\") {\n            return value;\n        }\n        if (typeof value === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") {\n                return true;\n            }\n            if (value === \"false\") {\n                return false;\n            }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n    hex(value, strict) {\n        if (typeof value === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") {\n                value = \"0x\" + value;\n            }\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(value)) {\n                return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n    data(value, strict) {\n        const result = this.hex(value, strict);\n        if (result.length % 2 !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n    // Requires an address\n    // Strict! Used on input.\n    address(value) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getAddress)(value);\n    }\n    callAddress(value) {\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(value, 32)) {\n            return null;\n        }\n        const address = (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getAddress)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexDataSlice)(value, 12));\n        return address === _ethersproject_constants__WEBPACK_IMPORTED_MODULE_7__.AddressZero ? null : address;\n    }\n    contractAddress(value) {\n        return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getContractAddress)(value);\n    }\n    // Strict! Used on input.\n    blockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        if (blockTag === \"earliest\") {\n            return \"0x0\";\n        }\n        switch(blockTag){\n            case \"earliest\":\n                return \"0x0\";\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n            case \"finalized\":\n                return blockTag;\n        }\n        if (typeof blockTag === \"number\" || (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(blockTag)) {\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexValue)(blockTag);\n        }\n        throw new Error(\"invalid blockTag\");\n    }\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value, strict) {\n        const result = this.hex(value, strict);\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexDataLength)(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value) {\n        if (value == null) {\n            return null;\n        }\n        const v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value);\n        try {\n            return v.toNumber();\n        } catch (error) {}\n        return null;\n    }\n    uint256(value) {\n        if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexZeroPad)(value, 32);\n    }\n    _block(value, format) {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = difficulty == null ? null : _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(difficulty);\n        return result;\n    }\n    block(value) {\n        return this._block(value, this.formats.block);\n    }\n    blockWithTransactions(value) {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n    // Strict! Used on input.\n    transactionRequest(value) {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n    transactionResponse(transaction) {\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n            transaction.accessList = [];\n        }\n        const result = Formatter.check(this.formats.transaction, transaction);\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(chainId)) {\n                chainId = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(chainId).toNumber();\n            }\n            result.chainId = chainId;\n        } else {\n            let chainId = transaction.networkId;\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(chainId)) {\n                chainId = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(chainId).toNumber();\n            }\n            if (typeof chainId !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) {\n                    chainId = 0;\n                }\n                chainId = parseInt(chainId);\n            }\n            if (typeof chainId !== \"number\") {\n                chainId = 0;\n            }\n            result.chainId = chainId;\n        }\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n        return result;\n    }\n    transaction(value) {\n        return (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__.parse)(value);\n    }\n    receiptLog(value) {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n    receipt(value) {\n        const result = Formatter.check(this.formats.receipt, value);\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && result.status !== value) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", {\n                            root: result.root,\n                            status: result.status\n                        });\n                    }\n                    result.status = value;\n                    delete result.root;\n                } else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            } else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n        return result;\n    }\n    topics(value) {\n        if (Array.isArray(value)) {\n            return value.map((v)=>this.topics(v));\n        } else if (value != null) {\n            return this.hash(value, true);\n        }\n        return null;\n    }\n    filter(value) {\n        return Formatter.check(this.formats.filter, value);\n    }\n    filterLog(value) {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n    static check(format, object) {\n        const result = {};\n        for(const key in format){\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            } catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n    // if value is null-ish, nullValue is returned\n    static allowNull(format, nullValue) {\n        return function(value) {\n            if (value == null) {\n                return nullValue;\n            }\n            return format(value);\n        };\n    }\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format, replaceValue) {\n        return function(value) {\n            if (!value) {\n                return replaceValue;\n            }\n            return format(value);\n        };\n    }\n    // Requires an Array satisfying check\n    static arrayOf(format) {\n        return function(array) {\n            if (!Array.isArray(array)) {\n                throw new Error(\"not an array\");\n            }\n            const result = [];\n            array.forEach(function(value) {\n                result.push(format(value));\n            });\n            return result;\n        };\n    }\n}\nfunction isCommunityResourcable(value) {\n    return value && typeof value.isCommunityResource === \"function\";\n}\nfunction isCommunityResource(value) {\n    return isCommunityResourcable(value) && value.isCommunityResource();\n}\n// Show the throttle message only once\nlet throttleMessage = false;\nfunction showThrottleMessage() {\n    if (throttleMessage) {\n        return;\n    }\n    throttleMessage = true;\n    console.log(\"========= NOTICE =========\");\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https://docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n} //# sourceMappingURL=formatter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vZm9ybWF0dGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFhO0FBQzJEO0FBQ25CO0FBQ2lEO0FBQy9DO0FBQ0M7QUFDK0I7QUFDeEM7QUFDVjtBQUNyQyxNQUFNZSxTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDMUIsTUFBTUU7SUFDVEMsYUFBYztRQUNWLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUksQ0FBQ0MsaUJBQWlCO0lBQ3pDO0lBQ0FBLG9CQUFvQjtRQUNoQixNQUFNRCxVQUFXLENBQUM7UUFDbEIsTUFBTUUsVUFBVSxJQUFJLENBQUNBLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDLElBQUk7UUFDdEMsTUFBTUMsWUFBWSxJQUFJLENBQUNBLFNBQVMsQ0FBQ0QsSUFBSSxDQUFDLElBQUk7UUFDMUMsTUFBTUUsV0FBVyxJQUFJLENBQUNBLFFBQVEsQ0FBQ0YsSUFBSSxDQUFDLElBQUk7UUFDeEMsTUFBTUcsT0FBTyxJQUFJLENBQUNBLElBQUksQ0FBQ0gsSUFBSSxDQUFDLElBQUk7UUFDaEMsTUFBTUksT0FBTyxJQUFJLENBQUNBLElBQUksQ0FBQ0osSUFBSSxDQUFDLElBQUk7UUFDaEMsTUFBTUssTUFBTSxJQUFJLENBQUNBLEdBQUcsQ0FBQ0wsSUFBSSxDQUFDLElBQUk7UUFDOUIsTUFBTU0sU0FBUyxJQUFJLENBQUNBLE1BQU0sQ0FBQ04sSUFBSSxDQUFDLElBQUk7UUFDcEMsTUFBTU8sT0FBTyxJQUFJLENBQUNBLElBQUksQ0FBQ1AsSUFBSSxDQUFDLElBQUk7UUFDaEMsTUFBTVEsYUFBYSxDQUFDQztZQUFRLE9BQU8sSUFBSSxDQUFDTixJQUFJLENBQUNNLEdBQUc7UUFBTztRQUN2RFosUUFBUWEsV0FBVyxHQUFHO1lBQ2xCTixNQUFNQTtZQUNORyxNQUFNQTtZQUNOSSxZQUFZaEIsVUFBVWlCLFNBQVMsQ0FBQyxJQUFJLENB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QVFDLEdBQUcsQ0FBQztJQUNaRCxRQUFRQyxHQUFHLENBQUM7SUFDWkQsUUFBUUMsR0FBRyxDQUFDO0lBQ1pELFFBQVFDLEdBQUcsQ0FBQztBQUNoQixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vZm9ybWF0dGVyLmpzP2U3NmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzLCBnZXRDb250cmFjdEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgaGV4RGF0YUxlbmd0aCwgaGV4RGF0YVNsaWNlLCBoZXhWYWx1ZSwgaGV4WmVyb1BhZCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IEFkZHJlc3NaZXJvIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgc2hhbGxvd0NvcHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSwgcGFyc2UgYXMgcGFyc2VUcmFuc2FjdGlvbiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC90cmFuc2FjdGlvbnNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmV4cG9ydCBjbGFzcyBGb3JtYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmZvcm1hdHMgPSB0aGlzLmdldERlZmF1bHRGb3JtYXRzKCk7XG4gICAgfVxuICAgIGdldERlZmF1bHRGb3JtYXRzKCkge1xuICAgICAgICBjb25zdCBmb3JtYXRzID0gKHt9KTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcy5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBiaWdOdW1iZXIgPSB0aGlzLmJpZ051bWJlci5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBibG9ja1RhZyA9IHRoaXMuYmxvY2tUYWcuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YS5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBoYXNoID0gdGhpcy5oYXNoLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IGhleCA9IHRoaXMuaGV4LmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IG51bWJlciA9IHRoaXMubnVtYmVyLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGUuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3Qgc3RyaWN0RGF0YSA9ICh2KSA9PiB7IHJldHVybiB0aGlzLmRhdGEodiwgdHJ1ZSk7IH07XG4gICAgICAgIGZvcm1hdHMudHJhbnNhY3Rpb24gPSB7XG4gICAgICAgICAgICBoYXNoOiBoYXNoLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGFjY2Vzc0xpc3Q6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy5hY2Nlc3NMaXN0LmJpbmQodGhpcyksIG51bGwpLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhhc2gsIG51bGwpLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcbiAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcbiAgICAgICAgICAgIGZyb206IGFkZHJlc3MsXG4gICAgICAgICAgICAvLyBlaXRoZXIgKGdhc1ByaWNlKSBvciAobWF4UHJpb3JpdHlGZWVQZXJHYXMgKyBtYXhGZWVQZXJHYXMpXG4gICAgICAgICAgICAvLyBtdXN0IGJlIHNldFxuICAgICAgICAgICAgZ2FzUHJpY2U6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBiaWdOdW1iZXIsXG4gICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzLCBudWxsKSxcbiAgICAgICAgICAgIHZhbHVlOiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBub25jZTogbnVtYmVyLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHI6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy51aW50MjU2KSxcbiAgICAgICAgICAgIHM6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy51aW50MjU2KSxcbiAgICAgICAgICAgIHY6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKSxcbiAgICAgICAgICAgIGNyZWF0ZXM6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICByYXc6IEZvcm1hdHRlci5hbGxvd051bGwoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMudHJhbnNhY3Rpb25SZXF1ZXN0ID0ge1xuICAgICAgICAgICAgZnJvbTogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSxcbiAgICAgICAgICAgIG5vbmNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICBnYXNMaW1pdDogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIHRvOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MpLFxuICAgICAgICAgICAgdmFsdWU6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIGRhdGE6IEZvcm1hdHRlci5hbGxvd051bGwoc3RyaWN0RGF0YSksXG4gICAgICAgICAgICB0eXBlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICBhY2Nlc3NMaXN0OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWNjZXNzTGlzdC5iaW5kKHRoaXMpLCBudWxsKSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybWF0cy5yZWNlaXB0TG9nID0ge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IG51bWJlcixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogaGFzaCxcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICB0b3BpY3M6IEZvcm1hdHRlci5hcnJheU9mKGhhc2gpLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGxvZ0luZGV4OiBudW1iZXIsXG4gICAgICAgICAgICBibG9ja0hhc2g6IGhhc2gsXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMucmVjZWlwdCA9IHtcbiAgICAgICAgICAgIHRvOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICBmcm9tOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgYWxsb3dOdWxsKGhhc2gpLCBidXQgYnJva2VuLUVJUC02NTggc3VwcG9ydCBpcyBoYW5kbGVkIGluIHJlY2VpcHRcbiAgICAgICAgICAgIHJvb3Q6IEZvcm1hdHRlci5hbGxvd051bGwoaGV4KSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IGJpZ051bWJlcixcbiAgICAgICAgICAgIGxvZ3NCbG9vbTogRm9ybWF0dGVyLmFsbG93TnVsbChkYXRhKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogaGFzaCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogaGFzaCxcbiAgICAgICAgICAgIGxvZ3M6IEZvcm1hdHRlci5hcnJheU9mKHRoaXMucmVjZWlwdExvZy5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBudW1iZXIsXG4gICAgICAgICAgICBjb25maXJtYXRpb25zOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICBjdW11bGF0aXZlR2FzVXNlZDogYmlnTnVtYmVyLFxuICAgICAgICAgICAgZWZmZWN0aXZlR2FzUHJpY2U6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIHN0YXR1czogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLmJsb2NrID0ge1xuICAgICAgICAgICAgaGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoKSxcbiAgICAgICAgICAgIHBhcmVudEhhc2g6IGhhc2gsXG4gICAgICAgICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbnVtYmVyLFxuICAgICAgICAgICAgbm9uY2U6IEZvcm1hdHRlci5hbGxvd051bGwoaGV4KSxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IHRoaXMuZGlmZmljdWx0eS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IGJpZ051bWJlcixcbiAgICAgICAgICAgIGdhc1VzZWQ6IGJpZ051bWJlcixcbiAgICAgICAgICAgIG1pbmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MpLFxuICAgICAgICAgICAgZXh0cmFEYXRhOiBkYXRhLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKEZvcm1hdHRlci5hcnJheU9mKGhhc2gpKSxcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKVxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLmJsb2NrV2l0aFRyYW5zYWN0aW9ucyA9IHNoYWxsb3dDb3B5KGZvcm1hdHMuYmxvY2spO1xuICAgICAgICBmb3JtYXRzLmJsb2NrV2l0aFRyYW5zYWN0aW9ucy50cmFuc2FjdGlvbnMgPSBGb3JtYXR0ZXIuYWxsb3dOdWxsKEZvcm1hdHRlci5hcnJheU9mKHRoaXMudHJhbnNhY3Rpb25SZXNwb25zZS5iaW5kKHRoaXMpKSk7XG4gICAgICAgIGZvcm1hdHMuZmlsdGVyID0ge1xuICAgICAgICAgICAgZnJvbUJsb2NrOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJsb2NrVGFnLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgdG9CbG9jazogRm9ybWF0dGVyLmFsbG93TnVsbChibG9ja1RhZywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgYWRkcmVzczogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgdG9waWNzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMudG9waWNzLmJpbmQodGhpcyksIHVuZGVmaW5lZCksXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMuZmlsdGVyTG9nID0ge1xuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoKSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgIHJlbW92ZWQ6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy5ib29sZWFuLmJpbmQodGhpcykpLFxuICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IEZvcm1hdHRlci5hbGxvd0ZhbHNpc2goZGF0YSwgXCIweFwiKSxcbiAgICAgICAgICAgIHRvcGljczogRm9ybWF0dGVyLmFycmF5T2YoaGFzaCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG4gICAgICAgICAgICBsb2dJbmRleDogbnVtYmVyLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9ybWF0cztcbiAgICB9XG4gICAgYWNjZXNzTGlzdChhY2Nlc3NMaXN0KSB7XG4gICAgICAgIHJldHVybiBhY2Nlc3NMaXN0aWZ5KGFjY2Vzc0xpc3QgfHwgW10pO1xuICAgIH1cbiAgICAvLyBSZXF1aXJlcyBhIEJpZ051bWJlcmlzaCB0aGF0IGlzIHdpdGhpbiB0aGUgSUVFRTc1NCBzYWZlIGludGVnZXIgcmFuZ2U7IHJldHVybnMgYSBudW1iZXJcbiAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG4gICAgbnVtYmVyKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShudW1iZXIpLnRvTnVtYmVyKCk7XG4gICAgfVxuICAgIHR5cGUobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPT09IFwiMHhcIiB8fCBudW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKG51bWJlcikudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuICAgIGJpZ051bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuICAgIH1cbiAgICAvLyBSZXF1aXJlcyBhIGJvb2xlYW4sIFwidHJ1ZVwiIG9yICBcImZhbHNlXCI7IHJldHVybnMgYSBib29sZWFuXG4gICAgYm9vbGVhbih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJvb2xlYW4gLSBcIiArIHZhbHVlKTtcbiAgICB9XG4gICAgaGV4KHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRhdGEodmFsdWUsIHN0cmljdCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmhleCh2YWx1ZSwgc3RyaWN0KTtcbiAgICAgICAgaWYgKChyZXN1bHQubGVuZ3RoICUgMikgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZGF0YTsgb2RkLWxlbmd0aCAtIFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFJlcXVpcmVzIGFuIGFkZHJlc3NcbiAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG4gICAgYWRkcmVzcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgfVxuICAgIGNhbGxBZGRyZXNzKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUsIDMyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGdldEFkZHJlc3MoaGV4RGF0YVNsaWNlKHZhbHVlLCAxMikpO1xuICAgICAgICByZXR1cm4gKGFkZHJlc3MgPT09IEFkZHJlc3NaZXJvKSA/IG51bGwgOiBhZGRyZXNzO1xuICAgIH1cbiAgICBjb250cmFjdEFkZHJlc3ModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbnRyYWN0QWRkcmVzcyh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICBibG9ja1RhZyhibG9ja1RhZykge1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibGF0ZXN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrVGFnID09PSBcImVhcmxpZXN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjB4MFwiO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYmxvY2tUYWcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJlYXJsaWVzdFwiOiByZXR1cm4gXCIweDBcIjtcbiAgICAgICAgICAgIGNhc2UgXCJsYXRlc3RcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICBjYXNlIFwic2FmZVwiOlxuICAgICAgICAgICAgY2FzZSBcImZpbmFsaXplZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1RhZztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIgfHwgaXNIZXhTdHJpbmcoYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4VmFsdWUoYmxvY2tUYWcpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmxvY2tUYWdcIik7XG4gICAgfVxuICAgIC8vIFJlcXVpcmVzIGEgaGFzaCwgb3B0aW9uYWxseSByZXF1aXJlcyAweCBwcmVmaXg7IHJldHVybnMgcHJlZml4ZWQgbG93ZXJjYXNlIGhhc2guXG4gICAgaGFzaCh2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaGV4KHZhbHVlLCBzdHJpY3QpO1xuICAgICAgICBpZiAoaGV4RGF0YUxlbmd0aChyZXN1bHQpICE9PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgZGlmZmljdWx0eSBhcyBhIG51bWJlciwgb3IgaWYgdG9vIGxhcmdlIChpLmUuIFBvQSBuZXR3b3JrKSBudWxsXG4gICAgZGlmZmljdWx0eSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdiA9IEJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB2LnRvTnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHVpbnQyNTYodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludDI1NlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4WmVyb1BhZCh2YWx1ZSwgMzIpO1xuICAgIH1cbiAgICBfYmxvY2sodmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAodmFsdWUuYXV0aG9yICE9IG51bGwgJiYgdmFsdWUubWluZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUubWluZXIgPSB2YWx1ZS5hdXRob3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGRpZmZpY3VsdHkgbWF5IG5lZWQgdG8gY29tZSBmcm9tIF9kaWZmaWN1bHR5IGluIHJlY3Vyc2VkIGJsb2Nrc1xuICAgICAgICBjb25zdCBkaWZmaWN1bHR5ID0gKHZhbHVlLl9kaWZmaWN1bHR5ICE9IG51bGwpID8gdmFsdWUuX2RpZmZpY3VsdHkgOiB2YWx1ZS5kaWZmaWN1bHR5O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBGb3JtYXR0ZXIuY2hlY2soZm9ybWF0LCB2YWx1ZSk7XG4gICAgICAgIHJlc3VsdC5fZGlmZmljdWx0eSA9ICgoZGlmZmljdWx0eSA9PSBudWxsKSA/IG51bGwgOiBCaWdOdW1iZXIuZnJvbShkaWZmaWN1bHR5KSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGJsb2NrKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ibG9jayh2YWx1ZSwgdGhpcy5mb3JtYXRzLmJsb2NrKTtcbiAgICB9XG4gICAgYmxvY2tXaXRoVHJhbnNhY3Rpb25zKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ibG9jayh2YWx1ZSwgdGhpcy5mb3JtYXRzLmJsb2NrV2l0aFRyYW5zYWN0aW9ucyk7XG4gICAgfVxuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICB0cmFuc2FjdGlvblJlcXVlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMudHJhbnNhY3Rpb25SZXF1ZXN0LCB2YWx1ZSk7XG4gICAgfVxuICAgIHRyYW5zYWN0aW9uUmVzcG9uc2UodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgLy8gUmVuYW1lIGdhcyB0byBnYXNMaW1pdFxuICAgICAgICBpZiAodHJhbnNhY3Rpb24uZ2FzICE9IG51bGwgJiYgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPSB0cmFuc2FjdGlvbi5nYXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSBjbGllbnRzIChUZXN0UlBDKSBkbyBzdHJhbmdlIHRoaW5ncyBsaWtlIHJldHVybiAweDAgZm9yIHRoZVxuICAgICAgICAvLyAwIGFkZHJlc3M7IGNvcnJlY3QgdGhpcyB0byBiZSBhIHJlYWwgYWRkcmVzc1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24udG8gJiYgQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24udG8pLmlzWmVybygpKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi50byA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuYW1lIGlucHV0IHRvIGRhdGFcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmlucHV0ICE9IG51bGwgJiYgdHJhbnNhY3Rpb24uZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5kYXRhID0gdHJhbnNhY3Rpb24uaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdG8gYW5kIGNyZWF0ZXMgYXJlIGVtcHR5LCBwb3B1bGF0ZSB0aGUgY3JlYXRlcyBmcm9tIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udG8gPT0gbnVsbCAmJiB0cmFuc2FjdGlvbi5jcmVhdGVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmNyZWF0ZXMgPSB0aGlzLmNvbnRyYWN0QWRkcmVzcyh0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0cmFuc2FjdGlvbi50eXBlID09PSAxIHx8IHRyYW5zYWN0aW9uLnR5cGUgPT09IDIpICYmIHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWNjZXNzTGlzdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMudHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGNoYWluSWQpKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY2hhaW5JZCA9IHRyYW5zYWN0aW9uLm5ldHdvcmtJZDtcbiAgICAgICAgICAgIC8vIGdldGgtZXRjIHJldHVybnMgY2hhaW5JZFxuICAgICAgICAgICAgaWYgKGNoYWluSWQgPT0gbnVsbCAmJiByZXN1bHQudiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IHRyYW5zYWN0aW9uLmNoYWluSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGNoYWluSWQpICE9PSBcIm51bWJlclwiICYmIHJlc3VsdC52ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gKHJlc3VsdC52IC0gMzUpIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAoY2hhaW5JZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYWluSWQgPSBwYXJzZUludChjaGFpbklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMHgwMDAwLi4uIHNob3VsZCBhY3R1YWxseSBiZSBudWxsXG4gICAgICAgIGlmIChyZXN1bHQuYmxvY2tIYXNoICYmIHJlc3VsdC5ibG9ja0hhc2gucmVwbGFjZSgvMC9nLCBcIlwiKSA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ibG9ja0hhc2ggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRyYW5zYWN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVRyYW5zYWN0aW9uKHZhbHVlKTtcbiAgICB9XG4gICAgcmVjZWlwdExvZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5yZWNlaXB0TG9nLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJlY2VpcHQodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5yZWNlaXB0LCB2YWx1ZSk7XG4gICAgICAgIC8vIFJTSyBpbmNvcnJlY3RseSBpbXBsZW1lbnRlZCBFSVAtNjU4LCBzbyB3ZSBtdW5nZSB0aGluZ3MgYSBiaXQgaGVyZSBmb3IgaXRcbiAgICAgICAgaWYgKHJlc3VsdC5yb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucm9vdC5sZW5ndGggPD0gNCkge1xuICAgICAgICAgICAgICAgIC8vIENvdWxkIGJlIDB4MDAsIDB4MCwgMHgwMSBvciAweDFcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEJpZ051bWJlci5mcm9tKHJlc3VsdC5yb290KS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMCB8fCB2YWx1ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgaWYgYm90aCBhcmUgc3BlY2lmaWVkLCB0aGV5IG1hdGNoXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzICE9IG51bGwgJiYgKHJlc3VsdC5zdGF0dXMgIT09IHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFsdC1yb290LXN0YXR1cy9zdGF0dXMgbWlzbWF0Y2hcIiwgXCJ2YWx1ZVwiLCB7IHJvb3Q6IHJlc3VsdC5yb290LCBzdGF0dXM6IHJlc3VsdC5zdGF0dXMgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXR1cyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0LnJvb3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhbHQtcm9vdC1zdGF0dXNcIiwgXCJ2YWx1ZS5yb290XCIsIHJlc3VsdC5yb290KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQucm9vdC5sZW5ndGggIT09IDY2KSB7XG4gICAgICAgICAgICAgICAgLy8gTXVzdCBiZSBhIHZhbGlkIGJ5dGVzMzJcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCByb290IGhhc2hcIiwgXCJ2YWx1ZS5yb290XCIsIHJlc3VsdC5yb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYnl6YW50aXVtID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0b3BpY3ModmFsdWUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiB0aGlzLnRvcGljcyh2KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzaCh2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZpbHRlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5maWx0ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgZmlsdGVyTG9nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLmZpbHRlckxvZywgdmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgY2hlY2soZm9ybWF0LCBvYmplY3QpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGZvcm1hdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdFtrZXldKG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yLmNoZWNrS2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIGVycm9yLmNoZWNrVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBpZiB2YWx1ZSBpcyBudWxsLWlzaCwgbnVsbFZhbHVlIGlzIHJldHVybmVkXG4gICAgc3RhdGljIGFsbG93TnVsbChmb3JtYXQsIG51bGxWYWx1ZSkge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBJZiB2YWx1ZSBpcyBmYWxzZS1pc2gsIHJlcGxhY2VWYWx1ZSBpcyByZXR1cm5lZFxuICAgIHN0YXRpYyBhbGxvd0ZhbHNpc2goZm9ybWF0LCByZXBsYWNlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBSZXF1aXJlcyBhbiBBcnJheSBzYXRpc2Z5aW5nIGNoZWNrXG4gICAgc3RhdGljIGFycmF5T2YoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZvcm1hdCh2YWx1ZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDb21tdW5pdHlSZXNvdXJjYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5pc0NvbW11bml0eVJlc291cmNlKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbW11bml0eVJlc291cmNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc0NvbW11bml0eVJlc291cmNhYmxlKHZhbHVlKSAmJiB2YWx1ZS5pc0NvbW11bml0eVJlc291cmNlKCkpO1xufVxuLy8gU2hvdyB0aGUgdGhyb3R0bGUgbWVzc2FnZSBvbmx5IG9uY2VcbmxldCB0aHJvdHRsZU1lc3NhZ2UgPSBmYWxzZTtcbmV4cG9ydCBmdW5jdGlvbiBzaG93VGhyb3R0bGVNZXNzYWdlKCkge1xuICAgIGlmICh0aHJvdHRsZU1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdHRsZU1lc3NhZ2UgPSB0cnVlO1xuICAgIGNvbnNvbGUubG9nKFwiPT09PT09PT09IE5PVElDRSA9PT09PT09PT1cIik7XG4gICAgY29uc29sZS5sb2coXCJSZXF1ZXN0LVJhdGUgRXhjZWVkZWQgICh0aGlzIG1lc3NhZ2Ugd2lsbCBub3QgYmUgcmVwZWF0ZWQpXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiVGhlIGRlZmF1bHQgQVBJIGtleXMgZm9yIGVhY2ggc2VydmljZSBhcmUgcHJvdmlkZWQgYXMgYSBoaWdobHktdGhyb3R0bGVkLFwiKTtcbiAgICBjb25zb2xlLmxvZyhcImNvbW11bml0eSByZXNvdXJjZSBmb3IgbG93LXRyYWZmaWMgcHJvamVjdHMgYW5kIGVhcmx5IHByb3RvdHlwaW5nLlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIldoaWxlIHlvdXIgYXBwbGljYXRpb24gd2lsbCBjb250aW51ZSB0byBmdW5jdGlvbiwgd2UgaGlnaGx5IHJlY29tbWVuZGVkXCIpO1xuICAgIGNvbnNvbGUubG9nKFwic2lnbmluZyB1cCBmb3IgeW91ciBvd24gQVBJIGtleXMgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSwgaW5jcmVhc2UgeW91clwiKTtcbiAgICBjb25zb2xlLmxvZyhcInJlcXVlc3QgcmF0ZS9saW1pdCBhbmQgZW5hYmxlIG90aGVyIHBlcmtzLCBzdWNoIGFzIG1ldHJpY3MgYW5kIGFkdmFuY2VkIEFQSXMuXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiRm9yIG1vcmUgZGV0YWlsczogaHR0cHM6L1xcL2RvY3MuZXRoZXJzLmlvL2FwaS1rZXlzL1wiKTtcbiAgICBjb25zb2xlLmxvZyhcIj09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRBZGRyZXNzIiwiZ2V0Q29udHJhY3RBZGRyZXNzIiwiQmlnTnVtYmVyIiwiaGV4RGF0YUxlbmd0aCIsImhleERhdGFTbGljZSIsImhleFZhbHVlIiwiaGV4WmVyb1BhZCIsImlzSGV4U3RyaW5nIiwiQWRkcmVzc1plcm8iLCJzaGFsbG93Q29weSIsImFjY2Vzc0xpc3RpZnkiLCJwYXJzZSIsInBhcnNlVHJhbnNhY3Rpb24iLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiRm9ybWF0dGVyIiwiY29uc3RydWN0b3IiLCJmb3JtYXRzIiwiZ2V0RGVmYXVsdEZvcm1hdHMiLCJhZGRyZXNzIiwiYmluZCIsImJpZ051bWJlciIsImJsb2NrVGFnIiwiZGF0YSIsImhhc2giLCJoZXgiLCJudW1iZXIiLCJ0eXBlIiwic3RyaWN0RGF0YSIsInYiLCJ0cmFuc2FjdGlvbiIsImFjY2Vzc0xpc3QiLCJhbGxvd051bGwiLCJibG9ja0hhc2giLCJibG9ja051bWJlciIsInRyYW5zYWN0aW9uSW5kZXgiLCJjb25maXJtYXRpb25zIiwiZnJvbSIsImdhc1ByaWNlIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJtYXhGZWVQZXJHYXMiLCJnYXNMaW1pdCIsInRvIiwidmFsdWUiLCJub25jZSIsInIiLCJ1aW50MjU2IiwicyIsImNyZWF0ZXMiLCJyYXciLCJ0cmFuc2FjdGlvblJlcXVlc3QiLCJyZWNlaXB0TG9nIiwidHJhbnNhY3Rpb25IYXNoIiwidG9waWNzIiwiYXJyYXlPZiIsImxvZ0luZGV4IiwicmVjZWlwdCIsImNvbnRyYWN0QWRkcmVzcyIsInJvb3QiLCJnYXNVc2VkIiwibG9nc0Jsb29tIiwibG9ncyIsImN1bXVsYXRpdmVHYXNVc2VkIiwiZWZmZWN0aXZlR2FzUHJpY2UiLCJzdGF0dXMiLCJibG9jayIsInBhcmVudEhhc2giLCJ0aW1lc3RhbXAiLCJkaWZmaWN1bHR5IiwibWluZXIiLCJleHRyYURhdGEiLCJ0cmFuc2FjdGlvbnMiLCJiYXNlRmVlUGVyR2FzIiwiYmxvY2tXaXRoVHJhbnNhY3Rpb25zIiwidHJhbnNhY3Rpb25SZXNwb25zZSIsImZpbHRlciIsImZyb21CbG9jayIsInVuZGVmaW5lZCIsInRvQmxvY2siLCJmaWx0ZXJMb2ciLCJyZW1vdmVkIiwiYm9vbGVhbiIsImFsbG93RmFsc2lzaCIsInRvTnVtYmVyIiwidG9Mb3dlckNhc2UiLCJFcnJvciIsInN0cmljdCIsInN1YnN0cmluZyIsInRocm93QXJndW1lbnRFcnJvciIsInJlc3VsdCIsImxlbmd0aCIsImNhbGxBZGRyZXNzIiwiZXJyb3IiLCJfYmxvY2siLCJmb3JtYXQiLCJhdXRob3IiLCJfZGlmZmljdWx0eSIsImNoZWNrIiwiZ2FzIiwiaXNaZXJvIiwiaW5wdXQiLCJjaGFpbklkIiwibmV0d29ya0lkIiwicGFyc2VJbnQiLCJyZXBsYWNlIiwiYnl6YW50aXVtIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwib2JqZWN0Iiwia2V5IiwiY2hlY2tLZXkiLCJjaGVja1ZhbHVlIiwibnVsbFZhbHVlIiwicmVwbGFjZVZhbHVlIiwiYXJyYXkiLCJmb3JFYWNoIiwicHVzaCIsImlzQ29tbXVuaXR5UmVzb3VyY2FibGUiLCJpc0NvbW11bml0eVJlc291cmNlIiwidGhyb3R0bGVNZXNzYWdlIiwic2hvd1Rocm90dGxlTWVzc2FnZSIsImNvbnNvbGUiLCJsb2ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/providers/lib.esm/formatter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/providers/lib.esm/infura-provider.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/infura-provider.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InfuraProvider: () => (/* binding */ InfuraProvider),\n/* harmony export */   InfuraWebSocketProvider: () => (/* binding */ InfuraWebSocketProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _websocket_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./websocket-provider */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js\");\n/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatter */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/formatter.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./url-json-rpc-provider */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\");\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst defaultProjectId = \"84842078b09946638c03157f83405213\";\nclass InfuraWebSocketProvider extends _websocket_provider__WEBPACK_IMPORTED_MODULE_2__.WebSocketProvider {\n    constructor(network, apiKey){\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"apiKey\", provider.projectId);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"projectId\", provider.projectId);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"projectSecret\", provider.projectSecret);\n    }\n    isCommunityResource() {\n        return this.projectId === defaultProjectId;\n    }\n}\nclass InfuraProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_4__.UrlJsonRpcProvider {\n    static getWebSocketProvider(network, apiKey) {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n    static getApiKey(apiKey) {\n        const apiKeyObj = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n        if (apiKey == null) {\n            return apiKeyObj;\n        }\n        if (typeof apiKey === \"string\") {\n            apiKeyObj.projectId = apiKey;\n        } else if (apiKey.projectSecret != null) {\n            logger.assertArgument(typeof apiKey.projectId === \"string\", \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument(typeof apiKey.projectSecret === \"string\", \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n        } else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n        return apiKeyObj;\n    }\n    static getUrl(network, apiKey) {\n        let host = null;\n        switch(network ? network.name : \"unknown\"){\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"sepolia\":\n                host = \"sepolia.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            case \"optimism\":\n                host = \"optimism-mainnet.infura.io\";\n                break;\n            case \"optimism-goerli\":\n                host = \"optimism-goerli.infura.io\";\n                break;\n            case \"arbitrum\":\n                host = \"arbitrum-mainnet.infura.io\";\n                break;\n            case \"arbitrum-goerli\":\n                host = \"arbitrum-goerli.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n        const connection = {\n            allowGzip: true,\n            url: \"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId,\n            throttleCallback: (attempt, url)=>{\n                if (apiKey.projectId === defaultProjectId) {\n                    (0,_formatter__WEBPACK_IMPORTED_MODULE_5__.showThrottleMessage)();\n                }\n                return Promise.resolve(true);\n            }\n        };\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret;\n        }\n        return connection;\n    }\n    isCommunityResource() {\n        return this.projectId === defaultProjectId;\n    }\n} //# sourceMappingURL=infura-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vaW5mdXJhLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWE7QUFDOEM7QUFDRjtBQUNQO0FBQ0g7QUFDVjtBQUNyQyxNQUFNSyxTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDNEI7QUFDN0QsTUFBTUcsbUJBQW1CO0FBQ2xCLE1BQU1DLGdDQUFnQ1Asa0VBQWlCQTtJQUMxRFEsWUFBWUMsT0FBTyxFQUFFQyxNQUFNLENBQUU7UUFDekIsTUFBTUMsV0FBVyxJQUFJQyxlQUFlSCxTQUFTQztRQUM3QyxNQUFNRyxhQUFhRixTQUFTRSxVQUFVO1FBQ3RDLElBQUlBLFdBQVdDLFFBQVEsRUFBRTtZQUNyQlYsT0FBT1csVUFBVSxDQUFDLGdEQUFnRGIseURBQU1BLENBQUNjLE1BQU0sQ0FBQ0MscUJBQXFCLEVBQUU7Z0JBQ25HQyxXQUFXO1lBQ2Y7UUFDSjtRQUNBLE1BQU1DLE1BQU1OLFdBQVdNLEdBQUcsQ0FBQ0MsT0FBTyxDQUFDLFVBQVUsTUFBTUEsT0FBTyxDQUFDLFFBQVE7UUFDbkUsS0FBSyxDQUFDRCxLQUFLVjtRQUNYVix5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsVUFBVVksU0FBU1UsU0FBUztRQUNqRHRCLHlFQUFjQSxDQUFDLElBQUksRUFBRSxhQUFhWSxTQUFTVSxTQUFTO1FBQ3BEdEIseUVBQWNBLENBQUMsSUFBSSxFQUFFLGlCQUFpQlksU0FBU1csYUFBYTtJQUNoRTtJQUNBQyxzQkFBc0I7UUFDbEIsT0FBUSxJQUFJLENBQUNGLFNBQVMsS0FBS2Y7SUFDL0I7QUFDSjtBQUNPLE1BQU1NLHVCQUF1QlAsc0VBQWtCQTtJQUNsRCxPQUFPbUIscUJBQXFCZixPQUFPLEVBQUVDLE1BQU0sRUFBRTtRQUN6QyxPQUFPLElBQUlILHdCQUF3QkUsU0FBU0M7SUFDaEQ7SUFDQSxPQUFPZSxVQUFVZixNQUFNLEVBQUU7UUFDckIsTUFBTWdCLFlBQVk7WUFDZGhCLFFBQVFKO1lBQ1JlLFdBQVdmO1lBQ1hnQixlQUFlO1FBQ25CO1FBQ0EsSUFBSVosVUFBVSxNQUFNO1lBQ2hCLE9BQU9nQjtRQUNYO1FBQ0EsSUFBSSxPQUFRaEIsV0FBWSxVQUFVO1lBQzlCZ0IsVUFBVUwsU0FBUyxHQUFHWDtRQUMxQixPQUNLLElBQUlBLE9BQU9ZLGFBQWEsSUFBSSxNQUFNO1lBQ25DbEIsT0FBT3VCLGNBQWMsQ0FBRSxPQUFRakIsT0FBT1csU0FBUyxLQUFNLFVBQVcsc0NBQXNDLGFBQWFYLE9BQU9XLFNBQVM7WUFDbklqQixPQUFPdUIsY0FBYyxDQUFFLE9BQVFqQixPQUFPWSxhQUFhLEtBQU0sVUFBVyx5QkFBeUIsaUJBQWlCO1lBQzlHSSxVQUFVTCxTQUFTLEdBQUdYLE9BQU9XLFNBQVM7WUFDdENLLFVBQVVKLGFBQWEsR0FBR1osT0FBT1ksYUFBYTtRQUNsRCxPQUNLLElBQUlaLE9BQU9XLFNBQVMsRUFBRTtZQUN2QkssVUFBVUwsU0FBUyxHQUFHWCxPQUFPVyxTQUFTO1FBQzFDO1FBQ0FLLFVBQVVoQixNQUFNLEdBQUdnQixVQUFVTCxTQUFTO1FBQ3RDLE9BQU9LO0lBQ1g7SUFDQSxPQUFPRSxPQUFPbkIsT0FBTyxFQUFFQyxNQUFNLEVBQUU7UUFDM0IsSUFBSW1CLE9BQU87UUFDWCxPQUFRcEIsVUFBVUEsUUFBUXFCLElBQUksR0FBRztZQUM3QixLQUFLO2dCQUNERCxPQUFPO2dCQUNQO1lBQ0osS0FBSztnQkFDREEsT0FBTztnQkFDUDtZQUNKLEtBQUs7Z0JBQ0RBLE9BQU87Z0JBQ1A7WUFDSixLQUFLO2dCQUNEQSxPQUFPO2dCQUNQO1lBQ0osS0FBSztnQkFDREEsT0FBTztnQkFDUDtZQUNKLEtBQUs7Z0JBQ0RBLE9BQU87Z0JBQ1A7WUFDSixLQUFLO2dCQUNEQSxPQUFPO2dCQUNQO1lBQ0osS0FBSztnQkFDREEsT0FBTztnQkFDUDtZQUNKLEtBQUs7Z0JBQ0RBLE9BQU87Z0JBQ1A7WUFDSjtnQkFDSXpCLE9BQU9XLFVBQVUsQ0FBQyx1QkFBdUJiLHlEQUFNQSxDQUFDYyxNQUFNLENBQUNlLGdCQUFnQixFQUFFO29CQUNyRUMsVUFBVTtvQkFDVkMsT0FBT3hCO2dCQUNYO1FBQ1I7UUFDQSxNQUFNSSxhQUFhO1lBQ2ZxQixXQUFXO1lBQ1hmLEtBQU0sWUFBWSxNQUFNVSxPQUFPLFNBQVNuQixPQUFPVyxTQUFTO1lBQ3hEYyxrQkFBa0IsQ0FBQ0MsU0FBU2pCO2dCQUN4QixJQUFJVCxPQUFPVyxTQUFTLEtBQUtmLGtCQUFrQjtvQkFDdkNMLCtEQUFtQkE7Z0JBQ3ZCO2dCQUNBLE9BQU9vQyxRQUFRQyxPQUFPLENBQUM7WUFDM0I7UUFDSjtRQUNBLElBQUk1QixPQUFPWSxhQUFhLElBQUksTUFBTTtZQUM5QlQsV0FBVzBCLElBQUksR0FBRztZQUNsQjFCLFdBQVdDLFFBQVEsR0FBR0osT0FBT1ksYUFBYTtRQUM5QztRQUNBLE9BQU9UO0lBQ1g7SUFDQVUsc0JBQXNCO1FBQ2xCLE9BQVEsSUFBSSxDQUFDRixTQUFTLEtBQUtmO0lBQy9CO0FBQ0osRUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2luZnVyYS1wcm92aWRlci5qcz84MzI2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgV2ViU29ja2V0UHJvdmlkZXIgfSBmcm9tIFwiLi93ZWJzb2NrZXQtcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNob3dUaHJvdHRsZU1lc3NhZ2UgfSBmcm9tIFwiLi9mb3JtYXR0ZXJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IFVybEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL3VybC1qc29uLXJwYy1wcm92aWRlclwiO1xuY29uc3QgZGVmYXVsdFByb2plY3RJZCA9IFwiODQ4NDIwNzhiMDk5NDY2MzhjMDMxNTdmODM0MDUyMTNcIjtcbmV4cG9ydCBjbGFzcyBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlciBleHRlbmRzIFdlYlNvY2tldFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgSW5mdXJhUHJvdmlkZXIobmV0d29yaywgYXBpS2V5KTtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHByb3ZpZGVyLmNvbm5lY3Rpb247XG4gICAgICAgIGlmIChjb25uZWN0aW9uLnBhc3N3b3JkKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIklORlVSQSBXZWJTb2NrZXQgcHJvamVjdCBzZWNyZXRzIHVuc3VwcG9ydGVkXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIkluZnVyYVByb3ZpZGVyLmdldFdlYlNvY2tldFByb3ZpZGVyKClcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gY29ubmVjdGlvbi51cmwucmVwbGFjZSgvXmh0dHAvaSwgXCJ3c1wiKS5yZXBsYWNlKFwiL3YzL1wiLCBcIi93cy92My9cIik7XG4gICAgICAgIHN1cGVyKHVybCwgbmV0d29yayk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYXBpS2V5XCIsIHByb3ZpZGVyLnByb2plY3RJZCk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvamVjdElkXCIsIHByb3ZpZGVyLnByb2plY3RJZCk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvamVjdFNlY3JldFwiLCBwcm92aWRlci5wcm9qZWN0U2VjcmV0KTtcbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnByb2plY3RJZCA9PT0gZGVmYXVsdFByb2plY3RJZCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEluZnVyYVByb3ZpZGVyIGV4dGVuZHMgVXJsSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBzdGF0aWMgZ2V0V2ViU29ja2V0UHJvdmlkZXIobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIobmV0d29yaywgYXBpS2V5KTtcbiAgICB9XG4gICAgc3RhdGljIGdldEFwaUtleShhcGlLZXkpIHtcbiAgICAgICAgY29uc3QgYXBpS2V5T2JqID0ge1xuICAgICAgICAgICAgYXBpS2V5OiBkZWZhdWx0UHJvamVjdElkLFxuICAgICAgICAgICAgcHJvamVjdElkOiBkZWZhdWx0UHJvamVjdElkLFxuICAgICAgICAgICAgcHJvamVjdFNlY3JldDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhcGlLZXlPYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYXBpS2V5KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYXBpS2V5T2JqLnByb2plY3RJZCA9IGFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcGlLZXkucHJvamVjdFNlY3JldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKHR5cGVvZiAoYXBpS2V5LnByb2plY3RJZCkgPT09IFwic3RyaW5nXCIpLCBcInByb2plY3RTZWNyZXQgcmVxdWlyZXMgYSBwcm9qZWN0SWRcIiwgXCJwcm9qZWN0SWRcIiwgYXBpS2V5LnByb2plY3RJZCk7XG4gICAgICAgICAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKHR5cGVvZiAoYXBpS2V5LnByb2plY3RTZWNyZXQpID09PSBcInN0cmluZ1wiKSwgXCJpbnZhbGlkIHByb2plY3RTZWNyZXRcIiwgXCJwcm9qZWN0U2VjcmV0XCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgICAgIGFwaUtleU9iai5wcm9qZWN0SWQgPSBhcGlLZXkucHJvamVjdElkO1xuICAgICAgICAgICAgYXBpS2V5T2JqLnByb2plY3RTZWNyZXQgPSBhcGlLZXkucHJvamVjdFNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcGlLZXkucHJvamVjdElkKSB7XG4gICAgICAgICAgICBhcGlLZXlPYmoucHJvamVjdElkID0gYXBpS2V5LnByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBhcGlLZXlPYmouYXBpS2V5ID0gYXBpS2V5T2JqLnByb2plY3RJZDtcbiAgICAgICAgcmV0dXJuIGFwaUtleU9iajtcbiAgICB9XG4gICAgc3RhdGljIGdldFVybChuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgbGV0IGhvc3QgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKG5ldHdvcmsgPyBuZXR3b3JrLm5hbWUgOiBcInVua25vd25cIikge1xuICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcIm1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZ29lcmxpLmluZnVyYS5pb1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNlcG9saWFcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJzZXBvbGlhLmluZnVyYS5pb1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1hdGljXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwicG9seWdvbi1tYWlubmV0LmluZnVyYS5pb1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1hdGljbXVtXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwicG9seWdvbi1tdW1iYWkuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwib3B0aW1pc21cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJvcHRpbWlzbS1tYWlubmV0LmluZnVyYS5pb1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9wdGltaXNtLWdvZXJsaVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcIm9wdGltaXNtLWdvZXJsaS5pbmZ1cmEuaW9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhcmJpdHJ1bVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImFyYml0cnVtLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXJiaXRydW0tZ29lcmxpXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiYXJiaXRydW0tZ29lcmxpLmluZnVyYS5pb1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBcIm5ldHdvcmtcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ldHdvcmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgYWxsb3dHemlwOiB0cnVlLFxuICAgICAgICAgICAgdXJsOiAoXCJodHRwczovXCIgKyBcIi9cIiArIGhvc3QgKyBcIi92My9cIiArIGFwaUtleS5wcm9qZWN0SWQpLFxuICAgICAgICAgICAgdGhyb3R0bGVDYWxsYmFjazogKGF0dGVtcHQsIHVybCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhcGlLZXkucHJvamVjdElkID09PSBkZWZhdWx0UHJvamVjdElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dUaHJvdHRsZU1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFwaUtleS5wcm9qZWN0U2VjcmV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24udXNlciA9IFwiXCI7XG4gICAgICAgICAgICBjb25uZWN0aW9uLnBhc3N3b3JkID0gYXBpS2V5LnByb2plY3RTZWNyZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfVxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wcm9qZWN0SWQgPT09IGRlZmF1bHRQcm9qZWN0SWQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZnVyYS1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiZGVmaW5lUmVhZE9ubHkiLCJXZWJTb2NrZXRQcm92aWRlciIsInNob3dUaHJvdHRsZU1lc3NhZ2UiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiVXJsSnNvblJwY1Byb3ZpZGVyIiwiZGVmYXVsdFByb2plY3RJZCIsIkluZnVyYVdlYlNvY2tldFByb3ZpZGVyIiwiY29uc3RydWN0b3IiLCJuZXR3b3JrIiwiYXBpS2V5IiwicHJvdmlkZXIiLCJJbmZ1cmFQcm92aWRlciIsImNvbm5lY3Rpb24iLCJwYXNzd29yZCIsInRocm93RXJyb3IiLCJlcnJvcnMiLCJVTlNVUFBPUlRFRF9PUEVSQVRJT04iLCJvcGVyYXRpb24iLCJ1cmwiLCJyZXBsYWNlIiwicHJvamVjdElkIiwicHJvamVjdFNlY3JldCIsImlzQ29tbXVuaXR5UmVzb3VyY2UiLCJnZXRXZWJTb2NrZXRQcm92aWRlciIsImdldEFwaUtleSIsImFwaUtleU9iaiIsImFzc2VydEFyZ3VtZW50IiwiZ2V0VXJsIiwiaG9zdCIsIm5hbWUiLCJJTlZBTElEX0FSR1VNRU5UIiwiYXJndW1lbnQiLCJ2YWx1ZSIsImFsbG93R3ppcCIsInRocm90dGxlQ2FsbGJhY2siLCJhdHRlbXB0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJ1c2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/providers/lib.esm/infura-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonRpcProvider: () => (/* binding */ JsonRpcProvider),\n/* harmony export */   JsonRpcSigner: () => (/* binding */ JsonRpcSigner)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/abstract-signer */ \"(ssr)/./node_modules/@ethersproject/abstract-signer/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/hash */ \"(ssr)/./node_modules/@ethersproject/hash/lib.esm/typed-data.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/./node_modules/@ethersproject/transactions/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/web */ \"(ssr)/./node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./base-provider */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/base-provider.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nconst errorGas = [\n    \"call\",\n    \"estimateGas\"\n];\nfunction spelunk(value, requireData) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof value.message === \"string\" && value.message.match(\"reverted\")) {\n        const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isHexString)(value.data) ? value.data : null;\n        if (!requireData || data) {\n            return {\n                message: value.message,\n                data\n            };\n        }\n    }\n    // Spelunk further...\n    if (typeof value === \"object\") {\n        for(const key in value){\n            const result = spelunk(value[key], requireData);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof value === \"string\") {\n        try {\n            return spelunk(JSON.parse(value), requireData);\n        } catch (error) {}\n    }\n    return null;\n}\nfunction checkError(method, error, params) {\n    const transaction = params.transaction || params.signedTransaction;\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\") {\n        const result = spelunk(error, true);\n        if (result) {\n            return result.data;\n        }\n        // Nothing descriptive..\n        logger.throwError(\"missing revert data in call exception; Transaction reverted without a reason string\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION, {\n            data: \"0x\",\n            transaction,\n            error\n        });\n    }\n    if (method === \"estimateGas\") {\n        // Try to find something, with a preference on SERVER_ERROR body\n        let result = spelunk(error.body, false);\n        if (result == null) {\n            result = spelunk(error, false);\n        }\n        // Found \"reverted\", this is a CALL_EXCEPTION\n        if (result) {\n            logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                reason: result.message,\n                method,\n                transaction,\n                error\n            });\n        }\n    }\n    // @TODO: Should we spelunk for message too?\n    let message = error.message;\n    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === \"string\") {\n        message = error.error.message;\n    } else if (typeof error.body === \"string\") {\n        message = error.body;\n    } else if (typeof error.responseText === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INSUFFICIENT_FUNDS, {\n            error,\n            method,\n            transaction\n        });\n    }\n    // \"nonce too low\"\n    if (message.match(/nonce (is )?too low/i)) {\n        logger.throwError(\"nonce has already been used\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NONCE_EXPIRED, {\n            error,\n            method,\n            transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {\n        logger.throwError(\"replacement fee too low\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error,\n            method,\n            transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/i)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            error,\n            method,\n            transaction\n        });\n    }\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error,\n            method,\n            transaction\n        });\n    }\n    throw error;\n}\nfunction timer(timeout) {\n    return new Promise(function(resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\nfunction getResult(payload) {\n    if (payload.error) {\n        // @TODO: not any\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nconst _constructorGuard = {};\nclass JsonRpcSigner extends _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_3__.Signer {\n    constructor(constructorGuard, provider, addressOrIndex){\n        super();\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"provider\", provider);\n        if (addressOrIndex == null) {\n            addressOrIndex = 0;\n        }\n        if (typeof addressOrIndex === \"string\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_index\", null);\n        } else if (typeof addressOrIndex === \"number\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_index\", addressOrIndex);\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"_address\", null);\n        } else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n    connect(provider) {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n    connectUnchecked() {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n    getAddress() {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n        return this.provider.send(\"eth_accounts\", []).then((accounts)=>{\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index]);\n        });\n    }\n    sendUncheckedTransaction(transaction) {\n        transaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(transaction);\n        const fromAddress = this.getAddress().then((address)=>{\n            if (address) {\n                address = address.toLowerCase();\n            }\n            return address;\n        });\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then((to)=>__awaiter(this, void 0, void 0, function*() {\n                    if (to == null) {\n                        return null;\n                    }\n                    const address = yield this.provider.resolveName(to);\n                    if (address == null) {\n                        logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                    }\n                    return address;\n                }));\n        }\n        return (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.resolveProperties)({\n            tx: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.resolveProperties)(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender })=>{\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            } else {\n                tx.from = sender;\n            }\n            const hexTx = this.provider.constructor.hexlifyTransaction(tx, {\n                from: true\n            });\n            return this.provider.send(\"eth_sendTransaction\", [\n                hexTx\n            ]).then((hash)=>{\n                return hash;\n            }, (error)=>{\n                if (typeof error.message === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected transaction\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"sendTransaction\",\n                        transaction: tx\n                    });\n                }\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n    signTransaction(transaction) {\n        return logger.throwError(\"signing transactions is unsupported\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // This cannot be mined any earlier than any recent block\n            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n            // Send the transaction\n            const hash = yield this.sendUncheckedTransaction(transaction);\n            try {\n                // Unfortunately, JSON-RPC only provides and opaque transaction hash\n                // for a response, and we need the actual transaction, so we poll\n                // for it; it should show up very quickly\n                return yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_5__.poll)(()=>__awaiter(this, void 0, void 0, function*() {\n                        const tx = yield this.provider.getTransaction(hash);\n                        if (tx === null) {\n                            return undefined;\n                        }\n                        return this.provider._wrapTransaction(tx, hash, blockNumber);\n                    }), {\n                    oncePoll: this.provider\n                });\n            } catch (error) {\n                error.transactionHash = hash;\n                throw error;\n            }\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const data = typeof message === \"string\" ? (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_6__.toUtf8Bytes)(message) : message;\n            const address = yield this.getAddress();\n            try {\n                return yield this.provider.send(\"personal_sign\", [\n                    (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data),\n                    address.toLowerCase()\n                ]);\n            } catch (error) {\n                if (typeof error.message === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"signMessage\",\n                        from: address,\n                        messageData: message\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    _legacySignMessage(message) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const data = typeof message === \"string\" ? (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_6__.toUtf8Bytes)(message) : message;\n            const address = yield this.getAddress();\n            try {\n                // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n                return yield this.provider.send(\"eth_sign\", [\n                    address.toLowerCase(),\n                    (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data)\n                ]);\n            } catch (error) {\n                if (typeof error.message === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"_legacySignMessage\",\n                        from: address,\n                        messageData: message\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    _signTypedData(domain, types, value) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // Populate any ENS names (in-place)\n            const populated = yield _ethersproject_hash__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.resolveNames(domain, types, value, (name)=>{\n                return this.provider.resolveName(name);\n            });\n            const address = yield this.getAddress();\n            try {\n                return yield this.provider.send(\"eth_signTypedData_v4\", [\n                    address.toLowerCase(),\n                    JSON.stringify(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n                ]);\n            } catch (error) {\n                if (typeof error.message === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.ACTION_REJECTED, {\n                        action: \"_signTypedData\",\n                        from: address,\n                        messageData: {\n                            domain: populated.domain,\n                            types,\n                            value: populated.value\n                        }\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    unlock(password) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const provider = this.provider;\n            const address = yield this.getAddress();\n            return provider.send(\"personal_unlockAccount\", [\n                address.toLowerCase(),\n                password,\n                null\n            ]);\n        });\n    }\n}\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction) {\n        return this.sendUncheckedTransaction(transaction).then((hash)=>{\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations)=>{\n                    return this.provider.waitForTransaction(hash, confirmations);\n                }\n            };\n        });\n    }\n}\nconst allowedTransactionKeys = {\n    chainId: true,\n    data: true,\n    gasLimit: true,\n    gasPrice: true,\n    nonce: true,\n    to: true,\n    value: true,\n    type: true,\n    accessList: true,\n    maxFeePerGas: true,\n    maxPriorityFeePerGas: true\n};\nclass JsonRpcProvider extends _base_provider__WEBPACK_IMPORTED_MODULE_8__.BaseProvider {\n    constructor(url, network){\n        let networkOrReady = network;\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject)=>{\n                setTimeout(()=>{\n                    this.detectNetwork().then((network)=>{\n                        resolve(network);\n                    }, (error)=>{\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Default URL\n        if (!url) {\n            url = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"defaultUrl\")();\n        }\n        if (typeof url === \"string\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"connection\", Object.freeze({\n                url: url\n            }));\n        } else {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, \"connection\", Object.freeze((0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(url)));\n        }\n        this._nextId = 42;\n    }\n    get _cache() {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = {};\n        }\n        return this._eventLoopCache;\n    }\n    static defaultUrl() {\n        return \"http://localhost:8545\";\n    }\n    detectNetwork() {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(()=>{\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n    _uncachedDetectNetwork() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield timer(0);\n            let chainId = null;\n            try {\n                chainId = yield this.send(\"eth_chainId\", []);\n            } catch (error) {\n                try {\n                    chainId = yield this.send(\"net_version\", []);\n                } catch (error) {}\n            }\n            if (chainId != null) {\n                const getNetwork = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"getNetwork\");\n                try {\n                    return getNetwork(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__.BigNumber.from(chainId).toNumber());\n                } catch (error) {\n                    return logger.throwError(\"could not detect network\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NETWORK_ERROR, {\n                        chainId: chainId,\n                        event: \"invalidNetwork\",\n                        serverError: error\n                    });\n                }\n            }\n            return logger.throwError(\"could not detect network\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NETWORK_ERROR, {\n                event: \"noNetwork\"\n            });\n        });\n    }\n    getSigner(addressOrIndex) {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n    getUncheckedSigner(addressOrIndex) {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n    listAccounts() {\n        return this.send(\"eth_accounts\", []).then((accounts)=>{\n            return accounts.map((a)=>this.formatter.address(a));\n        });\n    }\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: this._nextId++,\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.deepCopy)(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = [\n            \"eth_chainId\",\n            \"eth_blockNumber\"\n        ].indexOf(method) >= 0;\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_5__.fetchJson)(this.connection, JSON.stringify(request), getResult).then((result)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(()=>{\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    prepareRequest(method, params) {\n        switch(method){\n            case \"getBlockNumber\":\n                return [\n                    \"eth_blockNumber\",\n                    []\n                ];\n            case \"getGasPrice\":\n                return [\n                    \"eth_gasPrice\",\n                    []\n                ];\n            case \"getBalance\":\n                return [\n                    \"eth_getBalance\",\n                    [\n                        getLowerCase(params.address),\n                        params.blockTag\n                    ]\n                ];\n            case \"getTransactionCount\":\n                return [\n                    \"eth_getTransactionCount\",\n                    [\n                        getLowerCase(params.address),\n                        params.blockTag\n                    ]\n                ];\n            case \"getCode\":\n                return [\n                    \"eth_getCode\",\n                    [\n                        getLowerCase(params.address),\n                        params.blockTag\n                    ]\n                ];\n            case \"getStorageAt\":\n                return [\n                    \"eth_getStorageAt\",\n                    [\n                        getLowerCase(params.address),\n                        (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexZeroPad)(params.position, 32),\n                        params.blockTag\n                    ]\n                ];\n            case \"sendTransaction\":\n                return [\n                    \"eth_sendRawTransaction\",\n                    [\n                        params.signedTransaction\n                    ]\n                ];\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [\n                        \"eth_getBlockByNumber\",\n                        [\n                            params.blockTag,\n                            !!params.includeTransactions\n                        ]\n                    ];\n                } else if (params.blockHash) {\n                    return [\n                        \"eth_getBlockByHash\",\n                        [\n                            params.blockHash,\n                            !!params.includeTransactions\n                        ]\n                    ];\n                }\n                return null;\n            case \"getTransaction\":\n                return [\n                    \"eth_getTransactionByHash\",\n                    [\n                        params.transactionHash\n                    ]\n                ];\n            case \"getTransactionReceipt\":\n                return [\n                    \"eth_getTransactionReceipt\",\n                    [\n                        params.transactionHash\n                    ]\n                ];\n            case \"call\":\n                {\n                    const hexlifyTransaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"hexlifyTransaction\");\n                    return [\n                        \"eth_call\",\n                        [\n                            hexlifyTransaction(params.transaction, {\n                                from: true\n                            }),\n                            params.blockTag\n                        ]\n                    ];\n                }\n            case \"estimateGas\":\n                {\n                    const hexlifyTransaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, \"hexlifyTransaction\");\n                    return [\n                        \"eth_estimateGas\",\n                        [\n                            hexlifyTransaction(params.transaction, {\n                                from: true\n                            })\n                        ]\n                    ];\n                }\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [\n                    \"eth_getLogs\",\n                    [\n                        params.filter\n                    ]\n                ];\n            default:\n                break;\n        }\n        return null;\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // Legacy networks do not like the type field being passed along (which\n            // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n            if (method === \"call\" || method === \"estimateGas\") {\n                const tx = params.transaction;\n                if (tx && tx.type != null && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__.BigNumber.from(tx.type).isZero()) {\n                    // If there are no EIP-1559 properties, it might be non-EIP-1559\n                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                        const feeData = yield this.getFeeData();\n                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                            // Network doesn't know about EIP-1559 (and hence type)\n                            params = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(params);\n                            params.transaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(tx);\n                            delete params.transaction.type;\n                        }\n                    }\n                }\n            }\n            const args = this.prepareRequest(method, params);\n            if (args == null) {\n                logger.throwError(method + \" not implemented\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NOT_IMPLEMENTED, {\n                    operation: method\n                });\n            }\n            try {\n                return yield this.send(args[0], args[1]);\n            } catch (error) {\n                return checkError(method, error, params);\n            }\n        });\n    }\n    _startEvent(event) {\n        if (event.tag === \"pending\") {\n            this._startPending();\n        }\n        super._startEvent(event);\n    }\n    _startPending() {\n        if (this._pendingFilter != null) {\n            return;\n        }\n        const self = this;\n        const pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n        pendingFilter.then(function(filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [\n                    filterId\n                ]).then(function(hashes) {\n                    if (self._pendingFilter != pendingFilter) {\n                        return null;\n                    }\n                    let seq = Promise.resolve();\n                    hashes.forEach(function(hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function() {\n                            return self.getTransaction(hash).then(function(tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n                    return seq.then(function() {\n                        return timer(1000);\n                    });\n                }).then(function() {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [\n                            filterId\n                        ]);\n                        return;\n                    }\n                    setTimeout(function() {\n                        poll();\n                    }, 0);\n                    return null;\n                }).catch((error)=>{});\n            }\n            poll();\n            return filterId;\n        }).catch((error)=>{});\n    }\n    _stopEvent(event) {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction, allowExtra) {\n        // Check only allowed properties are given\n        const allowed = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(allowedTransactionKeys);\n        if (allowExtra) {\n            for(const key in allowExtra){\n                if (allowExtra[key]) {\n                    allowed[key] = true;\n                }\n            }\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.checkProperties)(transaction, allowed);\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\n            \"chainId\",\n            \"gasLimit\",\n            \"gasPrice\",\n            \"type\",\n            \"maxFeePerGas\",\n            \"maxPriorityFeePerGas\",\n            \"nonce\",\n            \"value\"\n        ].forEach(function(key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            const value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexValue)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__.BigNumber.from(transaction[key]));\n            if (key === \"gasLimit\") {\n                key = \"gas\";\n            }\n            result[key] = value;\n        });\n        [\n            \"from\",\n            \"to\",\n            \"data\"\n        ].forEach(function(key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            result[key] = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(transaction[key]);\n        });\n        if (transaction.accessList) {\n            result[\"accessList\"] = (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_10__.accessListify)(transaction.accessList);\n        }\n        return result;\n    }\n} //# sourceMappingURL=json-rpc-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vanNvbi1ycGMtcHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ2IsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQ3dEO0FBQ0g7QUFDNkI7QUFDMUI7QUFDeUU7QUFDNUU7QUFDTztBQUNQO0FBQ047QUFDVjtBQUNyQyxNQUFNMEIsU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0Ms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VjtZQUNBL0IsTUFBTSxDQUFDK0IsSUFBSSxHQUFHeEM7UUFDbEI7UUFDQTtZQUFDO1lBQVE7WUFBTTtTQUFPLENBQUM2TCxPQUFPLENBQUMsU0FBVXJKLEdBQUc7WUFDeEMsSUFBSU8sV0FBVyxDQUFDUCxJQUFJLElBQUksTUFBTTtnQkFDMUI7WUFDSjtZQUNBL0IsTUFBTSxDQUFDK0IsSUFBSSxHQUFHekIsNkRBQU9BLENBQUNnQyxXQUFXLENBQUNQLElBQUk7UUFDMUM7UUFDQSxJQUFJTyxZQUFZeUYsVUFBVSxFQUFFO1lBQ3hCL0gsTUFBTSxDQUFDLGFBQWEsR0FBR2tCLDJFQUFhQSxDQUFDb0IsWUFBWXlGLFVBQVU7UUFDL0Q7UUFDQSxPQUFPL0g7SUFDWDtBQUNKLEVBQ0EsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1zdGFydGVyLWtpdC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9qc29uLXJwYy1wcm92aWRlci5qcz84Njc5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBTaWduZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWJzdHJhY3Qtc2lnbmVyXCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBoZXhsaWZ5LCBoZXhWYWx1ZSwgaGV4WmVyb1BhZCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IF9UeXBlZERhdGFFbmNvZGVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2hhc2hcIjtcbmltcG9ydCB7IGNoZWNrUHJvcGVydGllcywgZGVlcENvcHksIGRlZmluZVJlYWRPbmx5LCBnZXRTdGF0aWMsIHJlc29sdmVQcm9wZXJ0aWVzLCBzaGFsbG93Q29weSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgZmV0Y2hKc29uLCBwb2xsIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3dlYlwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgQmFzZVByb3ZpZGVyIH0gZnJvbSBcIi4vYmFzZS1wcm92aWRlclwiO1xuY29uc3QgZXJyb3JHYXMgPSBbXCJjYWxsXCIsIFwiZXN0aW1hdGVHYXNcIl07XG5mdW5jdGlvbiBzcGVsdW5rKHZhbHVlLCByZXF1aXJlRGF0YSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBUaGVzZSAqYXJlKiB0aGUgZHJvaWRzIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLm1lc3NhZ2UubWF0Y2goXCJyZXZlcnRlZFwiKSkge1xuICAgICAgICBjb25zdCBkYXRhID0gaXNIZXhTdHJpbmcodmFsdWUuZGF0YSkgPyB2YWx1ZS5kYXRhIDogbnVsbDtcbiAgICAgICAgaWYgKCFyZXF1aXJlRGF0YSB8fCBkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiB2YWx1ZS5tZXNzYWdlLCBkYXRhIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3BlbHVuayBmdXJ0aGVyLi4uXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzcGVsdW5rKHZhbHVlW2tleV0sIHJlcXVpcmVEYXRhKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBNaWdodCBiZSBhIEpTT04gc3RyaW5nIHdlIGNhbiBmdXJ0aGVyIGRlc2NlbmQuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzcGVsdW5rKEpTT04ucGFyc2UodmFsdWUpLCByZXF1aXJlRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjaGVja0Vycm9yKG1ldGhvZCwgZXJyb3IsIHBhcmFtcykge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gcGFyYW1zLnRyYW5zYWN0aW9uIHx8IHBhcmFtcy5zaWduZWRUcmFuc2FjdGlvbjtcbiAgICAvLyBVbmRvIHRoZSBcImNvbnZlbmllbmNlXCIgc29tZSBub2RlcyBhcmUgYXR0ZW1wdGluZyB0byBwcmV2ZW50IGJhY2t3YXJkc1xuICAgIC8vIGluY29tcGF0aWJpbGl0eTsgbWF5YmUgZm9yIHY2IGNvbnNpZGVyIGZvcndhcmRpbmcgcmV2ZXJ0cyBhcyBlcnJvcnNcbiAgICBpZiAobWV0aG9kID09PSBcImNhbGxcIikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzcGVsdW5rKGVycm9yLCB0cnVlKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGhpbmcgZGVzY3JpcHRpdmUuLlxuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm1pc3NpbmcgcmV2ZXJ0IGRhdGEgaW4gY2FsbCBleGNlcHRpb247IFRyYW5zYWN0aW9uIHJldmVydGVkIHdpdGhvdXQgYSByZWFzb24gc3RyaW5nXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgIGRhdGE6IFwiMHhcIiwgdHJhbnNhY3Rpb24sIGVycm9yXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWV0aG9kID09PSBcImVzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgc29tZXRoaW5nLCB3aXRoIGEgcHJlZmVyZW5jZSBvbiBTRVJWRVJfRVJST1IgYm9keVxuICAgICAgICBsZXQgcmVzdWx0ID0gc3BlbHVuayhlcnJvci5ib2R5LCBmYWxzZSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3BlbHVuayhlcnJvciwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvdW5kIFwicmV2ZXJ0ZWRcIiwgdGhpcyBpcyBhIENBTExfRVhDRVBUSU9OXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLCBMb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlULCB7XG4gICAgICAgICAgICAgICAgcmVhc29uOiByZXN1bHQubWVzc2FnZSwgbWV0aG9kLCB0cmFuc2FjdGlvbiwgZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEBUT0RPOiBTaG91bGQgd2Ugc3BlbHVuayBmb3IgbWVzc2FnZSB0b28/XG4gICAgbGV0IG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiAmJiBlcnJvci5lcnJvciAmJiB0eXBlb2YgKGVycm9yLmVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlcnJvci5lcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGVycm9yLmJvZHkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlcnJvci5ib2R5O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGVycm9yLnJlc3BvbnNlVGV4dCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9IGVycm9yLnJlc3BvbnNlVGV4dDtcbiAgICB9XG4gICAgbWVzc2FnZSA9IChtZXNzYWdlIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gXCJpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGdhcyAqIHByaWNlICsgdmFsdWUgKyBjb3N0KGRhdGEpXCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzfGJhc2UgZmVlIGV4Y2VlZHMgZ2FzIGxpbWl0fEluc3VmZmljaWVudEZ1bmRzL2kpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBpbnRyaW5zaWMgdHJhbnNhY3Rpb24gY29zdFwiLCBMb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUywge1xuICAgICAgICAgICAgZXJyb3IsIG1ldGhvZCwgdHJhbnNhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFwibm9uY2UgdG9vIGxvd1wiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL25vbmNlIChpcyApP3RvbyBsb3cvaSkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELCB7XG4gICAgICAgICAgICBlcnJvciwgbWV0aG9kLCB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gXCJyZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZFwiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL3JlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkfHRyYW5zYWN0aW9uIGdhcyBwcmljZS4qdG9vIGxvdy9pKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIExvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQsIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBcInJlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkXCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvb25seSByZXBsYXktcHJvdGVjdGVkL2kpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibGVnYWN5IHByZS1laXAtMTU1IHRyYW5zYWN0aW9ucyBub3Qgc3VwcG9ydGVkXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBlcnJvciwgbWV0aG9kLCB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVycm9yR2FzLmluZGV4T2YobWV0aG9kKSA+PSAwICYmIG1lc3NhZ2UubWF0Y2goL2dhcyByZXF1aXJlZCBleGNlZWRzIGFsbG93YW5jZXxhbHdheXMgZmFpbGluZyB0cmFuc2FjdGlvbnxleGVjdXRpb24gcmV2ZXJ0ZWR8cmV2ZXJ0LykpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZXN0aW1hdGUgZ2FzOyB0cmFuc2FjdGlvbiBtYXkgZmFpbCBvciBtYXkgcmVxdWlyZSBtYW51YWwgZ2FzIGxpbWl0XCIsIExvZ2dlci5lcnJvcnMuVU5QUkVESUNUQUJMRV9HQVNfTElNSVQsIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbn1cbmZ1bmN0aW9uIHRpbWVyKHRpbWVvdXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJlc3VsdChwYXlsb2FkKSB7XG4gICAgaWYgKHBheWxvYWQuZXJyb3IpIHtcbiAgICAgICAgLy8gQFRPRE86IG5vdCBhbnlcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IocGF5bG9hZC5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgZXJyb3IuY29kZSA9IHBheWxvYWQuZXJyb3IuY29kZTtcbiAgICAgICAgZXJyb3IuZGF0YSA9IHBheWxvYWQuZXJyb3IuZGF0YTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBwYXlsb2FkLnJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldExvd2VyQ2FzZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgX2NvbnN0cnVjdG9yR3VhcmQgPSB7fTtcbmV4cG9ydCBjbGFzcyBKc29uUnBjU2lnbmVyIGV4dGVuZHMgU2lnbmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLCBwcm92aWRlciwgYWRkcmVzc09ySW5kZXgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkbyBub3QgY2FsbCB0aGUgSnNvblJwY1NpZ25lciBjb25zdHJ1Y3RvciBkaXJlY3RseTsgdXNlIHByb3ZpZGVyLmdldFNpZ25lclwiKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICAgICAgaWYgKGFkZHJlc3NPckluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZHJlc3NPckluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzT3JJbmRleCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2FkZHJlc3NcIiwgdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhhZGRyZXNzT3JJbmRleCkpO1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaW5kZXhcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChhZGRyZXNzT3JJbmRleCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2luZGV4XCIsIGFkZHJlc3NPckluZGV4KTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2FkZHJlc3NcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzIG9yIGluZGV4XCIsIFwiYWRkcmVzc09ySW5kZXhcIiwgYWRkcmVzc09ySW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGFsdGVyIEpTT04tUlBDIFNpZ25lciBjb25uZWN0aW9uXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiY29ubmVjdFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0VW5jaGVja2VkKCkge1xuICAgICAgICByZXR1cm4gbmV3IFVuY2hlY2tlZEpzb25ScGNTaWduZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRoaXMucHJvdmlkZXIsIHRoaXMuX2FkZHJlc3MgfHwgdGhpcy5faW5kZXgpO1xuICAgIH1cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICBpZiAodGhpcy5fYWRkcmVzcykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9hZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKS50aGVuKChhY2NvdW50cykgPT4ge1xuICAgICAgICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA8PSB0aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5rbm93biBhY2NvdW50ICNcIiArIHRoaXMuX2luZGV4LCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0QWRkcmVzc1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhhY2NvdW50c1t0aGlzLl9pbmRleF0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uID0gc2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCBmcm9tQWRkcmVzcyA9IHRoaXMuZ2V0QWRkcmVzcygpLnRoZW4oKGFkZHJlc3MpID0+IHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhlIEpTT04tUlBDIGZvciBldGhfc2VuZFRyYW5zYWN0aW9uIHVzZXMgOTAwMDAgZ2FzOyBpZiB0aGUgdXNlclxuICAgICAgICAvLyB3aXNoZXMgdG8gdXNlIHRoaXMsIGl0IGlzIGVhc3kgdG8gc3BlY2lmeSBleHBsaWNpdGx5LCBvdGhlcndpc2VcbiAgICAgICAgLy8gd2UgbG9vayBpdCB1cCBmb3IgdGhlbS5cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlID0gc2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgZXN0aW1hdGUuZnJvbSA9IGZyb21BZGRyZXNzO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPSB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKGVzdGltYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24udG8gPSBQcm9taXNlLnJlc29sdmUodHJhbnNhY3Rpb24udG8pLnRoZW4oKHRvKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLnJlc29sdmVOYW1lKHRvKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcm92aWRlZCBFTlMgbmFtZSByZXNvbHZlcyB0byBudWxsXCIsIFwidHgudG9cIiwgdG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgdHg6IHJlc29sdmVQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uKSxcbiAgICAgICAgICAgIHNlbmRlcjogZnJvbUFkZHJlc3NcbiAgICAgICAgfSkudGhlbigoeyB0eCwgc2VuZGVyIH0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHguZnJvbS50b0xvd2VyQ2FzZSgpICE9PSBzZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eC5mcm9tID0gc2VuZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGV4VHggPSB0aGlzLnByb3ZpZGVyLmNvbnN0cnVjdG9yLmhleGxpZnlUcmFuc2FjdGlvbih0eCwgeyBmcm9tOiB0cnVlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zZW5kVHJhbnNhY3Rpb25cIiwgW2hleFR4XSkudGhlbigoaGFzaCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgZXJyb3IubWVzc2FnZS5tYXRjaCgvdXNlciBkZW5pZWQvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1c2VyIHJlamVjdGVkIHRyYW5zYWN0aW9uXCIsIExvZ2dlci5lcnJvcnMuQUNUSU9OX1JFSkVDVEVELCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwic2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja0Vycm9yKFwic2VuZFRyYW5zYWN0aW9uXCIsIGVycm9yLCBoZXhUeCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJzaWduaW5nIHRyYW5zYWN0aW9ucyBpcyB1bnN1cHBvcnRlZFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25UcmFuc2FjdGlvblwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2Fubm90IGJlIG1pbmVkIGFueSBlYXJsaWVyIHRoYW4gYW55IHJlY2VudCBibG9ja1xuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnByb3ZpZGVyLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAvLyBTZW5kIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgY29uc3QgaGFzaCA9IHlpZWxkIHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgSlNPTi1SUEMgb25seSBwcm92aWRlcyBhbmQgb3BhcXVlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgICAgICAgICAgICAvLyBmb3IgYSByZXNwb25zZSwgYW5kIHdlIG5lZWQgdGhlIGFjdHVhbCB0cmFuc2FjdGlvbiwgc28gd2UgcG9sbFxuICAgICAgICAgICAgICAgIC8vIGZvciBpdDsgaXQgc2hvdWxkIHNob3cgdXAgdmVyeSBxdWlja2x5XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHBvbGwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24oaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5fd3JhcFRyYW5zYWN0aW9uKHR4LCBoYXNoLCBibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgfSksIHsgb25jZVBvbGw6IHRoaXMucHJvdmlkZXIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgodHlwZW9mIChtZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyB0b1V0ZjhCeXRlcyhtZXNzYWdlKSA6IG1lc3NhZ2UpO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfc2lnblwiLCBbaGV4bGlmeShkYXRhKSwgYWRkcmVzcy50b0xvd2VyQ2FzZSgpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChlcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiBlcnJvci5tZXNzYWdlLm1hdGNoKC91c2VyIGRlbmllZC9pKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZXIgcmVqZWN0ZWQgc2lnbmluZ1wiLCBMb2dnZXIuZXJyb3JzLkFDVElPTl9SRUpFQ1RFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInNpZ25NZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURhdGE6IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2xlZ2FjeVNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAoKHR5cGVvZiAobWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gdG9VdGY4Qnl0ZXMobWVzc2FnZSkgOiBtZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9KU09OLVJQQyNldGhfc2lnblxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblwiLCBbYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBoZXhsaWZ5KGRhdGEpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChlcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiBlcnJvci5tZXNzYWdlLm1hdGNoKC91c2VyIGRlbmllZC9pKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZXIgcmVqZWN0ZWQgc2lnbmluZ1wiLCBMb2dnZXIuZXJyb3JzLkFDVElPTl9SRUpFQ1RFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIl9sZWdhY3lTaWduTWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEYXRhOiBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBQb3B1bGF0ZSBhbnkgRU5TIG5hbWVzIChpbi1wbGFjZSlcbiAgICAgICAgICAgIGNvbnN0IHBvcHVsYXRlZCA9IHlpZWxkIF9UeXBlZERhdGFFbmNvZGVyLnJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NpZ25UeXBlZERhdGFfdjRcIiwgW1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KF9UeXBlZERhdGFFbmNvZGVyLmdldFBheWxvYWQocG9wdWxhdGVkLmRvbWFpbiwgdHlwZXMsIHBvcHVsYXRlZC52YWx1ZSkpXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChlcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiBlcnJvci5tZXNzYWdlLm1hdGNoKC91c2VyIGRlbmllZC9pKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZXIgcmVqZWN0ZWQgc2lnbmluZ1wiLCBMb2dnZXIuZXJyb3JzLkFDVElPTl9SRUpFQ1RFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIl9zaWduVHlwZWREYXRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURhdGE6IHsgZG9tYWluOiBwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgdmFsdWU6IHBvcHVsYXRlZC52YWx1ZSB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVubG9jayhwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF91bmxvY2tBY2NvdW50XCIsIFthZGRyZXNzLnRvTG93ZXJDYXNlKCksIHBhc3N3b3JkLCBudWxsXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFVuY2hlY2tlZEpzb25ScGNTaWduZXIgZXh0ZW5kcyBKc29uUnBjU2lnbmVyIHtcbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKS50aGVuKChoYXNoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhhc2g6IGhhc2gsXG4gICAgICAgICAgICAgICAgbm9uY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgZ2FzTGltaXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZ2FzUHJpY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IDAsXG4gICAgICAgICAgICAgICAgZnJvbTogbnVsbCxcbiAgICAgICAgICAgICAgICB3YWl0OiAoY29uZmlybWF0aW9ucykgPT4geyByZXR1cm4gdGhpcy5wcm92aWRlci53YWl0Rm9yVHJhbnNhY3Rpb24oaGFzaCwgY29uZmlybWF0aW9ucyk7IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNvbnN0IGFsbG93ZWRUcmFuc2FjdGlvbktleXMgPSB7XG4gICAgY2hhaW5JZDogdHJ1ZSwgZGF0YTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBub25jZTogdHJ1ZSwgdG86IHRydWUsIHZhbHVlOiB0cnVlLFxuICAgIHR5cGU6IHRydWUsIGFjY2Vzc0xpc3Q6IHRydWUsXG4gICAgbWF4RmVlUGVyR2FzOiB0cnVlLCBtYXhQcmlvcml0eUZlZVBlckdhczogdHJ1ZVxufTtcbmV4cG9ydCBjbGFzcyBKc29uUnBjUHJvdmlkZXIgZXh0ZW5kcyBCYXNlUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgbmV0d29yaykge1xuICAgICAgICBsZXQgbmV0d29ya09yUmVhZHkgPSBuZXR3b3JrO1xuICAgICAgICAvLyBUaGUgbmV0d29yayBpcyB1bmtub3duLCBxdWVyeSB0aGUgSlNPTi1SUEMgZm9yIGl0XG4gICAgICAgIGlmIChuZXR3b3JrT3JSZWFkeSA9PSBudWxsKSB7XG4gICAgICAgICAgICBuZXR3b3JrT3JSZWFkeSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXRlY3ROZXR3b3JrKCkudGhlbigobmV0d29yaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKG5ldHdvcmtPclJlYWR5KTtcbiAgICAgICAgLy8gRGVmYXVsdCBVUkxcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgIHVybCA9IGdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImRlZmF1bHRVcmxcIikoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh1cmwpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImNvbm5lY3Rpb25cIiwgT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY29ubmVjdGlvblwiLCBPYmplY3QuZnJlZXplKHNoYWxsb3dDb3B5KHVybCkpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uZXh0SWQgPSA0MjtcbiAgICB9XG4gICAgZ2V0IF9jYWNoZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50TG9vcENhY2hlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50TG9vcENhY2hlID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50TG9vcENhY2hlO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdFVybCgpIHtcbiAgICAgICAgcmV0dXJuIFwiaHR0cDovXFwvbG9jYWxob3N0Ojg1NDVcIjtcbiAgICB9XG4gICAgZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZVtcImRldGVjdE5ldHdvcmtcIl0pIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXSA9IHRoaXMuX3VuY2FjaGVkRGV0ZWN0TmV0d29yaygpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhpcyBjYWNoZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGV2ZW50IGxvb3BcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXSA9IG51bGw7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVbXCJkZXRlY3ROZXR3b3JrXCJdO1xuICAgIH1cbiAgICBfdW5jYWNoZWREZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGltZXIoMCk7XG4gICAgICAgICAgICBsZXQgY2hhaW5JZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSB5aWVsZCB0aGlzLnNlbmQoXCJldGhfY2hhaW5JZFwiLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0geWllbGQgdGhpcy5zZW5kKFwibmV0X3ZlcnNpb25cIiwgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdldE5ldHdvcmsgPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXROZXR3b3JrXCIpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXROZXR3b3JrKEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY291bGQgbm90IGRldGVjdCBuZXR3b3JrXCIsIExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogY2hhaW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImludmFsaWROZXR3b3JrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJFcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY291bGQgbm90IGRldGVjdCBuZXR3b3JrXCIsIExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBcIm5vTmV0d29ya1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFNpZ25lcihhZGRyZXNzT3JJbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IEpzb25ScGNTaWduZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRoaXMsIGFkZHJlc3NPckluZGV4KTtcbiAgICB9XG4gICAgZ2V0VW5jaGVja2VkU2lnbmVyKGFkZHJlc3NPckluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNpZ25lcihhZGRyZXNzT3JJbmRleCkuY29ubmVjdFVuY2hlY2tlZCgpO1xuICAgIH1cbiAgICBsaXN0QWNjb3VudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pLnRoZW4oKGFjY291bnRzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKChhKSA9PiB0aGlzLmZvcm1hdHRlci5hZGRyZXNzKGEpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBpZDogKHRoaXMuX25leHRJZCsrKSxcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgIHJlcXVlc3Q6IGRlZXBDb3B5KHJlcXVlc3QpLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIGNhbiBleHBhbmQgdGhpcyBpbiB0aGUgZnV0dXJlIHRvIGFueSBjYWxsLCBidXQgZm9yIG5vdyB0aGVzZVxuICAgICAgICAvLyBhcmUgdGhlIGJpZ2dlc3Qgd2lucyBhbmQgZG8gbm90IHJlcXVpcmUgYW55IHNlcmlhbGl6aW5nIHBhcmFtZXRlcnMuXG4gICAgICAgIGNvbnN0IGNhY2hlID0gKFtcImV0aF9jaGFpbklkXCIsIFwiZXRoX2Jsb2NrTnVtYmVyXCJdLmluZGV4T2YobWV0aG9kKSA+PSAwKTtcbiAgICAgICAgaWYgKGNhY2hlICYmIHRoaXMuX2NhY2hlW21ldGhvZF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVttZXRob2RdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZldGNoSnNvbih0aGlzLmNvbm5lY3Rpb24sIEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLCBnZXRSZXN1bHQpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENhY2hlIHRoZSBmZXRjaCwgYnV0IGNsZWFyIGl0IG9uIHRoZSBuZXh0IGV2ZW50IGxvb3BcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZVttZXRob2RdID0gcmVzdWx0O1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVbbWV0aG9kXSA9IG51bGw7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwcmVwYXJlUmVxdWVzdChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9ibG9ja051bWJlclwiLCBbXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dhc1ByaWNlXCIsIFtdXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRCYWxhbmNlXCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRDb2RlXCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlQXRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFN0b3JhZ2VBdFwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgaGV4WmVyb1BhZChwYXJhbXMucG9zaXRpb24sIDMyKSwgcGFyYW1zLmJsb2NrVGFnXV07XG4gICAgICAgICAgICBjYXNlIFwic2VuZFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIiwgW3BhcmFtcy5zaWduZWRUcmFuc2FjdGlvbl1dO1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldEJsb2NrQnlOdW1iZXJcIiwgW3BhcmFtcy5ibG9ja1RhZywgISFwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9uc11dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbXMuYmxvY2tIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0QmxvY2tCeUhhc2hcIiwgW3BhcmFtcy5ibG9ja0hhc2gsICEhcGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnNdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsIFtwYXJhbXMudHJhbnNhY3Rpb25IYXNoXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgW3BhcmFtcy50cmFuc2FjdGlvbkhhc2hdXTtcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZXhsaWZ5VHJhbnNhY3Rpb24gPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJoZXhsaWZ5VHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9jYWxsXCIsIFtoZXhsaWZ5VHJhbnNhY3Rpb24ocGFyYW1zLnRyYW5zYWN0aW9uLCB7IGZyb206IHRydWUgfSksIHBhcmFtcy5ibG9ja1RhZ11dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZXhsaWZ5VHJhbnNhY3Rpb24gPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJoZXhsaWZ5VHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9lc3RpbWF0ZUdhc1wiLCBbaGV4bGlmeVRyYW5zYWN0aW9uKHBhcmFtcy50cmFuc2FjdGlvbiwgeyBmcm9tOiB0cnVlIH0pXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOlxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyICYmIHBhcmFtcy5maWx0ZXIuYWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5maWx0ZXIuYWRkcmVzcyA9IGdldExvd2VyQ2FzZShwYXJhbXMuZmlsdGVyLmFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldExvZ3NcIiwgW3BhcmFtcy5maWx0ZXJdXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBlcmZvcm0obWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIExlZ2FjeSBuZXR3b3JrcyBkbyBub3QgbGlrZSB0aGUgdHlwZSBmaWVsZCBiZWluZyBwYXNzZWQgYWxvbmcgKHdoaWNoXG4gICAgICAgICAgICAvLyBpcyBmYWlyKSwgc28gd2UgZGVsZXRlIHR5cGUgaWYgaXQgaXMgMCBhbmQgYSBub24tRUlQLTE1NTkgbmV0d29ya1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJjYWxsXCIgfHwgbWV0aG9kID09PSBcImVzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHBhcmFtcy50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAodHggJiYgdHgudHlwZSAhPSBudWxsICYmIEJpZ051bWJlci5mcm9tKHR4LnR5cGUpLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBFSVAtMTU1OSBwcm9wZXJ0aWVzLCBpdCBtaWdodCBiZSBub24tRUlQLTE1NTlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyA9PSBudWxsICYmIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSB5aWVsZCB0aGlzLmdldEZlZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyA9PSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBrbm93IGFib3V0IEVJUC0xNTU5IChhbmQgaGVuY2UgdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBzaGFsbG93Q29weShwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50cmFuc2FjdGlvbiA9IHNoYWxsb3dDb3B5KHR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW1zLnRyYW5zYWN0aW9uLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5wcmVwYXJlUmVxdWVzdChtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IobWV0aG9kICsgXCIgbm90IGltcGxlbWVudGVkXCIsIExvZ2dlci5lcnJvcnMuTk9UX0lNUExFTUVOVEVELCB7IG9wZXJhdGlvbjogbWV0aG9kIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5zZW5kKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrRXJyb3IobWV0aG9kLCBlcnJvciwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zdGFydEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50YWcgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFBlbmRpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5fc3RhcnRFdmVudChldmVudCk7XG4gICAgfVxuICAgIF9zdGFydFBlbmRpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgcGVuZGluZ0ZpbHRlciA9IHRoaXMuc2VuZChcImV0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXJcIiwgW10pO1xuICAgICAgICB0aGlzLl9wZW5kaW5nRmlsdGVyID0gcGVuZGluZ0ZpbHRlcjtcbiAgICAgICAgcGVuZGluZ0ZpbHRlci50aGVuKGZ1bmN0aW9uIChmaWx0ZXJJZCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gcG9sbCgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNlbmQoXCJldGhfZ2V0RmlsdGVyQ2hhbmdlc1wiLCBbZmlsdGVySWRdKS50aGVuKGZ1bmN0aW9uIChoYXNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX3BlbmRpbmdGaWx0ZXIgIT0gcGVuZGluZ0ZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlcSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBoYXNoZXMuZm9yRWFjaChmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IFRoaXMgc2hvdWxkIGJlIGdhcmJhZ2UgY29sbGVjdGVkIGF0IHNvbWUgcG9pbnQuLi4gSG93PyBXaGVuP1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZW1pdHRlZFtcInQ6XCIgKyBoYXNoLnRvTG93ZXJDYXNlKCldID0gXCJwZW5kaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXEgPSBzZXEudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0VHJhbnNhY3Rpb24oaGFzaCkudGhlbihmdW5jdGlvbiAodHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwicGVuZGluZ1wiLCB0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VxLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVyKDEwMDApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX3BlbmRpbmdGaWx0ZXIgIT0gcGVuZGluZ0ZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZW5kKFwiZXRoX3VuaW5zdGFsbEZpbHRlclwiLCBbZmlsdGVySWRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcG9sbCgpOyB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9sbCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcklkO1xuICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsgfSk7XG4gICAgfVxuICAgIF9zdG9wRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhZyA9PT0gXCJwZW5kaW5nXCIgJiYgdGhpcy5saXN0ZW5lckNvdW50KFwicGVuZGluZ1wiKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0ZpbHRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuX3N0b3BFdmVudChldmVudCk7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgYW4gZXRoZXJzLmpzIHRyYW5zYWN0aW9uIGludG8gYSBKU09OLVJQQyB0cmFuc2FjdGlvblxuICAgIC8vICAtIGdhc0xpbWl0ID0+IGdhc1xuICAgIC8vICAtIEFsbCB2YWx1ZXMgaGV4bGlmaWVkXG4gICAgLy8gIC0gQWxsIG51bWVyaWMgdmFsdWVzIHplcm8tc3RyaXBlZFxuICAgIC8vICAtIEFsbCBhZGRyZXNzZXMgYXJlIGxvd2VyY2FzZWRcbiAgICAvLyBOT1RFOiBUaGlzIGFsbG93cyBhIFRyYW5zYWN0aW9uUmVxdWVzdCwgYnV0IGFsbCB2YWx1ZXMgc2hvdWxkIGJlIHJlc29sdmVkXG4gICAgLy8gICAgICAgYmVmb3JlIHRoaXMgaXMgY2FsbGVkXG4gICAgLy8gQFRPRE86IFRoaXMgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgYW5kIHByZXBhcmVSZXF1ZXN0XG4gICAgLy8gICAgICAgIHdpbGwgYmUgdGhlIHByZWZlcnJlZCBtZXRob2QgZm9yIHRoaXMuXG4gICAgc3RhdGljIGhleGxpZnlUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgYWxsb3dFeHRyYSkge1xuICAgICAgICAvLyBDaGVjayBvbmx5IGFsbG93ZWQgcHJvcGVydGllcyBhcmUgZ2l2ZW5cbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IHNoYWxsb3dDb3B5KGFsbG93ZWRUcmFuc2FjdGlvbktleXMpO1xuICAgICAgICBpZiAoYWxsb3dFeHRyYSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYWxsb3dFeHRyYSkge1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd0V4dHJhW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uLCBhbGxvd2VkKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIC8vIEpTT04tUlBDIG5vdyByZXF1aXJlcyBudW1lcmljIHZhbHVlcyB0byBiZSBcInF1YW50aXR5XCIgdmFsdWVzXG4gICAgICAgIFtcImNoYWluSWRcIiwgXCJnYXNMaW1pdFwiLCBcImdhc1ByaWNlXCIsIFwidHlwZVwiLCBcIm1heEZlZVBlckdhc1wiLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwibm9uY2VcIiwgXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhleFZhbHVlKEJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uW2tleV0pKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiZ2FzTGltaXRcIikge1xuICAgICAgICAgICAgICAgIGtleSA9IFwiZ2FzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgW1wiZnJvbVwiLCBcInRvXCIsIFwiZGF0YVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGhleGxpZnkodHJhbnNhY3Rpb25ba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgcmVzdWx0W1wiYWNjZXNzTGlzdFwiXSA9IGFjY2Vzc0xpc3RpZnkodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLXJwYy1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiU2lnbmVyIiwiQmlnTnVtYmVyIiwiaGV4bGlmeSIsImhleFZhbHVlIiwiaGV4WmVyb1BhZCIsImlzSGV4U3RyaW5nIiwiX1R5cGVkRGF0YUVuY29kZXIiLCJjaGVja1Byb3BlcnRpZXMiLCJkZWVwQ29weSIsImRlZmluZVJlYWRPbmx5IiwiZ2V0U3RhdGljIiwicmVzb2x2ZVByb3BlcnRpZXMiLCJzaGFsbG93Q29weSIsInRvVXRmOEJ5dGVzIiwiYWNjZXNzTGlzdGlmeSIsImZldGNoSnNvbiIsInBvbGwiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiQmFzZVByb3ZpZGVyIiwiZXJyb3JHYXMiLCJzcGVsdW5rIiwicmVxdWlyZURhdGEiLCJtZXNzYWdlIiwibWF0Y2giLCJkYXRhIiwia2V5IiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJjaGVja0Vycm9yIiwibWV0aG9kIiwicGFyYW1zIiwidHJhbnNhY3Rpb24iLCJzaWduZWRUcmFuc2FjdGlvbiIsInRocm93RXJyb3IiLCJlcnJvcnMiLCJDQUxMX0VYQ0VQVElPTiIsImJvZHkiLCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVCIsInJlYXNvbiIsImNvZGUiLCJTRVJWRVJfRVJST1IiLCJyZXNwb25zZVRleHQiLCJ0b0xvd2VyQ2FzZSIsIklOU1VGRklDSUVOVF9GVU5EUyIsIk5PTkNFX0VYUElSRUQiLCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCIsIlVOU1VQUE9SVEVEX09QRVJBVElPTiIsImluZGV4T2YiLCJ0aW1lciIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZ2V0UmVzdWx0IiwicGF5bG9hZCIsIkVycm9yIiwiZ2V0TG93ZXJDYXNlIiwiX2NvbnN0cnVjdG9yR3VhcmQiLCJKc29uUnBjU2lnbmVyIiwiY29uc3RydWN0b3IiLCJjb25zdHJ1Y3Rvckd1YXJkIiwicHJvdmlkZXIiLCJhZGRyZXNzT3JJbmRleCIsImZvcm1hdHRlciIsImFkZHJlc3MiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJjb25uZWN0Iiwib3BlcmF0aW9uIiwiY29ubmVjdFVuY2hlY2tlZCIsIlVuY2hlY2tlZEpzb25ScGNTaWduZXIiLCJfYWRkcmVzcyIsIl9pbmRleCIsImdldEFkZHJlc3MiLCJzZW5kIiwiYWNjb3VudHMiLCJsZW5ndGgiLCJzZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24iLCJmcm9tQWRkcmVzcyIsImdhc0xpbWl0IiwiZXN0aW1hdGUiLCJmcm9tIiwiZXN0aW1hdGVHYXMiLCJ0byIsInJlc29sdmVOYW1lIiwidHgiLCJzZW5kZXIiLCJoZXhUeCIsImhleGxpZnlUcmFuc2FjdGlvbiIsImhhc2giLCJBQ1RJT05fUkVKRUNURUQiLCJhY3Rpb24iLCJzaWduVHJhbnNhY3Rpb24iLCJzZW5kVHJhbnNhY3Rpb24iLCJibG9ja051bWJlciIsIl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyIiwicG9sbGluZ0ludGVydmFsIiwiZ2V0VHJhbnNhY3Rpb24iLCJ1bmRlZmluZWQiLCJfd3JhcFRyYW5zYWN0aW9uIiwib25jZVBvbGwiLCJ0cmFuc2FjdGlvbkhhc2giLCJzaWduTWVzc2FnZSIsIm1lc3NhZ2VEYXRhIiwiX2xlZ2FjeVNpZ25NZXNzYWdlIiwiX3NpZ25UeXBlZERhdGEiLCJkb21haW4iLCJ0eXBlcyIsInBvcHVsYXRlZCIsInJlc29sdmVOYW1lcyIsIm5hbWUiLCJzdHJpbmdpZnkiLCJnZXRQYXlsb2FkIiwidW5sb2NrIiwicGFzc3dvcmQiLCJub25jZSIsImdhc1ByaWNlIiwiY2hhaW5JZCIsImNvbmZpcm1hdGlvbnMiLCJ3YWl0Iiwid2FpdEZvclRyYW5zYWN0aW9uIiwiYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyIsInR5cGUiLCJhY2Nlc3NMaXN0IiwibWF4RmVlUGVyR2FzIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJKc29uUnBjUHJvdmlkZXIiLCJ1cmwiLCJuZXR3b3JrIiwibmV0d29ya09yUmVhZHkiLCJkZXRlY3ROZXR3b3JrIiwiT2JqZWN0IiwiZnJlZXplIiwiX25leHRJZCIsIl9jYWNoZSIsIl9ldmVudExvb3BDYWNoZSIsImRlZmF1bHRVcmwiLCJfdW5jYWNoZWREZXRlY3ROZXR3b3JrIiwiZ2V0TmV0d29yayIsInRvTnVtYmVyIiwiTkVUV09SS19FUlJPUiIsImV2ZW50Iiwic2VydmVyRXJyb3IiLCJnZXRTaWduZXIiLCJnZXRVbmNoZWNrZWRTaWduZXIiLCJsaXN0QWNjb3VudHMiLCJtYXAiLCJhIiwicmVxdWVzdCIsImlkIiwianNvbnJwYyIsImVtaXQiLCJjYWNoZSIsImNvbm5lY3Rpb24iLCJyZXNwb25zZSIsInByZXBhcmVSZXF1ZXN0IiwiYmxvY2tUYWciLCJwb3NpdGlvbiIsImluY2x1ZGVUcmFuc2FjdGlvbnMiLCJibG9ja0hhc2giLCJmaWx0ZXIiLCJwZXJmb3JtIiwiaXNaZXJvIiwiZmVlRGF0YSIsImdldEZlZURhdGEiLCJhcmdzIiwiTk9UX0lNUExFTUVOVEVEIiwiX3N0YXJ0RXZlbnQiLCJ0YWciLCJfc3RhcnRQZW5kaW5nIiwiX3BlbmRpbmdGaWx0ZXIiLCJzZWxmIiwicGVuZGluZ0ZpbHRlciIsImZpbHRlcklkIiwiaGFzaGVzIiwic2VxIiwiZm9yRWFjaCIsIl9lbWl0dGVkIiwiY2F0Y2giLCJfc3RvcEV2ZW50IiwibGlzdGVuZXJDb3VudCIsImFsbG93RXh0cmEiLCJhbGxvd2VkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StaticJsonRpcProvider: () => (/* binding */ StaticJsonRpcProvider),\n/* harmony export */   UrlJsonRpcProvider: () => (/* binding */ UrlJsonRpcProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nclass StaticJsonRpcProvider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider {\n    detectNetwork() {\n        const _super = Object.create(null, {\n            detectNetwork: {\n                get: ()=>super.detectNetwork\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            let network = this.network;\n            if (network == null) {\n                network = yield _super.detectNetwork.call(this);\n                if (!network) {\n                    logger.throwError(\"no network detected\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // If still not set, set it\n                if (this._network == null) {\n                    // A static network does not support \"any\"\n                    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_network\", network);\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return network;\n        });\n    }\n}\nclass UrlJsonRpcProvider extends StaticJsonRpcProvider {\n    constructor(network, apiKey){\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n        // Normalize the Network and API Key\n        network = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getNetwork\")(network);\n        apiKey = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getApiKey\")(apiKey);\n        const connection = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, \"getUrl\")(network, apiKey);\n        super(connection, network);\n        if (typeof apiKey === \"string\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"apiKey\", apiKey);\n        } else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key)=>{\n                (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, key, apiKey[key]);\n            });\n        }\n    }\n    _startPending() {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n    isCommunityResource() {\n        return false;\n    }\n    getSigner(address) {\n        return logger.throwError(\"API provider does not support signing\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"getSigner\"\n        });\n    }\n    listAccounts() {\n        return Promise.resolve([]);\n    }\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey) {\n        return apiKey;\n    }\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network, apiKey) {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n} //# sourceMappingURL=url-json-rpc-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vdXJsLWpzb24tcnBjLXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFhO0FBQ2IsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQ3NFO0FBQ3ZCO0FBQ1Y7QUFDckMsTUFBTVcsU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BO0FBQ3FCO0FBQ3RELHFFQUFxRTtBQUNyRSxrRUFBa0U7QUFDbEUsdUVBQXVFO0FBQ3ZFLGlDQUFpQztBQUNqQyx5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCLHdCQUF3QjtBQUN4QixrQkFBa0I7QUFDbEIsd0VBQXdFO0FBQ3hFLHdFQUF3RTtBQUN4RSxtQkFBbUI7QUFDWixNQUFNRyw4QkFBOEJELCtEQUFlQTtJQUN0REUsZ0JBQWdCO1FBQ1osTUFBTUMsU0FBU0MsT0FBT0MsTUFBTSxDQUFDLE1BQU07WUFDL0JILGVBQWU7Z0JBQUVJLEtBQUssSUFBTSxLQUFLLENBQUNKO1lBQWM7UUFDcEQ7UUFDQSxPQUFPMUIsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJK0IsVUFBVSxJQUFJLENBQUNBLE9BQU87WUFDMUIsSUFBSUEsV0FBVyxNQUFNO2dCQUNqQkEsVUFBVSxNQUFNSixPQUFPRCxhQUFhLENBQUNNLElBQUksQ0FBQyxJQUFJO2dCQUM5QyxJQUFJLENBQUNELFNBQVM7b0JBQ1ZSLE9BQU9VLFVBQVUsQ0FBQyx1QkFBdUJaLHlEQUFNQSxDQUFDYSxNQUFNLENBQUNDLGFBQWEsRUFBRSxDQUFDO2dCQUMzRTtnQkFDQSwyQkFBMkI7Z0JBQzNCLElBQUksSUFBSSxDQUFDQyxRQUFRLElBQUksTUFBTTtvQkFDdkIsMENBQTBDO29CQUMxQ2pCLHlFQUFjQSxDQUFDLElBQUksRUFBRSxZQUFZWTtvQkFDakMsSUFBSSxDQUFDTSxJQUFJLENBQUMsV0FBV04sU0FBUztnQkFDbEM7WUFDSjtZQUNBLE9BQU9BO1FBQ1g7SUFDSjtBQUNKO0FBQ08sTUFBTU8sMkJBQTJCYjtJQUNwQ2MsWUFBWVIsT0FBTyxFQUFFUyxNQUFNLENBQUU7UUFDekJqQixPQUFPa0IsYUFBYSxDQUFDLFlBQVlIO1FBQ2pDLG9DQUFvQztRQUNwQ1AsVUFBVVgsb0VBQVNBLENBQUMsWUFBWSxjQUFjVztRQUM5Q1MsU0FBU3BCLG9FQUFTQSxDQUFDLFlBQVksYUFBYW9CO1FBQzVDLE1BQU1FLGFBQWF0QixvRUFBU0EsQ0FBQyxZQUFZLFVBQVVXLFNBQVNTO1FBQzVELEtBQUssQ0FBQ0UsWUFBWVg7UUFDbEIsSUFBSSxPQUFRUyxXQUFZLFVBQVU7WUFDOUJyQix5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsVUFBVXFCO1FBQ25DLE9BQ0ssSUFBSUEsVUFBVSxNQUFNO1lBQ3JCWixPQUFPZSxJQUFJLENBQUNILFFBQVFJLE9BQU8sQ0FBQyxDQUFDQztnQkFDekIxQix5RUFBY0EsQ0FBQyxJQUFJLEVBQUUwQixLQUFLTCxNQUFNLENBQUNLLElBQUk7WUFDekM7UUFDSjtJQUNKO0lBQ0FDLGdCQUFnQjtRQUNadkIsT0FBT3dCLElBQUksQ0FBQztJQUNoQjtJQUNBQyxzQkFBc0I7UUFDbEIsT0FBTztJQUNYO0lBQ0FDLFVBQVVDLE9BQU8sRUFBRTtRQUNmLE9BQU8zQixPQUFPVSxVQUFVLENBQUMseUNBQXlDWix5REFBTUEsQ0FBQ2EsTUFBTSxDQUFDaUIscUJBQXFCLEVBQUU7WUFBRUMsV0FBVztRQUFZO0lBQ3BJO0lBQ0FDLGVBQWU7UUFDWCxPQUFPN0MsUUFBUUQsT0FBTyxDQUFDLEVBQUU7SUFDN0I7SUFDQSxpRUFBaUU7SUFDakUsT0FBTytDLFVBQVVkLE1BQU0sRUFBRTtRQUNyQixPQUFPQTtJQUNYO0lBQ0EsdUVBQXVFO0lBQ3ZFLDZFQUE2RTtJQUM3RSx3Q0FBd0M7SUFDeEMsT0FBT2UsT0FBT3hCLE9BQU8sRUFBRVMsTUFBTSxFQUFFO1FBQzNCLE9BQU9qQixPQUFPVSxVQUFVLENBQUMscURBQXFEWix5REFBTUEsQ0FBQ2EsTUFBTSxDQUFDc0IsZUFBZSxFQUFFO1lBQ3pHSixXQUFXO1FBQ2Y7SUFDSjtBQUNKLEVBQ0EsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1zdGFydGVyLWtpdC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS91cmwtanNvbi1ycGMtcHJvdmlkZXIuanM/ZWUzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHksIGdldFN0YXRpYyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi9qc29uLXJwYy1wcm92aWRlclwiO1xuLy8gQSBTdGF0aWNKc29uUnBjUHJvdmlkZXIgaXMgdXNlZnVsIHdoZW4geW91ICprbm93KiBmb3IgY2VydGFpbiB0aGF0XG4vLyB0aGUgYmFja2VuZCB3aWxsIG5ldmVyIGNoYW5nZSwgYXMgaXQgbmV2ZXIgY2FsbHMgZXRoX2NoYWluSWQgdG9cbi8vIHZlcmlmeSBpdHMgYmFja2VuZC4gSG93ZXZlciwgaWYgdGhlIGJhY2tlbmQgZG9lcyBjaGFuZ2UsIHRoZSBlZmZlY3RzXG4vLyBhcmUgdW5kZWZpbmVkIGFuZCBtYXkgaW5jbHVkZTpcbi8vIC0gaW5jb25zaXN0ZW50IHJlc3VsdHNcbi8vIC0gbG9ja2luZyB1cCB0aGUgVUlcbi8vIC0gYmxvY2sgc2tldyB3YXJuaW5nc1xuLy8gLSB3cm9uZyByZXN1bHRzXG4vLyBJZiB0aGUgbmV0d29yayBpcyBub3QgZXhwbGljaXQgKGkuZS4gYXV0by1kZXRlY3Rpb24gaXMgZXhwZWN0ZWQpLCB0aGVcbi8vIG5vZGUgTVVTVCBiZSBydW5uaW5nIGFuZCBhdmFpbGFibGUgdG8gcmVzcG9uZCB0byByZXF1ZXN0cyBCRUZPUkUgdGhpc1xuLy8gaXMgaW5zdGFudGlhdGVkLlxuZXhwb3J0IGNsYXNzIFN0YXRpY0pzb25ScGNQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlciB7XG4gICAgZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgICBkZXRlY3ROZXR3b3JrOiB7IGdldDogKCkgPT4gc3VwZXIuZGV0ZWN0TmV0d29yayB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IG5ldHdvcmsgPSB0aGlzLm5ldHdvcms7XG4gICAgICAgICAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV0d29yayA9IHlpZWxkIF9zdXBlci5kZXRlY3ROZXR3b3JrLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm8gbmV0d29yayBkZXRlY3RlZFwiLCBMb2dnZXIuZXJyb3JzLlVOS05PV05fRVJST1IsIHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgc3RpbGwgbm90IHNldCwgc2V0IGl0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHN0YXRpYyBuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgXCJhbnlcIlxuICAgICAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9uZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIG5ldHdvcmssIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVXJsSnNvblJwY1Byb3ZpZGVyIGV4dGVuZHMgU3RhdGljSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrQWJzdHJhY3QobmV3LnRhcmdldCwgVXJsSnNvblJwY1Byb3ZpZGVyKTtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBOZXR3b3JrIGFuZCBBUEkgS2V5XG4gICAgICAgIG5ldHdvcmsgPSBnZXRTdGF0aWMobmV3LnRhcmdldCwgXCJnZXROZXR3b3JrXCIpKG5ldHdvcmspO1xuICAgICAgICBhcGlLZXkgPSBnZXRTdGF0aWMobmV3LnRhcmdldCwgXCJnZXRBcGlLZXlcIikoYXBpS2V5KTtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGdldFN0YXRpYyhuZXcudGFyZ2V0LCBcImdldFVybFwiKShuZXR3b3JrLCBhcGlLZXkpO1xuICAgICAgICBzdXBlcihjb25uZWN0aW9uLCBuZXR3b3JrKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoYXBpS2V5KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhcGlLZXlcIiwgYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcGlLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXBpS2V5KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBrZXksIGFwaUtleVtrZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zdGFydFBlbmRpbmcoKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwiV0FSTklORzogQVBJIHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgcGVuZGluZyBmaWx0ZXJzXCIpO1xuICAgIH1cbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldFNpZ25lcihhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcIkFQSSBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IHNpZ25pbmdcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBcImdldFNpZ25lclwiIH0pO1xuICAgIH1cbiAgICBsaXN0QWNjb3VudHMoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gYSBkZWZhdWx0QXBpS2V5IGlmIG51bGwsIG90aGVyd2lzZSB2YWxpZGF0ZSB0aGUgQVBJIGtleVxuICAgIHN0YXRpYyBnZXRBcGlLZXkoYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiBhcGlLZXk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHVybCBvciBjb25uZWN0aW9uIGZvciB0aGUgZ2l2ZW4gbmV0d29yayBhbmQgQVBJIGtleS4gVGhlXG4gICAgLy8gQVBJIGtleSB3aWxsIGhhdmUgYmVlbiBzYW5pdGl6ZWQgYnkgdGhlIGdldEFwaUtleSBmaXJzdCwgc28gYW55IHZhbGlkYXRpb25cbiAgICAvLyBvciB0cmFuc2Zvcm1hdGlvbnMgY2FuIGJlIGRvbmUgdGhlcmUuXG4gICAgc3RhdGljIGdldFVybChuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwibm90IGltcGxlbWVudGVkOyBzdWItY2xhc3NlcyBtdXN0IG92ZXJyaWRlIGdldFVybFwiLCBMb2dnZXIuZXJyb3JzLk5PVF9JTVBMRU1FTlRFRCwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldFVybFwiXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybC1qc29uLXJwYy1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiZGVmaW5lUmVhZE9ubHkiLCJnZXRTdGF0aWMiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiSnNvblJwY1Byb3ZpZGVyIiwiU3RhdGljSnNvblJwY1Byb3ZpZGVyIiwiZGV0ZWN0TmV0d29yayIsIl9zdXBlciIsIk9iamVjdCIsImNyZWF0ZSIsImdldCIsIm5ldHdvcmsiLCJjYWxsIiwidGhyb3dFcnJvciIsImVycm9ycyIsIlVOS05PV05fRVJST1IiLCJfbmV0d29yayIsImVtaXQiLCJVcmxKc29uUnBjUHJvdmlkZXIiLCJjb25zdHJ1Y3RvciIsImFwaUtleSIsImNoZWNrQWJzdHJhY3QiLCJjb25uZWN0aW9uIiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJfc3RhcnRQZW5kaW5nIiwid2FybiIsImlzQ29tbXVuaXR5UmVzb3VyY2UiLCJnZXRTaWduZXIiLCJhZGRyZXNzIiwiVU5TVVBQT1JURURfT1BFUkFUSU9OIiwib3BlcmF0aW9uIiwibGlzdEFjY291bnRzIiwiZ2V0QXBpS2V5IiwiZ2V0VXJsIiwiTk9UX0lNUExFTUVOVEVEIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/providers/lib.esm/web3-provider.js":
/*!************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/web3-provider.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Web3Provider: () => (/* binding */ Web3Provider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/_version.js\");\n/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\");\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nlet _nextId = 1;\nfunction buildWeb3LegacyFetcher(provider, sendFunc) {\n    const fetcher = \"Web3LegacyFetcher\";\n    return function(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: _nextId++,\n            jsonrpc: \"2.0\"\n        };\n        return new Promise((resolve, reject)=>{\n            this.emit(\"debug\", {\n                action: \"request\",\n                fetcher,\n                request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.deepCopy)(request),\n                provider: this\n            });\n            sendFunc(request, (error, response)=>{\n                if (error) {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher,\n                        error,\n                        request,\n                        provider: this\n                    });\n                    return reject(error);\n                }\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher,\n                    request,\n                    response,\n                    provider: this\n                });\n                if (response.error) {\n                    const error = new Error(response.error.message);\n                    error.code = response.error.code;\n                    error.data = response.error.data;\n                    return reject(error);\n                }\n                resolve(response.result);\n            });\n        });\n    };\n}\nfunction buildEip1193Fetcher(provider) {\n    return function(method, params) {\n        if (params == null) {\n            params = [];\n        }\n        const request = {\n            method,\n            params\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.deepCopy)(request),\n            provider: this\n        });\n        return provider.request(request).then((response)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                response,\n                provider: this\n            });\n            return response;\n        }, (error)=>{\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                error,\n                provider: this\n            });\n            throw error;\n        });\n    };\n}\nclass Web3Provider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider {\n    constructor(provider, network){\n        if (provider == null) {\n            logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n        let path = null;\n        let jsonRpcFetchFunc = null;\n        let subprovider = null;\n        if (typeof provider === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n        } else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n            subprovider = provider;\n            if (provider.request) {\n                if (path === \"\") {\n                    path = \"eip-1193:\";\n                }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            } else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            } else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            } else {\n                logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n            if (!path) {\n                path = \"unknown:\";\n            }\n        }\n        super(path, network);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, \"provider\", subprovider);\n    }\n    send(method, params) {\n        return this.jsonRpcFetchFunc(method, params);\n    }\n} //# sourceMappingURL=web3-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vd2ViMy1wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFhO0FBQ3dEO0FBQ3RCO0FBQ1Y7QUFDckMsTUFBTUksU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BO0FBQ3FCO0FBQ3RELElBQUlHLFVBQVU7QUFDZCxTQUFTQyx1QkFBdUJDLFFBQVEsRUFBRUMsUUFBUTtJQUM5QyxNQUFNQyxVQUFVO0lBQ2hCLE9BQU8sU0FBVUMsTUFBTSxFQUFFQyxNQUFNO1FBQzNCLE1BQU1DLFVBQVU7WUFDWkYsUUFBUUE7WUFDUkMsUUFBUUE7WUFDUkUsSUFBS1I7WUFDTFMsU0FBUztRQUNiO1FBQ0EsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1lBQ3pCLElBQUksQ0FBQ0MsSUFBSSxDQUFDLFNBQVM7Z0JBQ2ZDLFFBQVE7Z0JBQ1JWO2dCQUNBRyxTQUFTYixtRUFBUUEsQ0FBQ2E7Z0JBQ2xCTCxVQUFVLElBQUk7WUFDbEI7WUFDQUMsU0FBU0ksU0FBUyxDQUFDUSxPQUFPQztnQkFDdEIsSUFBSUQsT0FBTztvQkFDUCxJQUFJLENBQUNGLElBQUksQ0FBQyxTQUFTO3dCQUNmQyxRQUFRO3dCQUNSVjt3QkFDQVc7d0JBQ0FSO3dCQUNBTCxVQUFVLElBQUk7b0JBQ2xCO29CQUNBLE9BQU9VLE9BQU9HO2dCQUNsQjtnQkFDQSxJQUFJLENBQUNGLElBQUksQ0FBQyxTQUFTO29CQUNmQyxRQUFRO29CQUNSVjtvQkFDQUc7b0JBQ0FTO29CQUNBZCxVQUFVLElBQUk7Z0JBQ2xCO2dCQUNBLElBQUljLFNBQVNELEtBQUssRUFBRTtvQkFDaEIsTUFBTUEsUUFBUSxJQUFJRSxNQUFNRCxTQUFTRCxLQUFLLENBQUNHLE9BQU87b0JBQzlDSCxNQUFNSSxJQUFJLEdBQUdILFNBQVNELEtBQUssQ0FBQ0ksSUFBSTtvQkFDaENKLE1BQU1LLElBQUksR0FBR0osU0FBU0QsS0FBSyxDQUFDSyxJQUFJO29CQUNoQyxPQUFPUixPQUFPRztnQkFDbEI7Z0JBQ0FKLFFBQVFLLFNBQVNLLE1BQU07WUFDM0I7UUFDSjtJQUNKO0FBQ0o7QUFDQSxTQUFTQyxvQkFBb0JwQixRQUFRO0lBQ2pDLE9BQU8sU0FBVUcsTUFBTSxFQUFFQyxNQUFNO1FBQzNCLElBQUlBLFVBQVUsTUFBTTtZQUNoQkEsU0FBUyxFQUFFO1FBQ2Y7UUFDQSxNQUFNQyxVQUFVO1lBQUVGO1lBQVFDO1FBQU87UUFDakMsSUFBSSxDQUFDTyxJQUFJLENBQUMsU0FBUztZQUNmQyxRQUFRO1lBQ1JWLFNBQVM7WUFDVEcsU0FBU2IsbUVBQVFBLENBQUNhO1lBQ2xCTCxVQUFVLElBQUk7UUFDbEI7UUFDQSxPQUFPQSxTQUFTSyxPQUFPLENBQUNBLFNBQVNnQixJQUFJLENBQUMsQ0FBQ1A7WUFDbkMsSUFBSSxDQUFDSCxJQUFJLENBQUMsU0FBUztnQkFDZkMsUUFBUTtnQkFDUlYsU0FBUztnQkFDVEc7Z0JBQ0FTO2dCQUNBZCxVQUFVLElBQUk7WUFDbEI7WUFDQSxPQUFPYztRQUNYLEdBQUcsQ0FBQ0Q7WUFDQSxJQUFJLENBQUNGLElBQUksQ0FBQyxTQUFTO2dCQUNmQyxRQUFRO2dCQUNSVixTQUFTO2dCQUNURztnQkFDQVE7Z0JBQ0FiLFVBQVUsSUFBSTtZQUNsQjtZQUNBLE1BQU1hO1FBQ1Y7SUFDSjtBQUNKO0FBQ08sTUFBTVMscUJBQXFCekIsK0RBQWVBO0lBQzdDMEIsWUFBWXZCLFFBQVEsRUFBRXdCLE9BQU8sQ0FBRTtRQUMzQixJQUFJeEIsWUFBWSxNQUFNO1lBQ2xCSixPQUFPNkIsa0JBQWtCLENBQUMsb0JBQW9CLFlBQVl6QjtRQUM5RDtRQUNBLElBQUkwQixPQUFPO1FBQ1gsSUFBSUMsbUJBQW1CO1FBQ3ZCLElBQUlDLGNBQWM7UUFDbEIsSUFBSSxPQUFRNUIsYUFBYyxZQUFZO1lBQ2xDMEIsT0FBTztZQUNQQyxtQkFBbUIzQjtRQUN2QixPQUNLO1lBQ0QwQixPQUFPMUIsU0FBUzZCLElBQUksSUFBSTdCLFNBQVMwQixJQUFJLElBQUk7WUFDekMsSUFBSSxDQUFDQSxRQUFRMUIsU0FBUzhCLFVBQVUsRUFBRTtnQkFDOUJKLE9BQU87WUFDWDtZQUNBRSxjQUFjNUI7WUFDZCxJQUFJQSxTQUFTSyxPQUFPLEVBQUU7Z0JBQ2xCLElBQUlxQixTQUFTLElBQUk7b0JBQ2JBLE9BQU87Z0JBQ1g7Z0JBQ0FDLG1CQUFtQlAsb0JBQW9CcEI7WUFDM0MsT0FDSyxJQUFJQSxTQUFTK0IsU0FBUyxFQUFFO2dCQUN6QkosbUJBQW1CNUIsdUJBQXVCQyxVQUFVQSxTQUFTK0IsU0FBUyxDQUFDQyxJQUFJLENBQUNoQztZQUNoRixPQUNLLElBQUlBLFNBQVNpQyxJQUFJLEVBQUU7Z0JBQ3BCTixtQkFBbUI1Qix1QkFBdUJDLFVBQVVBLFNBQVNpQyxJQUFJLENBQUNELElBQUksQ0FBQ2hDO1lBQzNFLE9BQ0s7Z0JBQ0RKLE9BQU82QixrQkFBa0IsQ0FBQyx3QkFBd0IsWUFBWXpCO1lBQ2xFO1lBQ0EsSUFBSSxDQUFDMEIsTUFBTTtnQkFDUEEsT0FBTztZQUNYO1FBQ0o7UUFDQSxLQUFLLENBQUNBLE1BQU1GO1FBQ1ovQix5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsb0JBQW9Ca0M7UUFDekNsQyx5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsWUFBWW1DO0lBQ3JDO0lBQ0FLLEtBQUs5QixNQUFNLEVBQUVDLE1BQU0sRUFBRTtRQUNqQixPQUFPLElBQUksQ0FBQ3VCLGdCQUFnQixDQUFDeEIsUUFBUUM7SUFDekM7QUFDSixFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vd2ViMy1wcm92aWRlci5qcz82ODcwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZGVlcENvcHksIGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL2pzb24tcnBjLXByb3ZpZGVyXCI7XG5sZXQgX25leHRJZCA9IDE7XG5mdW5jdGlvbiBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBzZW5kRnVuYykge1xuICAgIGNvbnN0IGZldGNoZXIgPSBcIldlYjNMZWdhY3lGZXRjaGVyXCI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgIGlkOiAoX25leHRJZCsrKSxcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIGZldGNoZXIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogZGVlcENvcHkocmVxdWVzdCksXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VuZEZ1bmMocmVxdWVzdCwgKGVycm9yLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGZldGNoZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihyZXNwb25zZS5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IHJlc3BvbnNlLmVycm9yLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmRhdGEgPSByZXNwb25zZS5lcnJvci5kYXRhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZEVpcDExOTNGZXRjaGVyKHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IG1ldGhvZCwgcGFyYW1zIH07XG4gICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICBmZXRjaGVyOiBcIkVpcDExOTNGZXRjaGVyXCIsXG4gICAgICAgICAgICByZXF1ZXN0OiBkZWVwQ29weShyZXF1ZXN0KSxcbiAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvdmlkZXIucmVxdWVzdChyZXF1ZXN0KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIGZldGNoZXI6IFwiRWlwMTE5M0ZldGNoZXJcIixcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgZmV0Y2hlcjogXCJFaXAxMTkzRmV0Y2hlclwiLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnQgY2xhc3MgV2ViM1Byb3ZpZGVyIGV4dGVuZHMgSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgbmV0d29yaykge1xuICAgICAgICBpZiAocHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgcHJvdmlkZXJcIiwgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhdGggPSBudWxsO1xuICAgICAgICBsZXQganNvblJwY0ZldGNoRnVuYyA9IG51bGw7XG4gICAgICAgIGxldCBzdWJwcm92aWRlciA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgKHByb3ZpZGVyKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBwYXRoID0gXCJ1bmtub3duOlwiO1xuICAgICAgICAgICAganNvblJwY0ZldGNoRnVuYyA9IHByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0aCA9IHByb3ZpZGVyLmhvc3QgfHwgcHJvdmlkZXIucGF0aCB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKCFwYXRoICYmIHByb3ZpZGVyLmlzTWV0YU1hc2spIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gXCJtZXRhbWFza1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VicHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgICAgIGlmIChwcm92aWRlci5yZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFwiZWlwLTExOTM6XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBidWlsZEVpcDExOTNGZXRjaGVyKHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnNlbmRBc3luYykge1xuICAgICAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBwcm92aWRlci5zZW5kQXN5bmMuYmluZChwcm92aWRlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIuc2VuZCkge1xuICAgICAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBwcm92aWRlci5zZW5kLmJpbmQocHJvdmlkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBwcm92aWRlclwiLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBcInVua25vd246XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocGF0aCwgbmV0d29yayk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwianNvblJwY0ZldGNoRnVuY1wiLCBqc29uUnBjRmV0Y2hGdW5jKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBzdWJwcm92aWRlcik7XG4gICAgfVxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNvblJwY0ZldGNoRnVuYyhtZXRob2QsIHBhcmFtcyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViMy1wcm92aWRlci5qcy5tYXAiXSwibmFtZXMiOlsiZGVlcENvcHkiLCJkZWZpbmVSZWFkT25seSIsIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJKc29uUnBjUHJvdmlkZXIiLCJfbmV4dElkIiwiYnVpbGRXZWIzTGVnYWN5RmV0Y2hlciIsInByb3ZpZGVyIiwic2VuZEZ1bmMiLCJmZXRjaGVyIiwibWV0aG9kIiwicGFyYW1zIiwicmVxdWVzdCIsImlkIiwianNvbnJwYyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZW1pdCIsImFjdGlvbiIsImVycm9yIiwicmVzcG9uc2UiLCJFcnJvciIsIm1lc3NhZ2UiLCJjb2RlIiwiZGF0YSIsInJlc3VsdCIsImJ1aWxkRWlwMTE5M0ZldGNoZXIiLCJ0aGVuIiwiV2ViM1Byb3ZpZGVyIiwiY29uc3RydWN0b3IiLCJuZXR3b3JrIiwidGhyb3dBcmd1bWVudEVycm9yIiwicGF0aCIsImpzb25ScGNGZXRjaEZ1bmMiLCJzdWJwcm92aWRlciIsImhvc3QiLCJpc01ldGFNYXNrIiwic2VuZEFzeW5jIiwiYmluZCIsInNlbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/providers/lib.esm/web3-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocketProvider: () => (/* binding */ WebSocketProvider)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-rpc-provider */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\");\n/* harmony import */ var _ws__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ws */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/ws.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */ let NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nclass WebSocketProvider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider {\n    constructor(url, network){\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        if (typeof url === \"string\") {\n            super(url, network);\n        } else {\n            super(\"_websocket\", network);\n        }\n        this._pollingInterval = -1;\n        this._wsReady = false;\n        if (typeof url === \"string\") {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_websocket\", new _ws__WEBPACK_IMPORTED_MODULE_4__.WebSocket(this.connection.url));\n        } else {\n            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_websocket\", url);\n        }\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_requests\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_subs\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_subIds\", {});\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_detectNetwork\", super.detectNetwork());\n        // Stall sending requests until the socket is open...\n        this.websocket.onopen = ()=>{\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id)=>{\n                this.websocket.send(this._requests[id].payload);\n            });\n        };\n        this.websocket.onmessage = (messageEvent)=>{\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n                } else {\n                    let error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(error, \"code\", result.error.code || null);\n                        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(error, \"response\", data);\n                    } else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n                }\n            } else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            } else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(()=>{\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n    }\n    // Cannot narrow the type of _websocket, as that is not backwards compatible\n    // so we add a getter and let the WebSocket be a public API.\n    get websocket() {\n        return this._websocket;\n    }\n    detectNetwork() {\n        return this._detectNetwork;\n    }\n    get pollingInterval() {\n        return 0;\n    }\n    resetEventsBlock(blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n    set pollingInterval(value) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return null;\n        });\n    }\n    set polling(value) {\n        if (!value) {\n            return;\n        }\n        logger.throwError(\"cannot set polling on WebSocketProvider\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n    send(method, params) {\n        const rid = NextId++;\n        return new Promise((resolve, reject)=>{\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n            this._requests[String(rid)] = {\n                callback,\n                payload\n            };\n            if (this._wsReady) {\n                this.websocket.send(payload);\n            }\n        });\n    }\n    static defaultUrl() {\n        return \"ws://localhost:8546\";\n    }\n    _subscribe(tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let subIdPromise = this._subIds[tag];\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param)=>{\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            this._subs[subId] = {\n                tag,\n                processFunc\n            };\n        });\n    }\n    _startEvent(event) {\n        switch(event.type){\n            case \"block\":\n                this._subscribe(\"block\", [\n                    \"newHeads\"\n                ], (result)=>{\n                    const blockNumber = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_5__.BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\n                    \"newPendingTransactions\"\n                ], (result)=>{\n                    this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\n                    \"logs\",\n                    this._getFilter(event.filter)\n                ], (result)=>{\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\":\n                {\n                    const emitReceipt = (event)=>{\n                        const hash = event.hash;\n                        this.getTransactionReceipt(hash).then((receipt)=>{\n                            if (!receipt) {\n                                return;\n                            }\n                            this.emit(hash, receipt);\n                        });\n                    };\n                    // In case it is already mined\n                    emitReceipt(event);\n                    // To keep things simple, we start up a single newHeads subscription\n                    // to keep an eye out for transactions we are watching for.\n                    // Starting a subscription for an event (i.e. \"tx\") that is already\n                    // running is (basically) a nop.\n                    this._subscribe(\"tx\", [\n                        \"newHeads\"\n                    ], (result)=>{\n                        this._events.filter((e)=>e.type === \"tx\").forEach(emitReceipt);\n                    });\n                    break;\n                }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n    _stopEvent(event) {\n        let tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e)=>e.type === \"tx\").length) {\n                return;\n            }\n            tag = \"tx\";\n        } else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then((subId)=>{\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [\n                subId\n            ]);\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // Wait until we have connected before trying to disconnect\n            if (this.websocket.readyState === _ws__WEBPACK_IMPORTED_MODULE_4__.WebSocket.CONNECTING) {\n                yield new Promise((resolve)=>{\n                    this.websocket.onopen = function() {\n                        resolve(true);\n                    };\n                    this.websocket.onerror = function() {\n                        resolve(false);\n                    };\n                });\n            }\n            // Hangup\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n            this.websocket.close(1000);\n        });\n    }\n} //# sourceMappingURL=websocket-provider.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vd2Vic29ja2V0LXByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBYTtBQUNiLElBQUlBLFlBQVksU0FBSyxJQUFJLFNBQUksQ0FBQ0EsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUNxRDtBQUNNO0FBQ0w7QUFDckI7QUFDYztBQUNWO0FBQ3JDLE1BQU1hLFNBQVMsSUFBSUYseURBQU1BLENBQUNDLDZDQUFPQTtBQUNqQzs7Ozs7Ozs7Ozs7OztDQWFD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Q0gsSUFBSTtRQUMvQixJQUFJLENBQUNLLE9BQU87WUFDUjtRQUNKO1FBQ0EsT0FBTyxJQUFJLENBQUNGLE9BQU8sQ0FBQ0gsSUFBSTtRQUN4QkssTUFBTTVFLElBQUksQ0FBQyxDQUFDNEU7WUFDUixJQUFJLENBQUMsSUFBSSxDQUFDMUIsS0FBSyxDQUFDMEIsTUFBTSxFQUFFO2dCQUNwQjtZQUNKO1lBQ0EsT0FBTyxJQUFJLENBQUMxQixLQUFLLENBQUMwQixNQUFNO1lBQ3hCLElBQUksQ0FBQy9DLElBQUksQ0FBQyxtQkFBbUI7Z0JBQUMrQzthQUFNO1FBQ3hDO0lBQ0o7SUFDQXVCLFVBQVU7UUFDTixPQUFPcEgsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQywyREFBMkQ7WUFDM0QsSUFBSSxJQUFJLENBQUN1QyxTQUFTLENBQUM4RSxVQUFVLEtBQUsvRiwwQ0FBU0EsQ0FBQ2dHLFVBQVUsRUFBRTtnQkFDcEQsTUFBTyxJQUFJOUcsUUFBUSxDQUFDRDtvQkFDaEIsSUFBSSxDQUFDZ0MsU0FBUyxDQUFDQyxNQUFNLEdBQUc7d0JBQ3BCakMsUUFBUTtvQkFDWjtvQkFDQSxJQUFJLENBQUNnQyxTQUFTLENBQUNnRixPQUFPLEdBQUc7d0JBQ3JCaEgsUUFBUTtvQkFDWjtnQkFDSjtZQUNKO1lBQ0EsU0FBUztZQUNULGdGQUFnRjtZQUNoRixJQUFJLENBQUNnQyxTQUFTLENBQUNpRixLQUFLLENBQUM7UUFDekI7SUFDSjtBQUNKLEVBQ0EsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1zdGFydGVyLWtpdC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS93ZWJzb2NrZXQtcHJvdmlkZXIuanM/ZjFiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSBcIi4vanNvbi1ycGMtcHJvdmlkZXJcIjtcbmltcG9ydCB7IFdlYlNvY2tldCB9IGZyb20gXCIuL3dzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4vKipcbiAqICBOb3RlczpcbiAqXG4gKiAgVGhpcyBwcm92aWRlciBkaWZmZXJzIGEgYml0IGZyb20gdGhlIHBvbGxpbmcgcHJvdmlkZXJzLiBPbmUgbWFpblxuICogIGRpZmZlcmVuY2UgaXMgaG93IGl0IGhhbmRsZXMgY29uc2lzdGVuY3kuIFRoZSBwb2xsaW5nIHByb3ZpZGVyc1xuICogIHdpbGwgc3RhbGwgcmVzcG9uc2VzIHRvIGVuc3VyZSBhIGNvbnNpc3RlbnQgc3RhdGUsIHdoaWxlIHRoaXNcbiAqICBXZWJTb2NrZXQgcHJvdmlkZXIgYXNzdW1lcyB0aGUgY29ubmVjdGVkIGJhY2tlbmQgd2lsbCBtYW5hZ2UgdGhpcy5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGlmIGEgcG9sbGluZyBwcm92aWRlciBlbWl0cyBhbiBldmVudCB3aGljaCBpbmRpY2F0ZXNcbiAqICB0aGUgZXZlbnQgb2NjdXJyZWQgaW4gYmxvY2toYXNoIFhYWCwgYSBjYWxsIHRvIGZldGNoIHRoYXQgYmxvY2sgYnlcbiAqICBpdHMgaGFzaCBYWFgsIGlmIG5vdCBwcmVzZW50IHdpbGwgcmV0cnkgdW50aWwgaXQgaXMgcHJlc2VudC4gVGhpc1xuICogIGNhbiBvY2N1ciB3aGVuIHF1ZXJ5aW5nIGEgcG9vbCBvZiBub2RlcyB0aGF0IGFyZSBtaWxkbHkgb3V0IG9mIHN5bmNcbiAqICB3aXRoIGVhY2ggb3RoZXIuXG4gKi9cbmxldCBOZXh0SWQgPSAxO1xuLy8gRm9yIG1vcmUgaW5mbyBhYm91dCB0aGUgUmVhbC10aW1lIEV2ZW50IEFQSSBzZWU6XG4vLyAgIGh0dHBzOi8vZ2V0aC5ldGhlcmV1bS5vcmcvZG9jcy9ycGMvcHVic3ViXG5leHBvcnQgY2xhc3MgV2ViU29ja2V0UHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgbmV0d29yaykge1xuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgYWRkZWQgaW4gdGhlIGZ1dHVyZTsgcGxlYXNlIG9wZW4gYW4gaXNzdWUgdG8gZXhwZWRpdGVcbiAgICAgICAgaWYgKG5ldHdvcmsgPT09IFwiYW55XCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiV2ViU29ja2V0UHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCAnYW55JyBuZXR3b3JrIHlldFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXR3b3JrOmFueVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh1cmwpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBzdXBlcih1cmwsIG5ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIoXCJfd2Vic29ja2V0XCIsIG5ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCA9IC0xO1xuICAgICAgICB0aGlzLl93c1JlYWR5ID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX3dlYnNvY2tldFwiLCBuZXcgV2ViU29ja2V0KHRoaXMuY29ubmVjdGlvbi51cmwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX3dlYnNvY2tldFwiLCB1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX3JlcXVlc3RzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfc3Vic1wiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX3N1Yklkc1wiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2RldGVjdE5ldHdvcmtcIiwgc3VwZXIuZGV0ZWN0TmV0d29yaygpKTtcbiAgICAgICAgLy8gU3RhbGwgc2VuZGluZyByZXF1ZXN0cyB1bnRpbCB0aGUgc29ja2V0IGlzIG9wZW4uLi5cbiAgICAgICAgdGhpcy53ZWJzb2NrZXQub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd3NSZWFkeSA9IHRydWU7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9yZXF1ZXN0cykuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLndlYnNvY2tldC5zZW5kKHRoaXMuX3JlcXVlc3RzW2lkXS5wYXlsb2FkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLndlYnNvY2tldC5vbm1lc3NhZ2UgPSAobWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gbWVzc2FnZUV2ZW50LmRhdGE7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBTdHJpbmcocmVzdWx0LmlkKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fcmVxdWVzdHNbaWRdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9yZXF1ZXN0c1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKG51bGwsIHJlc3VsdC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IEpTT04ucGFyc2UocmVxdWVzdC5wYXlsb2FkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXN1bHQucmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IubWVzc2FnZSB8fCBcInVua25vd24gZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seShlcnJvciwgXCJjb2RlXCIsIHJlc3VsdC5lcnJvci5jb2RlIHx8IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkoZXJyb3IsIFwicmVzcG9uc2VcIiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcInVua25vd24gZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jYWxsYmFjayhlcnJvciwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBKU09OLnBhcnNlKHJlcXVlc3QucGF5bG9hZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQubWV0aG9kID09PSBcImV0aF9zdWJzY3JpcHRpb25cIikge1xuICAgICAgICAgICAgICAgIC8vIFN1YnNjcmlwdGlvbi4uLlxuICAgICAgICAgICAgICAgIGNvbnN0IHN1YiA9IHRoaXMuX3N1YnNbcmVzdWx0LnBhcmFtcy5zdWJzY3JpcHRpb25dO1xuICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzLmVtaXQuYXBwbHkodGhpcywgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBzdWIucHJvY2Vzc0Z1bmMocmVzdWx0LnBhcmFtcy5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInRoaXMgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoaXMgUHJvdmlkZXIgZG9lcyBub3QgYWN0dWFsbHkgcG9sbCwgYnV0IHdlIHdhbnQgdG8gdHJpZ2dlclxuICAgICAgICAvLyBwb2xsIGV2ZW50cyBmb3IgdGhpbmdzIHRoYXQgZGVwZW5kIG9uIHRoZW0gKGxpa2Ugc3RhbGxpbmcgZm9yXG4gICAgICAgIC8vIGJsb2NrIGFuZCB0cmFuc2FjdGlvbiBsb29rdXBzKVxuICAgICAgICBjb25zdCBmYXV4UG9sbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInBvbGxcIik7XG4gICAgICAgIH0sIDEwMDApO1xuICAgICAgICBpZiAoZmF1eFBvbGwudW5yZWYpIHtcbiAgICAgICAgICAgIGZhdXhQb2xsLnVucmVmKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2Fubm90IG5hcnJvdyB0aGUgdHlwZSBvZiBfd2Vic29ja2V0LCBhcyB0aGF0IGlzIG5vdCBiYWNrd2FyZHMgY29tcGF0aWJsZVxuICAgIC8vIHNvIHdlIGFkZCBhIGdldHRlciBhbmQgbGV0IHRoZSBXZWJTb2NrZXQgYmUgYSBwdWJsaWMgQVBJLlxuICAgIGdldCB3ZWJzb2NrZXQoKSB7IHJldHVybiB0aGlzLl93ZWJzb2NrZXQ7IH1cbiAgICBkZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGV0ZWN0TmV0d29yaztcbiAgICB9XG4gICAgZ2V0IHBvbGxpbmdJbnRlcnZhbCgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJlc2V0RXZlbnRzQmxvY2soYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgcmVzZXQgZXZlbnRzIGJsb2NrIG9uIFdlYlNvY2tldFByb3ZpZGVyXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwicmVzZXRFdmVudEJsb2NrXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldCBwb2xsaW5nSW50ZXJ2YWwodmFsdWUpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgc2V0IHBvbGxpbmcgaW50ZXJ2YWwgb24gV2ViU29ja2V0UHJvdmlkZXJcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRQb2xsaW5nSW50ZXJ2YWxcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcG9sbCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0IHBvbGxpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHNldCBwb2xsaW5nIG9uIFdlYlNvY2tldFByb3ZpZGVyXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwic2V0UG9sbGluZ1wiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJpZCA9IE5leHRJZCsrO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2soZXJyb3IsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgaWQ6IHJpZCxcbiAgICAgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IEpTT04ucGFyc2UocGF5bG9hZCksXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHNbU3RyaW5nKHJpZCldID0geyBjYWxsYmFjaywgcGF5bG9hZCB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuX3dzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndlYnNvY2tldC5zZW5kKHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGRlZmF1bHRVcmwoKSB7XG4gICAgICAgIHJldHVybiBcIndzOi9cXC9sb2NhbGhvc3Q6ODU0NlwiO1xuICAgIH1cbiAgICBfc3Vic2NyaWJlKHRhZywgcGFyYW0sIHByb2Nlc3NGdW5jKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgc3ViSWRQcm9taXNlID0gdGhpcy5fc3ViSWRzW3RhZ107XG4gICAgICAgICAgICBpZiAoc3ViSWRQcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdWJJZFByb21pc2UgPSBQcm9taXNlLmFsbChwYXJhbSkudGhlbigocGFyYW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChcImV0aF9zdWJzY3JpYmVcIiwgcGFyYW0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1Yklkc1t0YWddID0gc3ViSWRQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3ViSWQgPSB5aWVsZCBzdWJJZFByb21pc2U7XG4gICAgICAgICAgICB0aGlzLl9zdWJzW3N1YklkXSA9IHsgdGFnLCBwcm9jZXNzRnVuYyB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3N0YXJ0RXZlbnQoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2tcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUoXCJibG9ja1wiLCBbXCJuZXdIZWFkc1wiXSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IEJpZ051bWJlci5mcm9tKHJlc3VsdC5udW1iZXIpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiYmxvY2tcIiwgYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUoXCJwZW5kaW5nXCIsIFtcIm5ld1BlbmRpbmdUcmFuc2FjdGlvbnNcIl0sIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwicGVuZGluZ1wiLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZpbHRlclwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZShldmVudC50YWcsIFtcImxvZ3NcIiwgdGhpcy5fZ2V0RmlsdGVyKGV2ZW50LmZpbHRlcildLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVtb3ZlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudC5maWx0ZXIsIHRoaXMuZm9ybWF0dGVyLmZpbHRlckxvZyhyZXN1bHQpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0eFwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW1pdFJlY2VpcHQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IGV2ZW50Lmhhc2g7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpLnRoZW4oKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVjZWlwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChoYXNoLCByZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIGl0IGlzIGFscmVhZHkgbWluZWRcbiAgICAgICAgICAgICAgICBlbWl0UmVjZWlwdChldmVudCk7XG4gICAgICAgICAgICAgICAgLy8gVG8ga2VlcCB0aGluZ3Mgc2ltcGxlLCB3ZSBzdGFydCB1cCBhIHNpbmdsZSBuZXdIZWFkcyBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAvLyB0byBrZWVwIGFuIGV5ZSBvdXQgZm9yIHRyYW5zYWN0aW9ucyB3ZSBhcmUgd2F0Y2hpbmcgZm9yLlxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0aW5nIGEgc3Vic2NyaXB0aW9uIGZvciBhbiBldmVudCAoaS5lLiBcInR4XCIpIHRoYXQgaXMgYWxyZWFkeVxuICAgICAgICAgICAgICAgIC8vIHJ1bm5pbmcgaXMgKGJhc2ljYWxseSkgYSBub3AuXG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKFwidHhcIiwgW1wibmV3SGVhZHNcIl0sIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzLmZpbHRlcigoZSkgPT4gKGUudHlwZSA9PT0gXCJ0eFwiKSkuZm9yRWFjaChlbWl0UmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3RoaW5nIGlzIG5lZWRlZFxuICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XG4gICAgICAgICAgICBjYXNlIFwicG9sbFwiOlxuICAgICAgICAgICAgY2FzZSBcIndpbGxQb2xsXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGlkUG9sbFwiOlxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidW5oYW5kbGVkOlwiLCBldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3N0b3BFdmVudChldmVudCkge1xuICAgICAgICBsZXQgdGFnID0gZXZlbnQudGFnO1xuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJ0eFwiKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgcmVtYWluaW5nIHRyYW5zYWN0aW9uIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50cy5maWx0ZXIoKGUpID0+IChlLnR5cGUgPT09IFwidHhcIikpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhZyA9IFwidHhcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoZXZlbnQuZXZlbnQpKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgcmVtYWluaW5nIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YklkID0gdGhpcy5fc3ViSWRzW3RhZ107XG4gICAgICAgIGlmICghc3ViSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fc3ViSWRzW3RhZ107XG4gICAgICAgIHN1YklkLnRoZW4oKHN1YklkKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N1YnNbc3ViSWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNbc3ViSWRdO1xuICAgICAgICAgICAgdGhpcy5zZW5kKFwiZXRoX3Vuc3Vic2NyaWJlXCIsIFtzdWJJZF0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgd2UgaGF2ZSBjb25uZWN0ZWQgYmVmb3JlIHRyeWluZyB0byBkaXNjb25uZWN0XG4gICAgICAgICAgICBpZiAodGhpcy53ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCAobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWJzb2NrZXQub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWJzb2NrZXQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhbmd1cFxuICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2xvc2VFdmVudCNTdGF0dXNfY29kZXNcbiAgICAgICAgICAgIHRoaXMud2Vic29ja2V0LmNsb3NlKDEwMDApO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJzb2NrZXQtcHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIkJpZ051bWJlciIsImRlZmluZVJlYWRPbmx5IiwiSnNvblJwY1Byb3ZpZGVyIiwiV2ViU29ja2V0IiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsIk5leHRJZCIsIldlYlNvY2tldFByb3ZpZGVyIiwiY29uc3RydWN0b3IiLCJ1cmwiLCJuZXR3b3JrIiwidGhyb3dFcnJvciIsImVycm9ycyIsIlVOU1VQUE9SVEVEX09QRVJBVElPTiIsIm9wZXJhdGlvbiIsIl9wb2xsaW5nSW50ZXJ2YWwiLCJfd3NSZWFkeSIsImNvbm5lY3Rpb24iLCJkZXRlY3ROZXR3b3JrIiwid2Vic29ja2V0Iiwib25vcGVuIiwiT2JqZWN0Iiwia2V5cyIsIl9yZXF1ZXN0cyIsImZvckVhY2giLCJpZCIsInNlbmQiLCJwYXlsb2FkIiwib25tZXNzYWdlIiwibWVzc2FnZUV2ZW50IiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsIlN0cmluZyIsInJlcXVlc3QiLCJ1bmRlZmluZWQiLCJjYWxsYmFjayIsImVtaXQiLCJhY3Rpb24iLCJyZXNwb25zZSIsInByb3ZpZGVyIiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJjb2RlIiwibWV0aG9kIiwic3ViIiwiX3N1YnMiLCJwYXJhbXMiLCJzdWJzY3JpcHRpb24iLCJwcm9jZXNzRnVuYyIsImNvbnNvbGUiLCJ3YXJuIiwiZmF1eFBvbGwiLCJzZXRJbnRlcnZhbCIsInVucmVmIiwiX3dlYnNvY2tldCIsIl9kZXRlY3ROZXR3b3JrIiwicG9sbGluZ0ludGVydmFsIiwicmVzZXRFdmVudHNCbG9jayIsImJsb2NrTnVtYmVyIiwicG9sbCIsInBvbGxpbmciLCJyaWQiLCJzdHJpbmdpZnkiLCJqc29ucnBjIiwiZGVmYXVsdFVybCIsIl9zdWJzY3JpYmUiLCJ0YWciLCJwYXJhbSIsInN1YklkUHJvbWlzZSIsIl9zdWJJZHMiLCJhbGwiLCJzdWJJZCIsIl9zdGFydEV2ZW50IiwiZXZlbnQiLCJ0eXBlIiwiZnJvbSIsIm51bWJlciIsInRvTnVtYmVyIiwiX2VtaXR0ZWQiLCJibG9jayIsIl9nZXRGaWx0ZXIiLCJmaWx0ZXIiLCJyZW1vdmVkIiwiZm9ybWF0dGVyIiwiZmlsdGVyTG9nIiwiZW1pdFJlY2VpcHQiLCJoYXNoIiwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0IiwicmVjZWlwdCIsIl9ldmVudHMiLCJsb2ciLCJfc3RvcEV2ZW50IiwibGVuZ3RoIiwibGlzdGVuZXJDb3VudCIsImRlc3Ryb3kiLCJyZWFkeVN0YXRlIiwiQ09OTkVDVElORyIsIm9uZXJyb3IiLCJjbG9zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/providers/lib.esm/ws.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/ws.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocket: () => (/* binding */ WS)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/providers/lib.esm/_version.js\");\n\n\n\nlet WS = null;\ntry {\n    WS = WebSocket;\n    if (WS == null) {\n        throw new Error(\"inject please\");\n    }\n} catch (error) {\n    const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n    WS = function() {\n        logger.throwError(\"WebSockets not supported in this environment\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    };\n}\n//export default WS;\n//module.exports = WS;\n //# sourceMappingURL=ws.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vd3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWE7QUFDa0M7QUFDVjtBQUNyQyxJQUFJRSxLQUFLO0FBQ1QsSUFBSTtJQUNBQSxLQUFLQztJQUNMLElBQUlELE1BQU0sTUFBTTtRQUNaLE1BQU0sSUFBSUUsTUFBTTtJQUNwQjtBQUNKLEVBQ0EsT0FBT0MsT0FBTztJQUNWLE1BQU1DLFNBQVMsSUFBSU4seURBQU1BLENBQUNDLDZDQUFPQTtJQUNqQ0MsS0FBSztRQUNESSxPQUFPQyxVQUFVLENBQUMsZ0RBQWdEUCx5REFBTUEsQ0FBQ1EsTUFBTSxDQUFDQyxxQkFBcUIsRUFBRTtZQUNuR0MsV0FBVztRQUNmO0lBQ0o7QUFDSjtBQUNBLG9CQUFvQjtBQUNwQixzQkFBc0I7QUFDSyxDQUMzQiw4QkFBOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL3dzLmpzPzRiYzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmxldCBXUyA9IG51bGw7XG50cnkge1xuICAgIFdTID0gV2ViU29ja2V0O1xuICAgIGlmIChXUyA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImluamVjdCBwbGVhc2VcIik7XG4gICAgfVxufVxuY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbiAgICBXUyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJXZWJTb2NrZXRzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBXZWJTb2NrZXQoKVwiXG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vL2V4cG9ydCBkZWZhdWx0IFdTO1xuLy9tb2R1bGUuZXhwb3J0cyA9IFdTO1xuZXhwb3J0IHsgV1MgYXMgV2ViU29ja2V0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13cy5qcy5tYXAiXSwibmFtZXMiOlsiTG9nZ2VyIiwidmVyc2lvbiIsIldTIiwiV2ViU29ja2V0IiwiRXJyb3IiLCJlcnJvciIsImxvZ2dlciIsInRocm93RXJyb3IiLCJlcnJvcnMiLCJVTlNVUFBPUlRFRF9PUEVSQVRJT04iLCJvcGVyYXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/providers/lib.esm/ws.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/rlp/lib.esm/_version.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/rlp/lib.esm/_version.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"rlp/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcmxwL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFVBQVUsWUFBWSxDQUNuQyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3JscC9saWIuZXNtL192ZXJzaW9uLmpzP2Y2YzUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcInJscC81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/rlp/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/rlp/lib.esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ethersproject/rlp/lib.esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/rlp/lib.esm/_version.js\");\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nfunction arrayifyInteger(value) {\n    const result = [];\n    while(value){\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for(let i = 0; i < length; i++){\n        result = result * 256 + data[offset + i];\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isBytesLike)(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n    const data = Array.prototype.slice.call((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(object));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nfunction encode(object) {\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(_encode(object));\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while(childOffset < offset + 1 + length){\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n    }\n    return {\n        consumed: 1 + length,\n        result: result\n    };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n    }\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1, length);\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return {\n            consumed: 1 + lengthLength + length,\n            result: result\n        };\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data.slice(offset + 1, offset + 1 + length));\n        return {\n            consumed: 1 + length,\n            result: result\n        };\n    }\n    return {\n        consumed: 1,\n        result: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data[offset])\n    };\n}\nfunction decode(data) {\n    const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcmxwL2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBYTtBQUNiLGdEQUFnRDtBQUNzQjtBQUN2QjtBQUNWO0FBQ3JDLE1BQU1LLFNBQVMsSUFBSUYseURBQU1BLENBQUNDLDZDQUFPQTtBQUNqQyxTQUFTRSxnQkFBZ0JDLEtBQUs7SUFDMUIsTUFBTUMsU0FBUyxFQUFFO0lBQ2pCLE1BQU9ELE1BQU87UUFDVkMsT0FBT0MsT0FBTyxDQUFDRixRQUFRO1FBQ3ZCQSxVQUFVO0lBQ2Q7SUFDQSxPQUFPQztBQUNYO0FBQ0EsU0FBU0Usa0JBQWtCQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsTUFBTTtJQUMzQyxJQUFJTCxTQUFTO0lBQ2IsSUFBSyxJQUFJTSxJQUFJLEdBQUdBLElBQUlELFFBQVFDLElBQUs7UUFDN0JOLFNBQVMsU0FBVSxNQUFPRyxJQUFJLENBQUNDLFNBQVNFLEVBQUU7SUFDOUM7SUFDQSxPQUFPTjtBQUNYO0FBQ0EsU0FBU08sUUFBUUMsTUFBTTtJQUNuQixJQUFJQyxNQUFNQyxPQUFPLENBQUNGLFNBQVM7UUFDdkIsSUFBSUcsVUFBVSxFQUFFO1FBQ2hCSCxPQUFPSSxPQUFPLENBQUMsU0FBVUMsS0FBSztZQUMxQkYsVUFBVUEsUUFBUUcsTUFBTSxDQUFDUCxRQUFRTTtRQUNyQztRQUNBLElBQUlGLFFBQVFOLE1BQU0sSUFBSSxJQUFJO1lBQ3RCTSxRQUFRVixPQUFPLENBQUMsT0FBT1UsUUFBUU4sTUFBTTtZQUNyQyxPQUFPTTtRQUNYO1FBQ0EsTUFBTU4sU0FBU1AsZ0JBQWdCYSxRQUFRTixNQUFNO1FBQzdDQSxPQUFPSixPQUFPLENBQUMsT0FBT0ksT0FBT0EsTUFBTTtRQUNuQyxPQUFPQSxPQUFPUyxNQUFNLENBQUNIO0lBQ3pCO0lBQ0EsSUFBSSxDQUFDakIsaUVBQVdBLENBQUNjLFNBQVM7UUFDdEJYLE9BQU9rQixrQkFBa0IsQ0FBQyxnQ0FBZ0MsVUFB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LEtBQUtNLE1BQU0xQixNQUFNLEVBQUU7UUFDbkNSLE9BQU9rQixrQkFBa0IsQ0FBQyxvQkFBb0IsUUFBUVo7SUFDMUQ7SUFDQSxPQUFPbUIsUUFBUXRCLE1BQU07QUFDekIsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3JscC9saWIuZXNtL2luZGV4LmpzPzFkMTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vL1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9STFBcbmltcG9ydCB7IGFycmF5aWZ5LCBoZXhsaWZ5LCBpc0J5dGVzTGlrZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZnVuY3Rpb24gYXJyYXlpZnlJbnRlZ2VyKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG4gICAgICAgIHZhbHVlID4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IChyZXN1bHQgKiAyNTYpICsgZGF0YVtvZmZzZXQgKyBpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9lbmNvZGUob2JqZWN0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBsZXQgcGF5bG9hZCA9IFtdO1xuICAgICAgICBvYmplY3QuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHBheWxvYWQgPSBwYXlsb2FkLmNvbmNhdChfZW5jb2RlKGNoaWxkKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGF5bG9hZC5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgICAgIHBheWxvYWQudW5zaGlmdCgweGMwICsgcGF5bG9hZC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXlpZnlJbnRlZ2VyKHBheWxvYWQubGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoLnVuc2hpZnQoMHhmNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbGVuZ3RoLmNvbmNhdChwYXlsb2FkKTtcbiAgICB9XG4gICAgaWYgKCFpc0J5dGVzTGlrZShvYmplY3QpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJSTFAgb2JqZWN0IG11c3QgYmUgQnl0ZXNMaWtlXCIsIFwib2JqZWN0XCIsIG9iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheWlmeShvYmplY3QpKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEgJiYgZGF0YVswXSA8PSAweDdmKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICBkYXRhLnVuc2hpZnQoMHg4MCArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihkYXRhLmxlbmd0aCk7XG4gICAgbGVuZ3RoLnVuc2hpZnQoMHhiNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgIHJldHVybiBsZW5ndGguY29uY2F0KGRhdGEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShvYmplY3QpIHtcbiAgICByZXR1cm4gaGV4bGlmeShfZW5jb2RlKG9iamVjdCkpO1xufVxuZnVuY3Rpb24gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgY2hpbGRPZmZzZXQsIGxlbmd0aCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChjaGlsZE9mZnNldCA8IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgY2hpbGRPZmZzZXQpO1xuICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkLnJlc3VsdCk7XG4gICAgICAgIGNoaWxkT2Zmc2V0ICs9IGRlY29kZWQuY29uc3VtZWQ7XG4gICAgICAgIGlmIChjaGlsZE9mZnNldCA+IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2hpbGQgZGF0YSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG59XG4vLyByZXR1cm5zIHsgY29uc3VtZWQ6IG51bWJlciwgcmVzdWx0OiBPYmplY3QgfVxuZnVuY3Rpb24gX2RlY29kZShkYXRhLCBvZmZzZXQpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgfVxuICAgIC8vIEFycmF5IHdpdGggZXh0cmEgbGVuZ3RoIHByZWZpeFxuICAgIGlmIChkYXRhW29mZnNldF0gPj0gMHhmOCkge1xuICAgICAgICBjb25zdCBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGY3O1xuICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgc2hvcnQgc2VnbWVudCB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCArIDEsIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBsb25nIHNlZ21lbnQgdG9vIHNob3J0XCIsIExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCwgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YzApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhjMDtcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIG9mZnNldCArIDEsIGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGI4KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Yjc7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBhcnJheSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCArIDEsIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBhcnJheSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweDgwKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4ODA7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxLCBvZmZzZXQgKyAxICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAxLCByZXN1bHQ6IGhleGxpZnkoZGF0YVtvZmZzZXRdKSB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShkYXRhKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeShkYXRhKTtcbiAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShieXRlcywgMCk7XG4gICAgaWYgKGRlY29kZWQuY29uc3VtZWQgIT09IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBybHAgZGF0YVwiLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkLnJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJhcnJheWlmeSIsImhleGxpZnkiLCJpc0J5dGVzTGlrZSIsIkxvZ2dlciIsInZlcnNpb24iLCJsb2dnZXIiLCJhcnJheWlmeUludGVnZXIiLCJ2YWx1ZSIsInJlc3VsdCIsInVuc2hpZnQiLCJ1bmFycmF5aWZ5SW50ZWdlciIsImRhdGEiLCJvZmZzZXQiLCJsZW5ndGgiLCJpIiwiX2VuY29kZSIsIm9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsInBheWxvYWQiLCJmb3JFYWNoIiwiY2hpbGQiLCJjb25jYXQiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJlbmNvZGUiLCJfZGVjb2RlQ2hpbGRyZW4iLCJjaGlsZE9mZnNldCIsImRlY29kZWQiLCJfZGVjb2RlIiwicHVzaCIsImNvbnN1bWVkIiwidGhyb3dFcnJvciIsImVycm9ycyIsIkJVRkZFUl9PVkVSUlVOIiwibGVuZ3RoTGVuZ3RoIiwiZGVjb2RlIiwiYnl0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/rlp/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/sha2/lib.esm/_version.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/sha2/lib.esm/_version.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"sha2/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2hhMi9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSxVQUFVLGFBQWEsQ0FDcEMsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1zdGFydGVyLWtpdC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaGEyL2xpYi5lc20vX3ZlcnNpb24uanM/NTlhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwic2hhMi81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/sha2/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/sha2/lib.esm/sha2.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ethersproject/sha2/lib.esm/sha2.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeHmac: () => (/* binding */ computeHmac),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha512: () => (/* binding */ sha512)\n/* harmony export */ });\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hash.js */ \"(ssr)/./node_modules/hash.js/lib/hash.js\");\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hash_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@ethersproject/sha2/lib.esm/types.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/sha2/lib.esm/_version.js\");\n\n\n//const _ripemd160 = _hash.ripemd160;\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(_version__WEBPACK_IMPORTED_MODULE_2__.version);\nfunction ripemd160(data) {\n    return \"0x\" + hash_js__WEBPACK_IMPORTED_MODULE_0___default().ripemd160().update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest(\"hex\");\n}\nfunction sha256(data) {\n    return \"0x\" + hash_js__WEBPACK_IMPORTED_MODULE_0___default().sha256().update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest(\"hex\");\n}\nfunction sha512(data) {\n    return \"0x\" + hash_js__WEBPACK_IMPORTED_MODULE_0___default().sha512().update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest(\"hex\");\n}\nfunction computeHmac(algorithm, key, data) {\n    if (!_types__WEBPACK_IMPORTED_MODULE_4__.SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n    return \"0x\" + hash_js__WEBPACK_IMPORTED_MODULE_0___default().hmac((hash_js__WEBPACK_IMPORTED_MODULE_0___default())[algorithm], (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(key)).update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest(\"hex\");\n} //# sourceMappingURL=sha2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2hhMi9saWIuZXNtL3NoYTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ2M7QUFDM0IscUNBQXFDO0FBQ1c7QUFDSDtBQUNFO0FBQ1Y7QUFDckMsTUFBTUssU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BO0FBQzFCLFNBQVNFLFVBQVVDLElBQUk7SUFDMUIsT0FBTyxPQUFRUCx3REFBYyxHQUFHUSxNQUFNLENBQUNQLDhEQUFRQSxDQUFDTSxPQUFPRSxNQUFNLENBQUM7QUFDbEU7QUFDTyxTQUFTQyxPQUFPSCxJQUFJO0lBQ3ZCLE9BQU8sT0FBUVAscURBQVcsR0FBR1EsTUFBTSxDQUFDUCw4REFBUUEsQ0FBQ00sT0FBT0UsTUFBTSxDQUFDO0FBQy9EO0FBQ08sU0FBU0UsT0FBT0osSUFBSTtJQUN2QixPQUFPLE9BQVFQLHFEQUFXLEdBQUdRLE1BQU0sQ0FBQ1AsOERBQVFBLENBQUNNLE9BQU9FLE1BQU0sQ0FBQztBQUMvRDtBQUNPLFNBQVNHLFlBQVlDLFNBQVMsRUFBRUMsR0FBRyxFQUFFUCxJQUFJO0lBQzVDLElBQUksQ0FBQ0wsc0RBQWtCLENBQUNXLFVBQVUsRUFBRTtRQUNoQ1IsT0FBT1UsVUFBVSxDQUFDLDJCQUEyQkYsV0FBV1YseURBQU1BLENBQUNhLE1BQU0sQ0FBQ0MscUJBQXFCLEVBQUU7WUFDekZDLFdBQVc7WUFDWEwsV0FBV0E7UUFDZjtJQUNKO0lBQ0EsT0FBTyxPQUFPYixtREFBUyxDQUFDQSxnREFBSSxDQUFDYSxVQUFVLEVBQUVaLDhEQUFRQSxDQUFDYSxNQUFNTixNQUFNLENBQUNQLDhEQUFRQSxDQUFDTSxPQUFPRSxNQUFNLENBQUM7QUFDMUYsRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NoYTIvbGliLmVzbS9zaGEyLmpzPzk2NzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgaGFzaCBmcm9tIFwiaGFzaC5qc1wiO1xuLy9jb25zdCBfcmlwZW1kMTYwID0gX2hhc2gucmlwZW1kMTYwO1xuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IFN1cHBvcnRlZEFsZ29yaXRobSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgZnVuY3Rpb24gcmlwZW1kMTYwKGRhdGEpIHtcbiAgICByZXR1cm4gXCIweFwiICsgKGhhc2gucmlwZW1kMTYwKCkudXBkYXRlKGFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNoYTI1NihkYXRhKSB7XG4gICAgcmV0dXJuIFwiMHhcIiArIChoYXNoLnNoYTI1NigpLnVwZGF0ZShhcnJheWlmeShkYXRhKSkuZGlnZXN0KFwiaGV4XCIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaGE1MTIoZGF0YSkge1xuICAgIHJldHVybiBcIjB4XCIgKyAoaGFzaC5zaGE1MTIoKS51cGRhdGUoYXJyYXlpZnkoZGF0YSkpLmRpZ2VzdChcImhleFwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhtYWMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICBpZiAoIVN1cHBvcnRlZEFsZ29yaXRobVthbGdvcml0aG1dKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtIFwiICsgYWxnb3JpdGhtLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImhtYWNcIixcbiAgICAgICAgICAgIGFsZ29yaXRobTogYWxnb3JpdGhtXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgaGFzaC5obWFjKGhhc2hbYWxnb3JpdGhtXSwgYXJyYXlpZnkoa2V5KSkudXBkYXRlKGFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyLmpzLm1hcCJdLCJuYW1lcyI6WyJoYXNoIiwiYXJyYXlpZnkiLCJTdXBwb3J0ZWRBbGdvcml0aG0iLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwicmlwZW1kMTYwIiwiZGF0YSIsInVwZGF0ZSIsImRpZ2VzdCIsInNoYTI1NiIsInNoYTUxMiIsImNvbXB1dGVIbWFjIiwiYWxnb3JpdGhtIiwia2V5IiwidGhyb3dFcnJvciIsImVycm9ycyIsIlVOU1VQUE9SVEVEX09QRVJBVElPTiIsIm9wZXJhdGlvbiIsImhtYWMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/sha2/lib.esm/sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/sha2/lib.esm/types.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ethersproject/sha2/lib.esm/types.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SupportedAlgorithm: () => (/* binding */ SupportedAlgorithm)\n/* harmony export */ });\nvar SupportedAlgorithm;\n(function(SupportedAlgorithm) {\n    SupportedAlgorithm[\"sha256\"] = \"sha256\";\n    SupportedAlgorithm[\"sha512\"] = \"sha512\";\n})(SupportedAlgorithm || (SupportedAlgorithm = {}));\n; //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2hhMi9saWIuZXNtL3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxJQUFJQSxtQkFBbUI7QUFDN0IsVUFBVUEsa0JBQWtCO0lBQ3pCQSxrQkFBa0IsQ0FBQyxTQUFTLEdBQUc7SUFDL0JBLGtCQUFrQixDQUFDLFNBQVMsR0FBRztBQUNuQyxHQUFHQSxzQkFBdUJBLENBQUFBLHFCQUFxQixDQUFDO0VBRWhELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2hhMi9saWIuZXNtL3R5cGVzLmpzPzA3OTYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBTdXBwb3J0ZWRBbGdvcml0aG07XG4oZnVuY3Rpb24gKFN1cHBvcnRlZEFsZ29yaXRobSkge1xuICAgIFN1cHBvcnRlZEFsZ29yaXRobVtcInNoYTI1NlwiXSA9IFwic2hhMjU2XCI7XG4gICAgU3VwcG9ydGVkQWxnb3JpdGhtW1wic2hhNTEyXCJdID0gXCJzaGE1MTJcIjtcbn0pKFN1cHBvcnRlZEFsZ29yaXRobSB8fCAoU3VwcG9ydGVkQWxnb3JpdGhtID0ge30pKTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJTdXBwb3J0ZWRBbGdvcml0aG0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/sha2/lib.esm/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/signing-key/lib.esm/_version.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ethersproject/signing-key/lib.esm/_version.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"signing-key/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2lnbmluZy1rZXkvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSxvQkFBb0IsQ0FDM0Msb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1zdGFydGVyLWtpdC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIuZXNtL192ZXJzaW9uLmpzPzhjMDkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcInNpZ25pbmcta2V5LzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/signing-key/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/signing-key/lib.esm/elliptic.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ethersproject/signing-key/lib.esm/elliptic.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EC: () => (/* binding */ EC$1)\n/* harmony export */ });\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hash.js */ \"(ssr)/./node_modules/hash.js/lib/hash.js\");\n/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(hash_js__WEBPACK_IMPORTED_MODULE_1__);\n\n\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nfunction createCommonjsModule(fn, basedir, module) {\n    return module = {\n        path: basedir,\n        exports: {},\n        require: function(path, base) {\n            return commonjsRequire(path, base === undefined || base === null ? module.path : base);\n        }\n    }, fn(module, module.exports), module.exports;\n}\nfunction getDefaultExportFromNamespaceIfPresent(n) {\n    return n && Object.prototype.hasOwnProperty.call(n, \"default\") ? n[\"default\"] : n;\n}\nfunction getDefaultExportFromNamespaceIfNotNamed(n) {\n    return n && Object.prototype.hasOwnProperty.call(n, \"default\") && Object.keys(n).length === 1 ? n[\"default\"] : n;\n}\nfunction getAugmentedNamespace(n) {\n    if (n.__esModule) return n;\n    var a = Object.defineProperty({}, \"__esModule\", {\n        value: true\n    });\n    Object.keys(n).forEach(function(k) {\n        var d = Object.getOwnPropertyDescriptor(n, k);\n        Object.defineProperty(a, k, d.get ? d : {\n            enumerable: true,\n            get: function() {\n                return n[k];\n            }\n        });\n    });\n    return a;\n}\nfunction commonjsRequire() {\n    throw new Error(\"Dynamic requires are not currently supported by @rollup/plugin-commonjs\");\n}\nvar minimalisticAssert = assert;\nfunction assert(val, msg) {\n    if (!val) throw new Error(msg || \"Assertion failed\");\n}\nassert.equal = function assertEqual(l, r, msg) {\n    if (l != r) throw new Error(msg || \"Assertion failed: \" + l + \" != \" + r);\n};\nvar utils_1 = createCommonjsModule(function(module, exports) {\n    \"use strict\";\n    var utils = exports;\n    function toArray(msg, enc) {\n        if (Array.isArray(msg)) return msg.slice();\n        if (!msg) return [];\n        var res = [];\n        if (typeof msg !== \"string\") {\n            for(var i = 0; i < msg.length; i++)res[i] = msg[i] | 0;\n            return res;\n        }\n        if (enc === \"hex\") {\n            msg = msg.replace(/[^a-z0-9]+/ig, \"\");\n            if (msg.length % 2 !== 0) msg = \"0\" + msg;\n            for(var i = 0; i < msg.length; i += 2)res.push(parseInt(msg[i] + msg[i + 1], 16));\n        } else {\n            for(var i = 0; i < msg.length; i++){\n                var c = msg.charCodeAt(i);\n                var hi = c >> 8;\n                var lo = c & 0xff;\n                if (hi) res.push(hi, lo);\n                else res.push(lo);\n            }\n        }\n        return res;\n    }\n    utils.toArray = toArray;\n    function zero2(word) {\n        if (word.length === 1) return \"0\" + word;\n        else return word;\n    }\n    utils.zero2 = zero2;\n    function toHex(msg) {\n        var res = \"\";\n        for(var i = 0; i < msg.length; i++)res += zero2(msg[i].toString(16));\n        return res;\n    }\n    utils.toHex = toHex;\n    utils.encode = function encode(arr, enc) {\n        if (enc === \"hex\") return toHex(arr);\n        else return arr;\n    };\n});\nvar utils_1$1 = createCommonjsModule(function(module, exports) {\n    \"use strict\";\n    var utils = exports;\n    utils.assert = minimalisticAssert;\n    utils.toArray = utils_1.toArray;\n    utils.zero2 = utils_1.zero2;\n    utils.toHex = utils_1.toHex;\n    utils.encode = utils_1.encode;\n    // Represent num in a w-NAF form\n    function getNAF(num, w, bits) {\n        var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n        naf.fill(0);\n        var ws = 1 << w + 1;\n        var k = num.clone();\n        for(var i = 0; i < naf.length; i++){\n            var z;\n            var mod = k.andln(ws - 1);\n            if (k.isOdd()) {\n                if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;\n                else z = mod;\n                k.isubn(z);\n            } else {\n                z = 0;\n            }\n            naf[i] = z;\n            k.iushrn(1);\n        }\n        return naf;\n    }\n    utils.getNAF = getNAF;\n    // Represent k1, k2 in a Joint Sparse Form\n    function getJSF(k1, k2) {\n        var jsf = [\n            [],\n            []\n        ];\n        k1 = k1.clone();\n        k2 = k2.clone();\n        var d1 = 0;\n        var d2 = 0;\n        var m8;\n        while(k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0){\n            // First phase\n            var m14 = k1.andln(3) + d1 & 3;\n            var m24 = k2.andln(3) + d2 & 3;\n            if (m14 === 3) m14 = -1;\n            if (m24 === 3) m24 = -1;\n            var u1;\n            if ((m14 & 1) === 0) {\n                u1 = 0;\n            } else {\n                m8 = k1.andln(7) + d1 & 7;\n                if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;\n                else u1 = m14;\n            }\n            jsf[0].push(u1);\n            var u2;\n            if ((m24 & 1) === 0) {\n                u2 = 0;\n            } else {\n                m8 = k2.andln(7) + d2 & 7;\n                if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;\n                else u2 = m24;\n            }\n            jsf[1].push(u2);\n            // Second phase\n            if (2 * d1 === u1 + 1) d1 = 1 - d1;\n            if (2 * d2 === u2 + 1) d2 = 1 - d2;\n            k1.iushrn(1);\n            k2.iushrn(1);\n        }\n        return jsf;\n    }\n    utils.getJSF = getJSF;\n    function cachedProperty(obj, name, computer) {\n        var key = \"_\" + name;\n        obj.prototype[name] = function cachedProperty() {\n            return this[key] !== undefined ? this[key] : this[key] = computer.call(this);\n        };\n    }\n    utils.cachedProperty = cachedProperty;\n    function parseBytes(bytes) {\n        return typeof bytes === \"string\" ? utils.toArray(bytes, \"hex\") : bytes;\n    }\n    utils.parseBytes = parseBytes;\n    function intFromLE(bytes) {\n        return new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(bytes, \"hex\", \"le\");\n    }\n    utils.intFromLE = intFromLE;\n});\n\"use strict\";\nvar getNAF = utils_1$1.getNAF;\nvar getJSF = utils_1$1.getJSF;\nvar assert$1 = utils_1$1.assert;\nfunction BaseCurve(type, conf) {\n    this.type = type;\n    this.p = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.p, 16);\n    // Use Montgomery, when there is no fast reduction for the prime\n    this.red = conf.prime ? bn_js__WEBPACK_IMPORTED_MODULE_0___default().red(conf.prime) : bn_js__WEBPACK_IMPORTED_MODULE_0___default().mont(this.p);\n    // Useful for many curves\n    this.zero = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0).toRed(this.red);\n    this.one = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1).toRed(this.red);\n    this.two = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(2).toRed(this.red);\n    // Curve configuration, optional\n    this.n = conf.n && new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.n, 16);\n    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n    // Temporary arrays\n    this._wnafT1 = new Array(4);\n    this._wnafT2 = new Array(4);\n    this._wnafT3 = new Array(4);\n    this._wnafT4 = new Array(4);\n    this._bitLength = this.n ? this.n.bitLength() : 0;\n    // Generalized Greg Maxwell's trick\n    var adjustCount = this.n && this.p.div(this.n);\n    if (!adjustCount || adjustCount.cmpn(100) > 0) {\n        this.redN = null;\n    } else {\n        this._maxwellTrick = true;\n        this.redN = this.n.toRed(this.red);\n    }\n}\nvar base = BaseCurve;\nBaseCurve.prototype.point = function point() {\n    throw new Error(\"Not implemented\");\n};\nBaseCurve.prototype.validate = function validate() {\n    throw new Error(\"Not implemented\");\n};\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n    assert$1(p.precomputed);\n    var doubles = p._getDoubles();\n    var naf = getNAF(k, 1, this._bitLength);\n    var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);\n    I /= 3;\n    // Translate into more windowed form\n    var repr = [];\n    var j;\n    var nafW;\n    for(j = 0; j < naf.length; j += doubles.step){\n        nafW = 0;\n        for(var l = j + doubles.step - 1; l >= j; l--)nafW = (nafW << 1) + naf[l];\n        repr.push(nafW);\n    }\n    var a = this.jpoint(null, null, null);\n    var b = this.jpoint(null, null, null);\n    for(var i = I; i > 0; i--){\n        for(j = 0; j < repr.length; j++){\n            nafW = repr[j];\n            if (nafW === i) b = b.mixedAdd(doubles.points[j]);\n            else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());\n        }\n        a = a.add(b);\n    }\n    return a.toP();\n};\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n    var w = 4;\n    // Precompute window\n    var nafPoints = p._getNAFPoints(w);\n    w = nafPoints.wnd;\n    var wnd = nafPoints.points;\n    // Get NAF form\n    var naf = getNAF(k, w, this._bitLength);\n    // Add `this`*(N+1) for every w-NAF index\n    var acc = this.jpoint(null, null, null);\n    for(var i = naf.length - 1; i >= 0; i--){\n        // Count zeroes\n        for(var l = 0; i >= 0 && naf[i] === 0; i--)l++;\n        if (i >= 0) l++;\n        acc = acc.dblp(l);\n        if (i < 0) break;\n        var z = naf[i];\n        assert$1(z !== 0);\n        if (p.type === \"affine\") {\n            // J +- P\n            if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]);\n            else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());\n        } else {\n            // J +- J\n            if (z > 0) acc = acc.add(wnd[z - 1 >> 1]);\n            else acc = acc.add(wnd[-z - 1 >> 1].neg());\n        }\n    }\n    return p.type === \"affine\" ? acc.toP() : acc;\n};\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {\n    var wndWidth = this._wnafT1;\n    var wnd = this._wnafT2;\n    var naf = this._wnafT3;\n    // Fill all arrays\n    var max = 0;\n    var i;\n    var j;\n    var p;\n    for(i = 0; i < len; i++){\n        p = points[i];\n        var nafPoints = p._getNAFPoints(defW);\n        wndWidth[i] = nafPoints.wnd;\n        wnd[i] = nafPoints.points;\n    }\n    // Comb small window NAFs\n    for(i = len - 1; i >= 1; i -= 2){\n        var a = i - 1;\n        var b = i;\n        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n            naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n            naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n            max = Math.max(naf[a].length, max);\n            max = Math.max(naf[b].length, max);\n            continue;\n        }\n        var comb = [\n            points[a],\n            /* 1 */ null,\n            /* 3 */ null,\n            /* 5 */ points[b]\n        ];\n        // Try to avoid Projective points, if possible\n        if (points[a].y.cmp(points[b].y) === 0) {\n            comb[1] = points[a].add(points[b]);\n            comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n            comb[1] = points[a].toJ().mixedAdd(points[b]);\n            comb[2] = points[a].add(points[b].neg());\n        } else {\n            comb[1] = points[a].toJ().mixedAdd(points[b]);\n            comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n        }\n        var index = [\n            -3,\n            /* -1 -1 */ -1,\n            /* -1 0 */ -5,\n            /* -1 1 */ -7,\n            /* 0 -1 */ 0,\n            /* 0 0 */ 7,\n            /* 0 1 */ 5,\n            /* 1 -1 */ 1,\n            /* 1 0 */ 3\n        ];\n        var jsf = getJSF(coeffs[a], coeffs[b]);\n        max = Math.max(jsf[0].length, max);\n        naf[a] = new Array(max);\n        naf[b] = new Array(max);\n        for(j = 0; j < max; j++){\n            var ja = jsf[0][j] | 0;\n            var jb = jsf[1][j] | 0;\n            naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n            naf[b][j] = 0;\n            wnd[a] = comb;\n        }\n    }\n    var acc = this.jpoint(null, null, null);\n    var tmp = this._wnafT4;\n    for(i = max; i >= 0; i--){\n        var k = 0;\n        while(i >= 0){\n            var zero = true;\n            for(j = 0; j < len; j++){\n                tmp[j] = naf[j][i] | 0;\n                if (tmp[j] !== 0) zero = false;\n            }\n            if (!zero) break;\n            k++;\n            i--;\n        }\n        if (i >= 0) k++;\n        acc = acc.dblp(k);\n        if (i < 0) break;\n        for(j = 0; j < len; j++){\n            var z = tmp[j];\n            p;\n            if (z === 0) continue;\n            else if (z > 0) p = wnd[j][z - 1 >> 1];\n            else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();\n            if (p.type === \"affine\") acc = acc.mixedAdd(p);\n            else acc = acc.add(p);\n        }\n    }\n    // Zeroify references\n    for(i = 0; i < len; i++)wnd[i] = null;\n    if (jacobianResult) return acc;\n    else return acc.toP();\n};\nfunction BasePoint(curve, type) {\n    this.curve = curve;\n    this.type = type;\n    this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\nBasePoint.prototype.eq = function eq() {\n    throw new Error(\"Not implemented\");\n};\nBasePoint.prototype.validate = function validate() {\n    return this.curve.validate(this);\n};\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n    bytes = utils_1$1.toArray(bytes, enc);\n    var len = this.p.byteLength();\n    // uncompressed, hybrid-odd, hybrid-even\n    if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) && bytes.length - 1 === 2 * len) {\n        if (bytes[0] === 0x06) assert$1(bytes[bytes.length - 1] % 2 === 0);\n        else if (bytes[0] === 0x07) assert$1(bytes[bytes.length - 1] % 2 === 1);\n        var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));\n        return res;\n    } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) && bytes.length - 1 === len) {\n        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n    }\n    throw new Error(\"Unknown point format\");\n};\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n    return this.encode(enc, true);\n};\nBasePoint.prototype._encode = function _encode(compact) {\n    var len = this.curve.p.byteLength();\n    var x = this.getX().toArray(\"be\", len);\n    if (compact) return [\n        this.getY().isEven() ? 0x02 : 0x03\n    ].concat(x);\n    return [\n        0x04\n    ].concat(x, this.getY().toArray(\"be\", len));\n};\nBasePoint.prototype.encode = function encode(enc, compact) {\n    return utils_1$1.encode(this._encode(compact), enc);\n};\nBasePoint.prototype.precompute = function precompute(power) {\n    if (this.precomputed) return this;\n    var precomputed = {\n        doubles: null,\n        naf: null,\n        beta: null\n    };\n    precomputed.naf = this._getNAFPoints(8);\n    precomputed.doubles = this._getDoubles(4, power);\n    precomputed.beta = this._getBeta();\n    this.precomputed = precomputed;\n    return this;\n};\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n    if (!this.precomputed) return false;\n    var doubles = this.precomputed.doubles;\n    if (!doubles) return false;\n    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;\n    var doubles = [\n        this\n    ];\n    var acc = this;\n    for(var i = 0; i < power; i += step){\n        for(var j = 0; j < step; j++)acc = acc.dbl();\n        doubles.push(acc);\n    }\n    return {\n        step: step,\n        points: doubles\n    };\n};\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;\n    var res = [\n        this\n    ];\n    var max = (1 << wnd) - 1;\n    var dbl = max === 1 ? null : this.dbl();\n    for(var i = 1; i < max; i++)res[i] = res[i - 1].add(dbl);\n    return {\n        wnd: wnd,\n        points: res\n    };\n};\nBasePoint.prototype._getBeta = function _getBeta() {\n    return null;\n};\nBasePoint.prototype.dblp = function dblp(k) {\n    var r = this;\n    for(var i = 0; i < k; i++)r = r.dbl();\n    return r;\n};\nvar inherits_browser = createCommonjsModule(function(module) {\n    if (typeof Object.create === \"function\") {\n        // implementation from standard node.js 'util' module\n        module.exports = function inherits(ctor, superCtor) {\n            if (superCtor) {\n                ctor.super_ = superCtor;\n                ctor.prototype = Object.create(superCtor.prototype, {\n                    constructor: {\n                        value: ctor,\n                        enumerable: false,\n                        writable: true,\n                        configurable: true\n                    }\n                });\n            }\n        };\n    } else {\n        // old school shim for old browsers\n        module.exports = function inherits(ctor, superCtor) {\n            if (superCtor) {\n                ctor.super_ = superCtor;\n                var TempCtor = function() {};\n                TempCtor.prototype = superCtor.prototype;\n                ctor.prototype = new TempCtor();\n                ctor.prototype.constructor = ctor;\n            }\n        };\n    }\n});\n\"use strict\";\nvar assert$2 = utils_1$1.assert;\nfunction ShortCurve(conf) {\n    base.call(this, \"short\", conf);\n    this.a = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.a, 16).toRed(this.red);\n    this.b = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.b, 16).toRed(this.red);\n    this.tinv = this.two.redInvm();\n    this.zeroA = this.a.fromRed().cmpn(0) === 0;\n    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n    // If the curve is endomorphic, precalculate beta and lambda\n    this.endo = this._getEndomorphism(conf);\n    this._endoWnafT1 = new Array(4);\n    this._endoWnafT2 = new Array(4);\n}\ninherits_browser(ShortCurve, base);\nvar short_1 = ShortCurve;\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n    // No efficient endomorphism\n    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return;\n    // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n    var beta;\n    var lambda;\n    if (conf.beta) {\n        beta = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.beta, 16).toRed(this.red);\n    } else {\n        var betas = this._getEndoRoots(this.p);\n        // Choose the smallest beta\n        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n        beta = beta.toRed(this.red);\n    }\n    if (conf.lambda) {\n        lambda = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.lambda, 16);\n    } else {\n        // Choose the lambda that is matching selected beta\n        var lambdas = this._getEndoRoots(this.n);\n        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n            lambda = lambdas[0];\n        } else {\n            lambda = lambdas[1];\n            assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n        }\n    }\n    // Get basis vectors, used for balanced length-two representation\n    var basis;\n    if (conf.basis) {\n        basis = conf.basis.map(function(vec) {\n            return {\n                a: new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(vec.a, 16),\n                b: new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(vec.b, 16)\n            };\n        });\n    } else {\n        basis = this._getEndoBasis(lambda);\n    }\n    return {\n        beta: beta,\n        lambda: lambda,\n        basis: basis\n    };\n};\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n    // Find roots of for x^2 + x + 1 in F\n    // Root = (-1 +- Sqrt(-3)) / 2\n    //\n    var red = num === this.p ? this.red : bn_js__WEBPACK_IMPORTED_MODULE_0___default().mont(num);\n    var tinv = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(2).toRed(red).redInvm();\n    var ntinv = tinv.redNeg();\n    var s = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n    var l1 = ntinv.redAdd(s).fromRed();\n    var l2 = ntinv.redSub(s).fromRed();\n    return [\n        l1,\n        l2\n    ];\n};\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n    // aprxSqrt >= sqrt(this.n)\n    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n    // 3.74\n    // Run EGCD, until r(L + 1) < aprxSqrt\n    var u = lambda;\n    var v = this.n.clone();\n    var x1 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1);\n    var y1 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0);\n    var x2 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0);\n    var y2 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1);\n    // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n    var a0;\n    var b0;\n    // First vector\n    var a1;\n    var b1;\n    // Second vector\n    var a2;\n    var b2;\n    var prevR;\n    var i = 0;\n    var r;\n    var x;\n    while(u.cmpn(0) !== 0){\n        var q = v.div(u);\n        r = v.sub(q.mul(u));\n        x = x2.sub(q.mul(x1));\n        var y = y2.sub(q.mul(y1));\n        if (!a1 && r.cmp(aprxSqrt) < 0) {\n            a0 = prevR.neg();\n            b0 = x1;\n            a1 = r.neg();\n            b1 = x;\n        } else if (a1 && ++i === 2) {\n            break;\n        }\n        prevR = r;\n        v = u;\n        u = r;\n        x2 = x1;\n        x1 = x;\n        y2 = y1;\n        y1 = y;\n    }\n    a2 = r.neg();\n    b2 = x;\n    var len1 = a1.sqr().add(b1.sqr());\n    var len2 = a2.sqr().add(b2.sqr());\n    if (len2.cmp(len1) >= 0) {\n        a2 = a0;\n        b2 = b0;\n    }\n    // Normalize signs\n    if (a1.negative) {\n        a1 = a1.neg();\n        b1 = b1.neg();\n    }\n    if (a2.negative) {\n        a2 = a2.neg();\n        b2 = b2.neg();\n    }\n    return [\n        {\n            a: a1,\n            b: b1\n        },\n        {\n            a: a2,\n            b: b2\n        }\n    ];\n};\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n    var basis = this.endo.basis;\n    var v1 = basis[0];\n    var v2 = basis[1];\n    var c1 = v2.b.mul(k).divRound(this.n);\n    var c2 = v1.b.neg().mul(k).divRound(this.n);\n    var p1 = c1.mul(v1.a);\n    var p2 = c2.mul(v2.a);\n    var q1 = c1.mul(v1.b);\n    var q2 = c2.mul(v2.b);\n    // Calculate answer\n    var k1 = k.sub(p1).sub(p2);\n    var k2 = q1.add(q2).neg();\n    return {\n        k1: k1,\n        k2: k2\n    };\n};\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n    x = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(x, 16);\n    if (!x.red) x = x.toRed(this.red);\n    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n    var y = y2.redSqrt();\n    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error(\"invalid point\");\n    // XXX Is there any way to tell if the number is odd without converting it\n    // to non-red form?\n    var isOdd = y.fromRed().isOdd();\n    if (odd && !isOdd || !odd && isOdd) y = y.redNeg();\n    return this.point(x, y);\n};\nShortCurve.prototype.validate = function validate(point) {\n    if (point.inf) return true;\n    var x = point.x;\n    var y = point.y;\n    var ax = this.a.redMul(x);\n    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n    return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\nShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n    var npoints = this._endoWnafT1;\n    var ncoeffs = this._endoWnafT2;\n    for(var i = 0; i < points.length; i++){\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n        if (split.k1.negative) {\n            split.k1.ineg();\n            p = p.neg(true);\n        }\n        if (split.k2.negative) {\n            split.k2.ineg();\n            beta = beta.neg(true);\n        }\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n    }\n    var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n    // Clean-up references to points and coefficients\n    for(var j = 0; j < i * 2; j++){\n        npoints[j] = null;\n        ncoeffs[j] = null;\n    }\n    return res;\n};\nfunction Point(curve, x, y, isRed) {\n    base.BasePoint.call(this, curve, \"affine\");\n    if (x === null && y === null) {\n        this.x = null;\n        this.y = null;\n        this.inf = true;\n    } else {\n        this.x = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(x, 16);\n        this.y = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(y, 16);\n        // Force redgomery representation when loading from JSON\n        if (isRed) {\n            this.x.forceRed(this.curve.red);\n            this.y.forceRed(this.curve.red);\n        }\n        if (!this.x.red) this.x = this.x.toRed(this.curve.red);\n        if (!this.y.red) this.y = this.y.toRed(this.curve.red);\n        this.inf = false;\n    }\n}\ninherits_browser(Point, base.BasePoint);\nShortCurve.prototype.point = function point(x, y, isRed) {\n    return new Point(this, x, y, isRed);\n};\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n    return Point.fromJSON(this, obj, red);\n};\nPoint.prototype._getBeta = function _getBeta() {\n    if (!this.curve.endo) return;\n    var pre = this.precomputed;\n    if (pre && pre.beta) return pre.beta;\n    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n    if (pre) {\n        var curve = this.curve;\n        var endoMul = function(p) {\n            return curve.point(p.x.redMul(curve.endo.beta), p.y);\n        };\n        pre.beta = beta;\n        beta.precomputed = {\n            beta: null,\n            naf: pre.naf && {\n                wnd: pre.naf.wnd,\n                points: pre.naf.points.map(endoMul)\n            },\n            doubles: pre.doubles && {\n                step: pre.doubles.step,\n                points: pre.doubles.points.map(endoMul)\n            }\n        };\n    }\n    return beta;\n};\nPoint.prototype.toJSON = function toJSON() {\n    if (!this.precomputed) return [\n        this.x,\n        this.y\n    ];\n    return [\n        this.x,\n        this.y,\n        this.precomputed && {\n            doubles: this.precomputed.doubles && {\n                step: this.precomputed.doubles.step,\n                points: this.precomputed.doubles.points.slice(1)\n            },\n            naf: this.precomputed.naf && {\n                wnd: this.precomputed.naf.wnd,\n                points: this.precomputed.naf.points.slice(1)\n            }\n        }\n    ];\n};\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n    if (typeof obj === \"string\") obj = JSON.parse(obj);\n    var res = curve.point(obj[0], obj[1], red);\n    if (!obj[2]) return res;\n    function obj2point(obj) {\n        return curve.point(obj[0], obj[1], red);\n    }\n    var pre = obj[2];\n    res.precomputed = {\n        beta: null,\n        doubles: pre.doubles && {\n            step: pre.doubles.step,\n            points: [\n                res\n            ].concat(pre.doubles.points.map(obj2point))\n        },\n        naf: pre.naf && {\n            wnd: pre.naf.wnd,\n            points: [\n                res\n            ].concat(pre.naf.points.map(obj2point))\n        }\n    };\n    return res;\n};\nPoint.prototype.inspect = function inspect() {\n    if (this.isInfinity()) return \"<EC Point Infinity>\";\n    return \"<EC Point x: \" + this.x.fromRed().toString(16, 2) + \" y: \" + this.y.fromRed().toString(16, 2) + \">\";\n};\nPoint.prototype.isInfinity = function isInfinity() {\n    return this.inf;\n};\nPoint.prototype.add = function add(p) {\n    // O + P = P\n    if (this.inf) return p;\n    // P + O = P\n    if (p.inf) return this;\n    // P + P = 2P\n    if (this.eq(p)) return this.dbl();\n    // P + (-P) = O\n    if (this.neg().eq(p)) return this.curve.point(null, null);\n    // P + Q = O\n    if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);\n    var c = this.y.redSub(p.y);\n    if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());\n    var nx = c.redSqr().redISub(this.x).redISub(p.x);\n    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n    return this.curve.point(nx, ny);\n};\nPoint.prototype.dbl = function dbl() {\n    if (this.inf) return this;\n    // 2P = O\n    var ys1 = this.y.redAdd(this.y);\n    if (ys1.cmpn(0) === 0) return this.curve.point(null, null);\n    var a = this.curve.a;\n    var x2 = this.x.redSqr();\n    var dyinv = ys1.redInvm();\n    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n    var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n    return this.curve.point(nx, ny);\n};\nPoint.prototype.getX = function getX() {\n    return this.x.fromRed();\n};\nPoint.prototype.getY = function getY() {\n    return this.y.fromRed();\n};\nPoint.prototype.mul = function mul(k) {\n    k = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(k, 16);\n    if (this.isInfinity()) return this;\n    else if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);\n    else if (this.curve.endo) return this.curve._endoWnafMulAdd([\n        this\n    ], [\n        k\n    ]);\n    else return this.curve._wnafMul(this, k);\n};\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n    var points = [\n        this,\n        p2\n    ];\n    var coeffs = [\n        k1,\n        k2\n    ];\n    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs);\n    else return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n    var points = [\n        this,\n        p2\n    ];\n    var coeffs = [\n        k1,\n        k2\n    ];\n    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs, true);\n    else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\nPoint.prototype.eq = function eq(p) {\n    return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\nPoint.prototype.neg = function neg(_precompute) {\n    if (this.inf) return this;\n    var res = this.curve.point(this.x, this.y.redNeg());\n    if (_precompute && this.precomputed) {\n        var pre = this.precomputed;\n        var negate = function(p) {\n            return p.neg();\n        };\n        res.precomputed = {\n            naf: pre.naf && {\n                wnd: pre.naf.wnd,\n                points: pre.naf.points.map(negate)\n            },\n            doubles: pre.doubles && {\n                step: pre.doubles.step,\n                points: pre.doubles.points.map(negate)\n            }\n        };\n    }\n    return res;\n};\nPoint.prototype.toJ = function toJ() {\n    if (this.inf) return this.curve.jpoint(null, null, null);\n    var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n    return res;\n};\nfunction JPoint(curve, x, y, z) {\n    base.BasePoint.call(this, curve, \"jacobian\");\n    if (x === null && y === null && z === null) {\n        this.x = this.curve.one;\n        this.y = this.curve.one;\n        this.z = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0);\n    } else {\n        this.x = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(x, 16);\n        this.y = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(y, 16);\n        this.z = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(z, 16);\n    }\n    if (!this.x.red) this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red) this.y = this.y.toRed(this.curve.red);\n    if (!this.z.red) this.z = this.z.toRed(this.curve.red);\n    this.zOne = this.z === this.curve.one;\n}\ninherits_browser(JPoint, base.BasePoint);\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n    return new JPoint(this, x, y, z);\n};\nJPoint.prototype.toP = function toP() {\n    if (this.isInfinity()) return this.curve.point(null, null);\n    var zinv = this.z.redInvm();\n    var zinv2 = zinv.redSqr();\n    var ax = this.x.redMul(zinv2);\n    var ay = this.y.redMul(zinv2).redMul(zinv);\n    return this.curve.point(ax, ay);\n};\nJPoint.prototype.neg = function neg() {\n    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\nJPoint.prototype.add = function add(p) {\n    // O + P = P\n    if (this.isInfinity()) return p;\n    // P + O = P\n    if (p.isInfinity()) return this;\n    // 12M + 4S + 7A\n    var pz2 = p.z.redSqr();\n    var z2 = this.z.redSqr();\n    var u1 = this.x.redMul(pz2);\n    var u2 = p.x.redMul(z2);\n    var s1 = this.y.redMul(pz2.redMul(p.z));\n    var s2 = p.y.redMul(z2.redMul(this.z));\n    var h = u1.redSub(u2);\n    var r = s1.redSub(s2);\n    if (h.cmpn(0) === 0) {\n        if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);\n        else return this.dbl();\n    }\n    var h2 = h.redSqr();\n    var h3 = h2.redMul(h);\n    var v = u1.redMul(h2);\n    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n    var nz = this.z.redMul(p.z).redMul(h);\n    return this.curve.jpoint(nx, ny, nz);\n};\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n    // O + P = P\n    if (this.isInfinity()) return p.toJ();\n    // P + O = P\n    if (p.isInfinity()) return this;\n    // 8M + 3S + 7A\n    var z2 = this.z.redSqr();\n    var u1 = this.x;\n    var u2 = p.x.redMul(z2);\n    var s1 = this.y;\n    var s2 = p.y.redMul(z2).redMul(this.z);\n    var h = u1.redSub(u2);\n    var r = s1.redSub(s2);\n    if (h.cmpn(0) === 0) {\n        if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);\n        else return this.dbl();\n    }\n    var h2 = h.redSqr();\n    var h3 = h2.redMul(h);\n    var v = u1.redMul(h2);\n    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n    var nz = this.z.redMul(h);\n    return this.curve.jpoint(nx, ny, nz);\n};\nJPoint.prototype.dblp = function dblp(pow) {\n    if (pow === 0) return this;\n    if (this.isInfinity()) return this;\n    if (!pow) return this.dbl();\n    var i;\n    if (this.curve.zeroA || this.curve.threeA) {\n        var r = this;\n        for(i = 0; i < pow; i++)r = r.dbl();\n        return r;\n    }\n    // 1M + 2S + 1A + N * (4S + 5M + 8A)\n    // N = 1 => 6M + 6S + 9A\n    var a = this.curve.a;\n    var tinv = this.curve.tinv;\n    var jx = this.x;\n    var jy = this.y;\n    var jz = this.z;\n    var jz4 = jz.redSqr().redSqr();\n    // Reuse results\n    var jyd = jy.redAdd(jy);\n    for(i = 0; i < pow; i++){\n        var jx2 = jx.redSqr();\n        var jyd2 = jyd.redSqr();\n        var jyd4 = jyd2.redSqr();\n        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n        var t1 = jx.redMul(jyd2);\n        var nx = c.redSqr().redISub(t1.redAdd(t1));\n        var t2 = t1.redISub(nx);\n        var dny = c.redMul(t2);\n        dny = dny.redIAdd(dny).redISub(jyd4);\n        var nz = jyd.redMul(jz);\n        if (i + 1 < pow) jz4 = jz4.redMul(jyd4);\n        jx = nx;\n        jz = nz;\n        jyd = dny;\n    }\n    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\nJPoint.prototype.dbl = function dbl() {\n    if (this.isInfinity()) return this;\n    if (this.curve.zeroA) return this._zeroDbl();\n    else if (this.curve.threeA) return this._threeDbl();\n    else return this._dbl();\n};\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n    var nx;\n    var ny;\n    var nz;\n    // Z = 1\n    if (this.zOne) {\n        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n        //     #doubling-mdbl-2007-bl\n        // 1M + 5S + 14A\n        // XX = X1^2\n        var xx = this.x.redSqr();\n        // YY = Y1^2\n        var yy = this.y.redSqr();\n        // YYYY = YY^2\n        var yyyy = yy.redSqr();\n        // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n        s = s.redIAdd(s);\n        // M = 3 * XX + a; a = 0\n        var m = xx.redAdd(xx).redIAdd(xx);\n        // T = M ^ 2 - 2*S\n        var t = m.redSqr().redISub(s).redISub(s);\n        // 8 * YYYY\n        var yyyy8 = yyyy.redIAdd(yyyy);\n        yyyy8 = yyyy8.redIAdd(yyyy8);\n        yyyy8 = yyyy8.redIAdd(yyyy8);\n        // X3 = T\n        nx = t;\n        // Y3 = M * (S - T) - 8 * YYYY\n        ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n        // Z3 = 2*Y1\n        nz = this.y.redAdd(this.y);\n    } else {\n        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n        //     #doubling-dbl-2009-l\n        // 2M + 5S + 13A\n        // A = X1^2\n        var a = this.x.redSqr();\n        // B = Y1^2\n        var b = this.y.redSqr();\n        // C = B^2\n        var c = b.redSqr();\n        // D = 2 * ((X1 + B)^2 - A - C)\n        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n        d = d.redIAdd(d);\n        // E = 3 * A\n        var e = a.redAdd(a).redIAdd(a);\n        // F = E^2\n        var f = e.redSqr();\n        // 8 * C\n        var c8 = c.redIAdd(c);\n        c8 = c8.redIAdd(c8);\n        c8 = c8.redIAdd(c8);\n        // X3 = F - 2 * D\n        nx = f.redISub(d).redISub(d);\n        // Y3 = E * (D - X3) - 8 * C\n        ny = e.redMul(d.redISub(nx)).redISub(c8);\n        // Z3 = 2 * Y1 * Z1\n        nz = this.y.redMul(this.z);\n        nz = nz.redIAdd(nz);\n    }\n    return this.curve.jpoint(nx, ny, nz);\n};\nJPoint.prototype._threeDbl = function _threeDbl() {\n    var nx;\n    var ny;\n    var nz;\n    // Z = 1\n    if (this.zOne) {\n        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n        //     #doubling-mdbl-2007-bl\n        // 1M + 5S + 15A\n        // XX = X1^2\n        var xx = this.x.redSqr();\n        // YY = Y1^2\n        var yy = this.y.redSqr();\n        // YYYY = YY^2\n        var yyyy = yy.redSqr();\n        // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n        s = s.redIAdd(s);\n        // M = 3 * XX + a\n        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n        // T = M^2 - 2 * S\n        var t = m.redSqr().redISub(s).redISub(s);\n        // X3 = T\n        nx = t;\n        // Y3 = M * (S - T) - 8 * YYYY\n        var yyyy8 = yyyy.redIAdd(yyyy);\n        yyyy8 = yyyy8.redIAdd(yyyy8);\n        yyyy8 = yyyy8.redIAdd(yyyy8);\n        ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n        // Z3 = 2 * Y1\n        nz = this.y.redAdd(this.y);\n    } else {\n        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n        // 3M + 5S\n        // delta = Z1^2\n        var delta = this.z.redSqr();\n        // gamma = Y1^2\n        var gamma = this.y.redSqr();\n        // beta = X1 * gamma\n        var beta = this.x.redMul(gamma);\n        // alpha = 3 * (X1 - delta) * (X1 + delta)\n        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n        alpha = alpha.redAdd(alpha).redIAdd(alpha);\n        // X3 = alpha^2 - 8 * beta\n        var beta4 = beta.redIAdd(beta);\n        beta4 = beta4.redIAdd(beta4);\n        var beta8 = beta4.redAdd(beta4);\n        nx = alpha.redSqr().redISub(beta8);\n        // Z3 = (Y1 + Z1)^2 - gamma - delta\n        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n        // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n        var ggamma8 = gamma.redSqr();\n        ggamma8 = ggamma8.redIAdd(ggamma8);\n        ggamma8 = ggamma8.redIAdd(ggamma8);\n        ggamma8 = ggamma8.redIAdd(ggamma8);\n        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n    }\n    return this.curve.jpoint(nx, ny, nz);\n};\nJPoint.prototype._dbl = function _dbl() {\n    var a = this.curve.a;\n    // 4M + 6S + 10A\n    var jx = this.x;\n    var jy = this.y;\n    var jz = this.z;\n    var jz4 = jz.redSqr().redSqr();\n    var jx2 = jx.redSqr();\n    var jy2 = jy.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n    var jxd4 = jx.redAdd(jx);\n    jxd4 = jxd4.redIAdd(jxd4);\n    var t1 = jxd4.redMul(jy2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var jyd8 = jy2.redSqr();\n    jyd8 = jyd8.redIAdd(jyd8);\n    jyd8 = jyd8.redIAdd(jyd8);\n    jyd8 = jyd8.redIAdd(jyd8);\n    var ny = c.redMul(t2).redISub(jyd8);\n    var nz = jy.redAdd(jy).redMul(jz);\n    return this.curve.jpoint(nx, ny, nz);\n};\nJPoint.prototype.trpl = function trpl() {\n    if (!this.curve.zeroA) return this.dbl().add(this);\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n    // 5M + 10S + ...\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // ZZ = Z1^2\n    var zz = this.z.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // M = 3 * XX + a * ZZ2; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // MM = M^2\n    var mm = m.redSqr();\n    // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    e = e.redIAdd(e);\n    e = e.redAdd(e).redIAdd(e);\n    e = e.redISub(mm);\n    // EE = E^2\n    var ee = e.redSqr();\n    // T = 16*YYYY\n    var t = yyyy.redIAdd(yyyy);\n    t = t.redIAdd(t);\n    t = t.redIAdd(t);\n    t = t.redIAdd(t);\n    // U = (M + E)^2 - MM - EE - T\n    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n    // X3 = 4 * (X1 * EE - 4 * YY * U)\n    var yyu4 = yy.redMul(u);\n    yyu4 = yyu4.redIAdd(yyu4);\n    yyu4 = yyu4.redIAdd(yyu4);\n    var nx = this.x.redMul(ee).redISub(yyu4);\n    nx = nx.redIAdd(nx);\n    nx = nx.redIAdd(nx);\n    // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n    ny = ny.redIAdd(ny);\n    ny = ny.redIAdd(ny);\n    ny = ny.redIAdd(ny);\n    // Z3 = (Z1 + E)^2 - ZZ - EE\n    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n    return this.curve.jpoint(nx, ny, nz);\n};\nJPoint.prototype.mul = function mul(k, kbase) {\n    k = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(k, kbase);\n    return this.curve._wnafMul(this, k);\n};\nJPoint.prototype.eq = function eq(p) {\n    if (p.type === \"affine\") return this.eq(p.toJ());\n    if (this === p) return true;\n    // x1 * z2^2 == x2 * z1^2\n    var z2 = this.z.redSqr();\n    var pz2 = p.z.redSqr();\n    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false;\n    // y1 * z2^3 == y2 * z1^3\n    var z3 = z2.redMul(this.z);\n    var pz3 = pz2.redMul(p.z);\n    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\nJPoint.prototype.eqXToP = function eqXToP(x) {\n    var zs = this.z.redSqr();\n    var rx = x.toRed(this.curve.red).redMul(zs);\n    if (this.x.cmp(rx) === 0) return true;\n    var xc = x.clone();\n    var t = this.curve.redN.redMul(zs);\n    for(;;){\n        xc.iadd(this.curve.n);\n        if (xc.cmp(this.curve.p) >= 0) return false;\n        rx.redIAdd(t);\n        if (this.x.cmp(rx) === 0) return true;\n    }\n};\nJPoint.prototype.inspect = function inspect() {\n    if (this.isInfinity()) return \"<EC JPoint Infinity>\";\n    return \"<EC JPoint x: \" + this.x.toString(16, 2) + \" y: \" + this.y.toString(16, 2) + \" z: \" + this.z.toString(16, 2) + \">\";\n};\nJPoint.prototype.isInfinity = function isInfinity() {\n    // XXX This code assumes that zero is always zero in red\n    return this.z.cmpn(0) === 0;\n};\nvar curve_1 = createCommonjsModule(function(module, exports) {\n    \"use strict\";\n    var curve = exports;\n    curve.base = base;\n    curve.short = short_1;\n    curve.mont = /*RicMoo:ethers:require(./mont)*/ null;\n    curve.edwards = /*RicMoo:ethers:require(./edwards)*/ null;\n});\nvar curves_1 = createCommonjsModule(function(module, exports) {\n    \"use strict\";\n    var curves = exports;\n    var assert = utils_1$1.assert;\n    function PresetCurve(options) {\n        if (options.type === \"short\") this.curve = new curve_1.short(options);\n        else if (options.type === \"edwards\") this.curve = new curve_1.edwards(options);\n        else this.curve = new curve_1.mont(options);\n        this.g = this.curve.g;\n        this.n = this.curve.n;\n        this.hash = options.hash;\n        assert(this.g.validate(), \"Invalid curve\");\n        assert(this.g.mul(this.n).isInfinity(), \"Invalid curve, G*N != O\");\n    }\n    curves.PresetCurve = PresetCurve;\n    function defineCurve(name, options) {\n        Object.defineProperty(curves, name, {\n            configurable: true,\n            enumerable: true,\n            get: function() {\n                var curve = new PresetCurve(options);\n                Object.defineProperty(curves, name, {\n                    configurable: true,\n                    enumerable: true,\n                    value: curve\n                });\n                return curve;\n            }\n        });\n    }\n    defineCurve(\"p192\", {\n        type: \"short\",\n        prime: \"p192\",\n        p: \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\",\n        a: \"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc\",\n        b: \"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1\",\n        n: \"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831\",\n        hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n        gRed: false,\n        g: [\n            \"188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012\",\n            \"07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811\"\n        ]\n    });\n    defineCurve(\"p224\", {\n        type: \"short\",\n        prime: \"p224\",\n        p: \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\",\n        a: \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe\",\n        b: \"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4\",\n        n: \"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d\",\n        hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n        gRed: false,\n        g: [\n            \"b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21\",\n            \"bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34\"\n        ]\n    });\n    defineCurve(\"p256\", {\n        type: \"short\",\n        prime: null,\n        p: \"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff\",\n        a: \"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc\",\n        b: \"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b\",\n        n: \"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551\",\n        hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n        gRed: false,\n        g: [\n            \"6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296\",\n            \"4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5\"\n        ]\n    });\n    defineCurve(\"p384\", {\n        type: \"short\",\n        prime: null,\n        p: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \" + \"fffffffe ffffffff 00000000 00000000 ffffffff\",\n        a: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \" + \"fffffffe ffffffff 00000000 00000000 fffffffc\",\n        b: \"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f \" + \"5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef\",\n        n: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 \" + \"f4372ddf 581a0db2 48b0a77a ecec196a ccc52973\",\n        hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha384),\n        gRed: false,\n        g: [\n            \"aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 \" + \"5502f25d bf55296c 3a545e38 72760ab7\",\n            \"3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 \" + \"0a60b1ce 1d7e819d 7a431d7c 90ea0e5f\"\n        ]\n    });\n    defineCurve(\"p521\", {\n        type: \"short\",\n        prime: null,\n        p: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff \" + \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \" + \"ffffffff ffffffff ffffffff ffffffff ffffffff\",\n        a: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff \" + \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \" + \"ffffffff ffffffff ffffffff ffffffff fffffffc\",\n        b: \"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b \" + \"99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd \" + \"3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00\",\n        n: \"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff \" + \"ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 \" + \"f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409\",\n        hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha512),\n        gRed: false,\n        g: [\n            \"000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 \" + \"053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 \" + \"a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66\",\n            \"00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 \" + \"579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 \" + \"3fad0761 353c7086 a272c240 88be9476 9fd16650\"\n        ]\n    });\n    defineCurve(\"curve25519\", {\n        type: \"mont\",\n        prime: \"p25519\",\n        p: \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\",\n        a: \"76d06\",\n        b: \"1\",\n        n: \"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed\",\n        hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n        gRed: false,\n        g: [\n            \"9\"\n        ]\n    });\n    defineCurve(\"ed25519\", {\n        type: \"edwards\",\n        prime: \"p25519\",\n        p: \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\",\n        a: \"-1\",\n        c: \"1\",\n        // -121665 * (121666^(-1)) (mod P)\n        d: \"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3\",\n        n: \"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed\",\n        hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n        gRed: false,\n        g: [\n            \"216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a\",\n            // 4/5\n            \"6666666666666666666666666666666666666666666666666666666666666658\"\n        ]\n    });\n    var pre;\n    try {\n        pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/ null.crash();\n    } catch (e) {\n        pre = undefined;\n    }\n    defineCurve(\"secp256k1\", {\n        type: \"short\",\n        prime: \"k256\",\n        p: \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\",\n        a: \"0\",\n        b: \"7\",\n        n: \"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141\",\n        h: \"1\",\n        hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),\n        // Precomputed endomorphism\n        beta: \"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\",\n        lambda: \"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72\",\n        basis: [\n            {\n                a: \"3086d221a7d46bcde86c90e49284eb15\",\n                b: \"-e4437ed6010e88286f547fa90abfe4c3\"\n            },\n            {\n                a: \"114ca50f7a8e2f3f657c1108d9d44cfd8\",\n                b: \"3086d221a7d46bcde86c90e49284eb15\"\n            }\n        ],\n        gRed: false,\n        g: [\n            \"79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\",\n            \"483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n            pre\n        ]\n    });\n});\n\"use strict\";\nfunction HmacDRBG(options) {\n    if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);\n    this.hash = options.hash;\n    this.predResist = !!options.predResist;\n    this.outLen = this.hash.outSize;\n    this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n    this._reseed = null;\n    this.reseedInterval = null;\n    this.K = null;\n    this.V = null;\n    var entropy = utils_1.toArray(options.entropy, options.entropyEnc || \"hex\");\n    var nonce = utils_1.toArray(options.nonce, options.nonceEnc || \"hex\");\n    var pers = utils_1.toArray(options.pers, options.persEnc || \"hex\");\n    minimalisticAssert(entropy.length >= this.minEntropy / 8, \"Not enough entropy. Minimum is: \" + this.minEntropy + \" bits\");\n    this._init(entropy, nonce, pers);\n}\nvar hmacDrbg = HmacDRBG;\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n    var seed = entropy.concat(nonce).concat(pers);\n    this.K = new Array(this.outLen / 8);\n    this.V = new Array(this.outLen / 8);\n    for(var i = 0; i < this.V.length; i++){\n        this.K[i] = 0x00;\n        this.V[i] = 0x01;\n    }\n    this._update(seed);\n    this._reseed = 1;\n    this.reseedInterval = 0x1000000000000; // 2^48\n};\nHmacDRBG.prototype._hmac = function hmac() {\n    return new (hash_js__WEBPACK_IMPORTED_MODULE_1___default().hmac)(this.hash, this.K);\n};\nHmacDRBG.prototype._update = function update(seed) {\n    var kmac = this._hmac().update(this.V).update([\n        0x00\n    ]);\n    if (seed) kmac = kmac.update(seed);\n    this.K = kmac.digest();\n    this.V = this._hmac().update(this.V).digest();\n    if (!seed) return;\n    this.K = this._hmac().update(this.V).update([\n        0x01\n    ]).update(seed).digest();\n    this.V = this._hmac().update(this.V).digest();\n};\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n    // Optional entropy enc\n    if (typeof entropyEnc !== \"string\") {\n        addEnc = add;\n        add = entropyEnc;\n        entropyEnc = null;\n    }\n    entropy = utils_1.toArray(entropy, entropyEnc);\n    add = utils_1.toArray(add, addEnc);\n    minimalisticAssert(entropy.length >= this.minEntropy / 8, \"Not enough entropy. Minimum is: \" + this.minEntropy + \" bits\");\n    this._update(entropy.concat(add || []));\n    this._reseed = 1;\n};\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n    if (this._reseed > this.reseedInterval) throw new Error(\"Reseed is required\");\n    // Optional encoding\n    if (typeof enc !== \"string\") {\n        addEnc = add;\n        add = enc;\n        enc = null;\n    }\n    // Optional additional data\n    if (add) {\n        add = utils_1.toArray(add, addEnc || \"hex\");\n        this._update(add);\n    }\n    var temp = [];\n    while(temp.length < len){\n        this.V = this._hmac().update(this.V).digest();\n        temp = temp.concat(this.V);\n    }\n    var res = temp.slice(0, len);\n    this._update(add);\n    this._reseed++;\n    return utils_1.encode(res, enc);\n};\n\"use strict\";\nvar assert$3 = utils_1$1.assert;\nfunction KeyPair(ec, options) {\n    this.ec = ec;\n    this.priv = null;\n    this.pub = null;\n    // KeyPair(ec, { priv: ..., pub: ... })\n    if (options.priv) this._importPrivate(options.priv, options.privEnc);\n    if (options.pub) this._importPublic(options.pub, options.pubEnc);\n}\nvar key = KeyPair;\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n    if (pub instanceof KeyPair) return pub;\n    return new KeyPair(ec, {\n        pub: pub,\n        pubEnc: enc\n    });\n};\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n    if (priv instanceof KeyPair) return priv;\n    return new KeyPair(ec, {\n        priv: priv,\n        privEnc: enc\n    });\n};\nKeyPair.prototype.validate = function validate() {\n    var pub = this.getPublic();\n    if (pub.isInfinity()) return {\n        result: false,\n        reason: \"Invalid public key\"\n    };\n    if (!pub.validate()) return {\n        result: false,\n        reason: \"Public key is not a point\"\n    };\n    if (!pub.mul(this.ec.curve.n).isInfinity()) return {\n        result: false,\n        reason: \"Public key * N != O\"\n    };\n    return {\n        result: true,\n        reason: null\n    };\n};\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n    // compact is optional argument\n    if (typeof compact === \"string\") {\n        enc = compact;\n        compact = null;\n    }\n    if (!this.pub) this.pub = this.ec.g.mul(this.priv);\n    if (!enc) return this.pub;\n    return this.pub.encode(enc, compact);\n};\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n    if (enc === \"hex\") return this.priv.toString(16, 2);\n    else return this.priv;\n};\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n    this.priv = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(key, enc || 16);\n    // Ensure that the priv won't be bigger than n, otherwise we may fail\n    // in fixed multiplication method\n    this.priv = this.priv.umod(this.ec.curve.n);\n};\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n    if (key.x || key.y) {\n        // Montgomery points only have an `x` coordinate.\n        // Weierstrass/Edwards points on the other hand have both `x` and\n        // `y` coordinates.\n        if (this.ec.curve.type === \"mont\") {\n            assert$3(key.x, \"Need x coordinate\");\n        } else if (this.ec.curve.type === \"short\" || this.ec.curve.type === \"edwards\") {\n            assert$3(key.x && key.y, \"Need both x and y coordinate\");\n        }\n        this.pub = this.ec.curve.point(key.x, key.y);\n        return;\n    }\n    this.pub = this.ec.curve.decodePoint(key, enc);\n};\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n    if (!pub.validate()) {\n        assert$3(pub.validate(), \"public point not validated\");\n    }\n    return pub.mul(this.priv).getX();\n};\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n    return this.ec.sign(msg, this, enc, options);\n};\nKeyPair.prototype.verify = function verify(msg, signature) {\n    return this.ec.verify(msg, signature, this);\n};\nKeyPair.prototype.inspect = function inspect() {\n    return \"<Key priv: \" + (this.priv && this.priv.toString(16, 2)) + \" pub: \" + (this.pub && this.pub.inspect()) + \" >\";\n};\n\"use strict\";\nvar assert$4 = utils_1$1.assert;\nfunction Signature(options, enc) {\n    if (options instanceof Signature) return options;\n    if (this._importDER(options, enc)) return;\n    assert$4(options.r && options.s, \"Signature without r or s\");\n    this.r = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(options.r, 16);\n    this.s = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(options.s, 16);\n    if (options.recoveryParam === undefined) this.recoveryParam = null;\n    else this.recoveryParam = options.recoveryParam;\n}\nvar signature = Signature;\nfunction Position() {\n    this.place = 0;\n}\nfunction getLength(buf, p) {\n    var initial = buf[p.place++];\n    if (!(initial & 0x80)) {\n        return initial;\n    }\n    var octetLen = initial & 0xf;\n    // Indefinite length or overflow\n    if (octetLen === 0 || octetLen > 4) {\n        return false;\n    }\n    var val = 0;\n    for(var i = 0, off = p.place; i < octetLen; i++, off++){\n        val <<= 8;\n        val |= buf[off];\n        val >>>= 0;\n    }\n    // Leading zeroes\n    if (val <= 0x7f) {\n        return false;\n    }\n    p.place = off;\n    return val;\n}\nfunction rmPadding(buf) {\n    var i = 0;\n    var len = buf.length - 1;\n    while(!buf[i] && !(buf[i + 1] & 0x80) && i < len){\n        i++;\n    }\n    if (i === 0) {\n        return buf;\n    }\n    return buf.slice(i);\n}\nSignature.prototype._importDER = function _importDER(data, enc) {\n    data = utils_1$1.toArray(data, enc);\n    var p = new Position();\n    if (data[p.place++] !== 0x30) {\n        return false;\n    }\n    var len = getLength(data, p);\n    if (len === false) {\n        return false;\n    }\n    if (len + p.place !== data.length) {\n        return false;\n    }\n    if (data[p.place++] !== 0x02) {\n        return false;\n    }\n    var rlen = getLength(data, p);\n    if (rlen === false) {\n        return false;\n    }\n    var r = data.slice(p.place, rlen + p.place);\n    p.place += rlen;\n    if (data[p.place++] !== 0x02) {\n        return false;\n    }\n    var slen = getLength(data, p);\n    if (slen === false) {\n        return false;\n    }\n    if (data.length !== slen + p.place) {\n        return false;\n    }\n    var s = data.slice(p.place, slen + p.place);\n    if (r[0] === 0) {\n        if (r[1] & 0x80) {\n            r = r.slice(1);\n        } else {\n            // Leading zeroes\n            return false;\n        }\n    }\n    if (s[0] === 0) {\n        if (s[1] & 0x80) {\n            s = s.slice(1);\n        } else {\n            // Leading zeroes\n            return false;\n        }\n    }\n    this.r = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(r);\n    this.s = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(s);\n    this.recoveryParam = null;\n    return true;\n};\nfunction constructLength(arr, len) {\n    if (len < 0x80) {\n        arr.push(len);\n        return;\n    }\n    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n    arr.push(octets | 0x80);\n    while(--octets){\n        arr.push(len >>> (octets << 3) & 0xff);\n    }\n    arr.push(len);\n}\nSignature.prototype.toDER = function toDER(enc) {\n    var r = this.r.toArray();\n    var s = this.s.toArray();\n    // Pad values\n    if (r[0] & 0x80) r = [\n        0\n    ].concat(r);\n    // Pad values\n    if (s[0] & 0x80) s = [\n        0\n    ].concat(s);\n    r = rmPadding(r);\n    s = rmPadding(s);\n    while(!s[0] && !(s[1] & 0x80)){\n        s = s.slice(1);\n    }\n    var arr = [\n        0x02\n    ];\n    constructLength(arr, r.length);\n    arr = arr.concat(r);\n    arr.push(0x02);\n    constructLength(arr, s.length);\n    var backHalf = arr.concat(s);\n    var res = [\n        0x30\n    ];\n    constructLength(res, backHalf.length);\n    res = res.concat(backHalf);\n    return utils_1$1.encode(res, enc);\n};\n\"use strict\";\nvar rand = /*RicMoo:ethers:require(brorand)*/ function() {\n    throw new Error(\"unsupported\");\n};\nvar assert$5 = utils_1$1.assert;\nfunction EC(options) {\n    if (!(this instanceof EC)) return new EC(options);\n    // Shortcut `elliptic.ec(curve-name)`\n    if (typeof options === \"string\") {\n        assert$5(Object.prototype.hasOwnProperty.call(curves_1, options), \"Unknown curve \" + options);\n        options = curves_1[options];\n    }\n    // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n    if (options instanceof curves_1.PresetCurve) options = {\n        curve: options\n    };\n    this.curve = options.curve.curve;\n    this.n = this.curve.n;\n    this.nh = this.n.ushrn(1);\n    this.g = this.curve.g;\n    // Point on curve\n    this.g = options.curve.g;\n    this.g.precompute(options.curve.n.bitLength() + 1);\n    // Hash for function for DRBG\n    this.hash = options.hash || options.curve.hash;\n}\nvar ec = EC;\nEC.prototype.keyPair = function keyPair(options) {\n    return new key(this, options);\n};\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n    return key.fromPrivate(this, priv, enc);\n};\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n    return key.fromPublic(this, pub, enc);\n};\nEC.prototype.genKeyPair = function genKeyPair(options) {\n    if (!options) options = {};\n    // Instantiate Hmac_DRBG\n    var drbg = new hmacDrbg({\n        hash: this.hash,\n        pers: options.pers,\n        persEnc: options.persEnc || \"utf8\",\n        entropy: options.entropy || rand(this.hash.hmacStrength),\n        entropyEnc: options.entropy && options.entropyEnc || \"utf8\",\n        nonce: this.n.toArray()\n    });\n    var bytes = this.n.byteLength();\n    var ns2 = this.n.sub(new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(2));\n    for(;;){\n        var priv = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(drbg.generate(bytes));\n        if (priv.cmp(ns2) > 0) continue;\n        priv.iaddn(1);\n        return this.keyFromPrivate(priv);\n    }\n};\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n    var delta = msg.byteLength() * 8 - this.n.bitLength();\n    if (delta > 0) msg = msg.ushrn(delta);\n    if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);\n    else return msg;\n};\nEC.prototype.sign = function sign(msg, key, enc, options) {\n    if (typeof enc === \"object\") {\n        options = enc;\n        enc = null;\n    }\n    if (!options) options = {};\n    key = this.keyFromPrivate(key, enc);\n    msg = this._truncateToN(new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(msg, 16));\n    // Zero-extend key to provide enough entropy\n    var bytes = this.n.byteLength();\n    var bkey = key.getPrivate().toArray(\"be\", bytes);\n    // Zero-extend nonce to have the same byte size as N\n    var nonce = msg.toArray(\"be\", bytes);\n    // Instantiate Hmac_DRBG\n    var drbg = new hmacDrbg({\n        hash: this.hash,\n        entropy: bkey,\n        nonce: nonce,\n        pers: options.pers,\n        persEnc: options.persEnc || \"utf8\"\n    });\n    // Number of bytes to generate\n    var ns1 = this.n.sub(new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1));\n    for(var iter = 0;; iter++){\n        var k = options.k ? options.k(iter) : new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(drbg.generate(this.n.byteLength()));\n        k = this._truncateToN(k, true);\n        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;\n        var kp = this.g.mul(k);\n        if (kp.isInfinity()) continue;\n        var kpX = kp.getX();\n        var r = kpX.umod(this.n);\n        if (r.cmpn(0) === 0) continue;\n        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n        s = s.umod(this.n);\n        if (s.cmpn(0) === 0) continue;\n        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);\n        // Use complement of `s`, if it is > `n / 2`\n        if (options.canonical && s.cmp(this.nh) > 0) {\n            s = this.n.sub(s);\n            recoveryParam ^= 1;\n        }\n        return new signature({\n            r: r,\n            s: s,\n            recoveryParam: recoveryParam\n        });\n    }\n};\nEC.prototype.verify = function verify(msg, signature$1, key, enc) {\n    msg = this._truncateToN(new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(msg, 16));\n    key = this.keyFromPublic(key, enc);\n    signature$1 = new signature(signature$1, \"hex\");\n    // Perform primitive values validation\n    var r = signature$1.r;\n    var s = signature$1.s;\n    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;\n    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false;\n    // Validate signature\n    var sinv = s.invm(this.n);\n    var u1 = sinv.mul(msg).umod(this.n);\n    var u2 = sinv.mul(r).umod(this.n);\n    var p;\n    if (!this.curve._maxwellTrick) {\n        p = this.g.mulAdd(u1, key.getPublic(), u2);\n        if (p.isInfinity()) return false;\n        return p.getX().umod(this.n).cmp(r) === 0;\n    }\n    // NOTE: Greg Maxwell's trick, inspired by:\n    // https://git.io/vad3K\n    p = this.g.jmulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity()) return false;\n    // Compare `p.x` of Jacobian point with `r`,\n    // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n    // inverse of `p.z^2`\n    return p.eqXToP(r);\n};\nEC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {\n    assert$5((3 & j) === j, \"The recovery param is more than two bits\");\n    signature$1 = new signature(signature$1, enc);\n    var n = this.n;\n    var e = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(msg);\n    var r = signature$1.r;\n    var s = signature$1.s;\n    // A set LSB signifies that the y-coordinate is odd\n    var isYOdd = j & 1;\n    var isSecondKey = j >> 1;\n    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error(\"Unable to find sencond key candinate\");\n    // 1.1. Let x = r + jn.\n    if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n    else r = this.curve.pointFromX(r, isYOdd);\n    var rInv = signature$1.r.invm(n);\n    var s1 = n.sub(e).mul(rInv).umod(n);\n    var s2 = s.mul(rInv).umod(n);\n    // 1.6.1 Compute Q = r^-1 (sR -  eG)\n    //               Q = r^-1 (sR + -eG)\n    return this.g.mulAdd(s1, r, s2);\n};\nEC.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {\n    signature$1 = new signature(signature$1, enc);\n    if (signature$1.recoveryParam !== null) return signature$1.recoveryParam;\n    for(var i = 0; i < 4; i++){\n        var Qprime;\n        try {\n            Qprime = this.recoverPubKey(e, signature$1, i);\n        } catch (e) {\n            continue;\n        }\n        if (Qprime.eq(Q)) return i;\n    }\n    throw new Error(\"Unable to find valid recovery factor\");\n};\nvar elliptic_1 = createCommonjsModule(function(module, exports) {\n    \"use strict\";\n    var elliptic = exports;\n    elliptic.version = /*RicMoo:ethers*/ ({\n        version: \"6.5.4\"\n    }).version;\n    elliptic.utils = utils_1$1;\n    elliptic.rand = /*RicMoo:ethers:require(brorand)*/ function() {\n        throw new Error(\"unsupported\");\n    };\n    elliptic.curve = curve_1;\n    elliptic.curves = curves_1;\n    // Protocols\n    elliptic.ec = ec;\n    elliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/ null;\n});\nvar EC$1 = elliptic_1.ec;\n //# sourceMappingURL=elliptic.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2lnbmluZy1rZXkvbGliLmVzbS9lbGxpcHRpYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF1QjtBQUNJO0FBRTNCLElBQUlFLGlCQUFpQixPQUFPQyxlQUFlLGNBQWNBLGFBQWEsTUFBa0IsR0FBY0MsQ0FBTUEsR0FBRyxPQUFPQyxXQUFXLGNBQWNBLFNBQVMsT0FBT0MsU0FBUyxjQUFjQSxPQUFPLENBQUM7QUFFOUwsU0FBU0Msd0JBQXlCQyxDQUFDO0lBQ2xDLE9BQU9BLEtBQUtBLEVBQUVDLFVBQVUsSUFBSUMsT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0wsR0FBRyxhQUFhQSxDQUFDLENBQUMsVUFBVSxHQUFHQTtBQUNqRztBQUVBLFNBQVNNLHFCQUFxQkMsRUFBRSxFQUFFQyxPQUFPLEVBQUVDLE1BQU07SUFDaEQsT0FBT0EsU0FBUztRQUNmQyxNQUFNRjtRQUNORyxTQUFTLENBQUM7UUFDVkMsU0FBUyxTQUFVRixJQUFJLEVBQUVHLElBQUk7WUFDNUIsT0FBT0MsZ0JBQWdCSixNQUFNLFNBQVVLLGFBQWFGLFNBQVMsT0FBUUosT0FBT0MsSUFBSSxHQUFHRztRQUNwRjtJQUNELEdBQUdOLEdBQUdFLFFBQVFBLE9BQU9FLE9BQU8sR0FBR0YsT0FBT0UsT0FBTztBQUM5QztBQUVBLFNBQVNLLHVDQUF3Q0MsQ0FBQztJQUNqRCxPQUFPQSxLQUFLZixPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDWSxHQUFHLGFBQWFBLENBQUMsQ0FBQyxVQUFVLEdBQUdBO0FBQ2pGO0FBRUEsU0FBU0Msd0NBQXlDRCxDQUFDO0lBQ2xELE9BQU9BLEtBQUtmLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNZLEdBQUcsY0FBY2YsT0FBT2lCLElBQUksQ0FBQ0YsR0FBR0csTUFBTSxLQUFLLElBQUlILENBQUMsQ0FBQyxVQUFVLEdBQUdBO0FBQ2hI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QVk7SUFDWjhHLFNBQVNyRSxFQUFFLEdBQUdBO0lBQ2RxRSxTQUFTRSxLQUFLLEdBQUcseUNBQXlDLEdBQUc7QUFDN0Q7QUFFQSxJQUFJQyxPQUFPSixXQUFXcEUsRUFBRTtBQUVGLENBQ3RCLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2lnbmluZy1rZXkvbGliLmVzbS9lbGxpcHRpYy5qcz8yNTc2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBCTiBmcm9tICdibi5qcyc7XG5pbXBvcnQgaGFzaCBmcm9tICdoYXNoLmpzJztcblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBiYXNlZGlyLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHtcblx0XHRwYXRoOiBiYXNlZGlyLFxuXHRcdGV4cG9ydHM6IHt9LFxuXHRcdHJlcXVpcmU6IGZ1bmN0aW9uIChwYXRoLCBiYXNlKSB7XG5cdFx0XHRyZXR1cm4gY29tbW9uanNSZXF1aXJlKHBhdGgsIChiYXNlID09PSB1bmRlZmluZWQgfHwgYmFzZSA9PT0gbnVsbCkgPyBtb2R1bGUucGF0aCA6IGJhc2UpO1xuXHRcdH1cblx0fSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbU5hbWVzcGFjZUlmUHJlc2VudCAobikge1xuXHRyZXR1cm4gbiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgJ2RlZmF1bHQnKSA/IG5bJ2RlZmF1bHQnXSA6IG47XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tTmFtZXNwYWNlSWZOb3ROYW1lZCAobikge1xuXHRyZXR1cm4gbiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgJ2RlZmF1bHQnKSAmJiBPYmplY3Qua2V5cyhuKS5sZW5ndGggPT09IDEgPyBuWydkZWZhdWx0J10gOiBuO1xufVxuXG5mdW5jdGlvbiBnZXRBdWdtZW50ZWROYW1lc3BhY2Uobikge1xuXHRpZiAobi5fX2VzTW9kdWxlKSByZXR1cm4gbjtcblx0dmFyIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdfX2VzTW9kdWxlJywge3ZhbHVlOiB0cnVlfSk7XG5cdE9iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0XHR2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobiwgayk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIGssIGQuZ2V0ID8gZCA6IHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIG5ba107XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRyZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY29tbW9uanNSZXF1aXJlICgpIHtcblx0dGhyb3cgbmV3IEVycm9yKCdEeW5hbWljIHJlcXVpcmVzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSBAcm9sbHVwL3BsdWdpbi1jb21tb25qcycpO1xufVxuXG52YXIgbWluaW1hbGlzdGljQXNzZXJ0ID0gYXNzZXJ0O1xuXG5mdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcbiAgaWYgKCF2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xufVxuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBhc3NlcnRFcXVhbChsLCByLCBtc2cpIHtcbiAgaWYgKGwgIT0gcilcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICgnQXNzZXJ0aW9uIGZhaWxlZDogJyArIGwgKyAnICE9ICcgKyByKSk7XG59O1xuXG52YXIgdXRpbHNfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gZXhwb3J0cztcblxuZnVuY3Rpb24gdG9BcnJheShtc2csIGVuYykge1xuICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKVxuICAgIHJldHVybiBtc2cuc2xpY2UoKTtcbiAgaWYgKCFtc2cpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgcmVzID0gW107XG4gIGlmICh0eXBlb2YgbXNnICE9PSAnc3RyaW5nJykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgICAgcmVzW2ldID0gbXNnW2ldIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmIChlbmMgPT09ICdoZXgnKSB7XG4gICAgbXNnID0gbXNnLnJlcGxhY2UoL1teYS16MC05XSsvaWcsICcnKTtcbiAgICBpZiAobXNnLmxlbmd0aCAlIDIgIT09IDApXG4gICAgICBtc2cgPSAnMCcgKyBtc2c7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IDIpXG4gICAgICByZXMucHVzaChwYXJzZUludChtc2dbaV0gKyBtc2dbaSArIDFdLCAxNikpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgdmFyIGhpID0gYyA+PiA4O1xuICAgICAgdmFyIGxvID0gYyAmIDB4ZmY7XG4gICAgICBpZiAoaGkpXG4gICAgICAgIHJlcy5wdXNoKGhpLCBsbyk7XG4gICAgICBlbHNlXG4gICAgICAgIHJlcy5wdXNoKGxvKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvQXJyYXkgPSB0b0FycmF5O1xuXG5mdW5jdGlvbiB6ZXJvMih3b3JkKSB7XG4gIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgZWxzZVxuICAgIHJldHVybiB3b3JkO1xufVxudXRpbHMuemVybzIgPSB6ZXJvMjtcblxuZnVuY3Rpb24gdG9IZXgobXNnKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgcmVzICs9IHplcm8yKG1zZ1tpXS50b1N0cmluZygxNikpO1xuICByZXR1cm4gcmVzO1xufVxudXRpbHMudG9IZXggPSB0b0hleDtcblxudXRpbHMuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGFyciwgZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB0b0hleChhcnIpO1xuICBlbHNlXG4gICAgcmV0dXJuIGFycjtcbn07XG59KTtcblxudmFyIHV0aWxzXzEkMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gZXhwb3J0cztcblxuXG5cblxudXRpbHMuYXNzZXJ0ID0gbWluaW1hbGlzdGljQXNzZXJ0O1xudXRpbHMudG9BcnJheSA9IHV0aWxzXzEudG9BcnJheTtcbnV0aWxzLnplcm8yID0gdXRpbHNfMS56ZXJvMjtcbnV0aWxzLnRvSGV4ID0gdXRpbHNfMS50b0hleDtcbnV0aWxzLmVuY29kZSA9IHV0aWxzXzEuZW5jb2RlO1xuXG4vLyBSZXByZXNlbnQgbnVtIGluIGEgdy1OQUYgZm9ybVxuZnVuY3Rpb24gZ2V0TkFGKG51bSwgdywgYml0cykge1xuICB2YXIgbmFmID0gbmV3IEFycmF5KE1hdGgubWF4KG51bS5iaXRMZW5ndGgoKSwgYml0cykgKyAxKTtcbiAgbmFmLmZpbGwoMCk7XG5cbiAgdmFyIHdzID0gMSA8PCAodyArIDEpO1xuICB2YXIgayA9IG51bS5jbG9uZSgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmFmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHo7XG4gICAgdmFyIG1vZCA9IGsuYW5kbG4od3MgLSAxKTtcbiAgICBpZiAoay5pc09kZCgpKSB7XG4gICAgICBpZiAobW9kID4gKHdzID4+IDEpIC0gMSlcbiAgICAgICAgeiA9ICh3cyA+PiAxKSAtIG1vZDtcbiAgICAgIGVsc2VcbiAgICAgICAgeiA9IG1vZDtcbiAgICAgIGsuaXN1Ym4oeik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHogPSAwO1xuICAgIH1cblxuICAgIG5hZltpXSA9IHo7XG4gICAgay5pdXNocm4oMSk7XG4gIH1cblxuICByZXR1cm4gbmFmO1xufVxudXRpbHMuZ2V0TkFGID0gZ2V0TkFGO1xuXG4vLyBSZXByZXNlbnQgazEsIGsyIGluIGEgSm9pbnQgU3BhcnNlIEZvcm1cbmZ1bmN0aW9uIGdldEpTRihrMSwgazIpIHtcbiAgdmFyIGpzZiA9IFtcbiAgICBbXSxcbiAgICBbXSxcbiAgXTtcblxuICBrMSA9IGsxLmNsb25lKCk7XG4gIGsyID0gazIuY2xvbmUoKTtcbiAgdmFyIGQxID0gMDtcbiAgdmFyIGQyID0gMDtcbiAgdmFyIG04O1xuICB3aGlsZSAoazEuY21wbigtZDEpID4gMCB8fCBrMi5jbXBuKC1kMikgPiAwKSB7XG4gICAgLy8gRmlyc3QgcGhhc2VcbiAgICB2YXIgbTE0ID0gKGsxLmFuZGxuKDMpICsgZDEpICYgMztcbiAgICB2YXIgbTI0ID0gKGsyLmFuZGxuKDMpICsgZDIpICYgMztcbiAgICBpZiAobTE0ID09PSAzKVxuICAgICAgbTE0ID0gLTE7XG4gICAgaWYgKG0yNCA9PT0gMylcbiAgICAgIG0yNCA9IC0xO1xuICAgIHZhciB1MTtcbiAgICBpZiAoKG0xNCAmIDEpID09PSAwKSB7XG4gICAgICB1MSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG04ID0gKGsxLmFuZGxuKDcpICsgZDEpICYgNztcbiAgICAgIGlmICgobTggPT09IDMgfHwgbTggPT09IDUpICYmIG0yNCA9PT0gMilcbiAgICAgICAgdTEgPSAtbTE0O1xuICAgICAgZWxzZVxuICAgICAgICB1MSA9IG0xNDtcbiAgICB9XG4gICAganNmWzBdLnB1c2godTEpO1xuXG4gICAgdmFyIHUyO1xuICAgIGlmICgobTI0ICYgMSkgPT09IDApIHtcbiAgICAgIHUyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgbTggPSAoazIuYW5kbG4oNykgKyBkMikgJiA3O1xuICAgICAgaWYgKChtOCA9PT0gMyB8fCBtOCA9PT0gNSkgJiYgbTE0ID09PSAyKVxuICAgICAgICB1MiA9IC1tMjQ7XG4gICAgICBlbHNlXG4gICAgICAgIHUyID0gbTI0O1xuICAgIH1cbiAgICBqc2ZbMV0ucHVzaCh1Mik7XG5cbiAgICAvLyBTZWNvbmQgcGhhc2VcbiAgICBpZiAoMiAqIGQxID09PSB1MSArIDEpXG4gICAgICBkMSA9IDEgLSBkMTtcbiAgICBpZiAoMiAqIGQyID09PSB1MiArIDEpXG4gICAgICBkMiA9IDEgLSBkMjtcbiAgICBrMS5pdXNocm4oMSk7XG4gICAgazIuaXVzaHJuKDEpO1xuICB9XG5cbiAgcmV0dXJuIGpzZjtcbn1cbnV0aWxzLmdldEpTRiA9IGdldEpTRjtcblxuZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkob2JqLCBuYW1lLCBjb21wdXRlcikge1xuICB2YXIga2V5ID0gJ18nICsgbmFtZTtcbiAgb2JqLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIGNhY2hlZFByb3BlcnR5KCkge1xuICAgIHJldHVybiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCA/IHRoaXNba2V5XSA6XG4gICAgICB0aGlzW2tleV0gPSBjb21wdXRlci5jYWxsKHRoaXMpO1xuICB9O1xufVxudXRpbHMuY2FjaGVkUHJvcGVydHkgPSBjYWNoZWRQcm9wZXJ0eTtcblxuZnVuY3Rpb24gcGFyc2VCeXRlcyhieXRlcykge1xuICByZXR1cm4gdHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJyA/IHV0aWxzLnRvQXJyYXkoYnl0ZXMsICdoZXgnKSA6XG4gICAgYnl0ZXM7XG59XG51dGlscy5wYXJzZUJ5dGVzID0gcGFyc2VCeXRlcztcblxuZnVuY3Rpb24gaW50RnJvbUxFKGJ5dGVzKSB7XG4gIHJldHVybiBuZXcgQk4oYnl0ZXMsICdoZXgnLCAnbGUnKTtcbn1cbnV0aWxzLmludEZyb21MRSA9IGludEZyb21MRTtcbn0pO1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG52YXIgZ2V0TkFGID0gdXRpbHNfMSQxLmdldE5BRjtcbnZhciBnZXRKU0YgPSB1dGlsc18xJDEuZ2V0SlNGO1xudmFyIGFzc2VydCQxID0gdXRpbHNfMSQxLmFzc2VydDtcblxuZnVuY3Rpb24gQmFzZUN1cnZlKHR5cGUsIGNvbmYpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wID0gbmV3IEJOKGNvbmYucCwgMTYpO1xuXG4gIC8vIFVzZSBNb250Z29tZXJ5LCB3aGVuIHRoZXJlIGlzIG5vIGZhc3QgcmVkdWN0aW9uIGZvciB0aGUgcHJpbWVcbiAgdGhpcy5yZWQgPSBjb25mLnByaW1lID8gQk4ucmVkKGNvbmYucHJpbWUpIDogQk4ubW9udCh0aGlzLnApO1xuXG4gIC8vIFVzZWZ1bCBmb3IgbWFueSBjdXJ2ZXNcbiAgdGhpcy56ZXJvID0gbmV3IEJOKDApLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5vbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLnR3byA9IG5ldyBCTigyKS50b1JlZCh0aGlzLnJlZCk7XG5cbiAgLy8gQ3VydmUgY29uZmlndXJhdGlvbiwgb3B0aW9uYWxcbiAgdGhpcy5uID0gY29uZi5uICYmIG5ldyBCTihjb25mLm4sIDE2KTtcbiAgdGhpcy5nID0gY29uZi5nICYmIHRoaXMucG9pbnRGcm9tSlNPTihjb25mLmcsIGNvbmYuZ1JlZCk7XG5cbiAgLy8gVGVtcG9yYXJ5IGFycmF5c1xuICB0aGlzLl93bmFmVDEgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUMiA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQzID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDQgPSBuZXcgQXJyYXkoNCk7XG5cbiAgdGhpcy5fYml0TGVuZ3RoID0gdGhpcy5uID8gdGhpcy5uLmJpdExlbmd0aCgpIDogMDtcblxuICAvLyBHZW5lcmFsaXplZCBHcmVnIE1heHdlbGwncyB0cmlja1xuICB2YXIgYWRqdXN0Q291bnQgPSB0aGlzLm4gJiYgdGhpcy5wLmRpdih0aGlzLm4pO1xuICBpZiAoIWFkanVzdENvdW50IHx8IGFkanVzdENvdW50LmNtcG4oMTAwKSA+IDApIHtcbiAgICB0aGlzLnJlZE4gPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX21heHdlbGxUcmljayA9IHRydWU7XG4gICAgdGhpcy5yZWROID0gdGhpcy5uLnRvUmVkKHRoaXMucmVkKTtcbiAgfVxufVxudmFyIGJhc2UgPSBCYXNlQ3VydmU7XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX2ZpeGVkTmFmTXVsID0gZnVuY3Rpb24gX2ZpeGVkTmFmTXVsKHAsIGspIHtcbiAgYXNzZXJ0JDEocC5wcmVjb21wdXRlZCk7XG4gIHZhciBkb3VibGVzID0gcC5fZ2V0RG91YmxlcygpO1xuXG4gIHZhciBuYWYgPSBnZXROQUYoaywgMSwgdGhpcy5fYml0TGVuZ3RoKTtcbiAgdmFyIEkgPSAoMSA8PCAoZG91Ymxlcy5zdGVwICsgMSkpIC0gKGRvdWJsZXMuc3RlcCAlIDIgPT09IDAgPyAyIDogMSk7XG4gIEkgLz0gMztcblxuICAvLyBUcmFuc2xhdGUgaW50byBtb3JlIHdpbmRvd2VkIGZvcm1cbiAgdmFyIHJlcHIgPSBbXTtcbiAgdmFyIGo7XG4gIHZhciBuYWZXO1xuICBmb3IgKGogPSAwOyBqIDwgbmFmLmxlbmd0aDsgaiArPSBkb3VibGVzLnN0ZXApIHtcbiAgICBuYWZXID0gMDtcbiAgICBmb3IgKHZhciBsID0gaiArIGRvdWJsZXMuc3RlcCAtIDE7IGwgPj0gajsgbC0tKVxuICAgICAgbmFmVyA9IChuYWZXIDw8IDEpICsgbmFmW2xdO1xuICAgIHJlcHIucHVzaChuYWZXKTtcbiAgfVxuXG4gIHZhciBhID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIHZhciBiID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBJOyBpID4gMDsgaS0tKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IHJlcHIubGVuZ3RoOyBqKyspIHtcbiAgICAgIG5hZlcgPSByZXByW2pdO1xuICAgICAgaWYgKG5hZlcgPT09IGkpXG4gICAgICAgIGIgPSBiLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdKTtcbiAgICAgIGVsc2UgaWYgKG5hZlcgPT09IC1pKVxuICAgICAgICBiID0gYi5taXhlZEFkZChkb3VibGVzLnBvaW50c1tqXS5uZWcoKSk7XG4gICAgfVxuICAgIGEgPSBhLmFkZChiKTtcbiAgfVxuICByZXR1cm4gYS50b1AoKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX3duYWZNdWwgPSBmdW5jdGlvbiBfd25hZk11bChwLCBrKSB7XG4gIHZhciB3ID0gNDtcblxuICAvLyBQcmVjb21wdXRlIHdpbmRvd1xuICB2YXIgbmFmUG9pbnRzID0gcC5fZ2V0TkFGUG9pbnRzKHcpO1xuICB3ID0gbmFmUG9pbnRzLnduZDtcbiAgdmFyIHduZCA9IG5hZlBvaW50cy5wb2ludHM7XG5cbiAgLy8gR2V0IE5BRiBmb3JtXG4gIHZhciBuYWYgPSBnZXROQUYoaywgdywgdGhpcy5fYml0TGVuZ3RoKTtcblxuICAvLyBBZGQgYHRoaXNgKihOKzEpIGZvciBldmVyeSB3LU5BRiBpbmRleFxuICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBuYWYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAvLyBDb3VudCB6ZXJvZXNcbiAgICBmb3IgKHZhciBsID0gMDsgaSA+PSAwICYmIG5hZltpXSA9PT0gMDsgaS0tKVxuICAgICAgbCsrO1xuICAgIGlmIChpID49IDApXG4gICAgICBsKys7XG4gICAgYWNjID0gYWNjLmRibHAobCk7XG5cbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcbiAgICB2YXIgeiA9IG5hZltpXTtcbiAgICBhc3NlcnQkMSh6ICE9PSAwKTtcbiAgICBpZiAocC50eXBlID09PSAnYWZmaW5lJykge1xuICAgICAgLy8gSiArLSBQXG4gICAgICBpZiAoeiA+IDApXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKC16IC0gMSkgPj4gMV0ubmVnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBKICstIEpcbiAgICAgIGlmICh6ID4gMClcbiAgICAgICAgYWNjID0gYWNjLmFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5hZGQod25kWygteiAtIDEpID4+IDFdLm5lZygpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHAudHlwZSA9PT0gJ2FmZmluZScgPyBhY2MudG9QKCkgOiBhY2M7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsQWRkID0gZnVuY3Rpb24gX3duYWZNdWxBZGQoZGVmVyxcbiAgcG9pbnRzLFxuICBjb2VmZnMsXG4gIGxlbixcbiAgamFjb2JpYW5SZXN1bHQpIHtcbiAgdmFyIHduZFdpZHRoID0gdGhpcy5fd25hZlQxO1xuICB2YXIgd25kID0gdGhpcy5fd25hZlQyO1xuICB2YXIgbmFmID0gdGhpcy5fd25hZlQzO1xuXG4gIC8vIEZpbGwgYWxsIGFycmF5c1xuICB2YXIgbWF4ID0gMDtcbiAgdmFyIGk7XG4gIHZhciBqO1xuICB2YXIgcDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcCA9IHBvaW50c1tpXTtcbiAgICB2YXIgbmFmUG9pbnRzID0gcC5fZ2V0TkFGUG9pbnRzKGRlZlcpO1xuICAgIHduZFdpZHRoW2ldID0gbmFmUG9pbnRzLnduZDtcbiAgICB3bmRbaV0gPSBuYWZQb2ludHMucG9pbnRzO1xuICB9XG5cbiAgLy8gQ29tYiBzbWFsbCB3aW5kb3cgTkFGc1xuICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDE7IGkgLT0gMikge1xuICAgIHZhciBhID0gaSAtIDE7XG4gICAgdmFyIGIgPSBpO1xuICAgIGlmICh3bmRXaWR0aFthXSAhPT0gMSB8fCB3bmRXaWR0aFtiXSAhPT0gMSkge1xuICAgICAgbmFmW2FdID0gZ2V0TkFGKGNvZWZmc1thXSwgd25kV2lkdGhbYV0sIHRoaXMuX2JpdExlbmd0aCk7XG4gICAgICBuYWZbYl0gPSBnZXROQUYoY29lZmZzW2JdLCB3bmRXaWR0aFtiXSwgdGhpcy5fYml0TGVuZ3RoKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG5hZlthXS5sZW5ndGgsIG1heCk7XG4gICAgICBtYXggPSBNYXRoLm1heChuYWZbYl0ubGVuZ3RoLCBtYXgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGNvbWIgPSBbXG4gICAgICBwb2ludHNbYV0sIC8qIDEgKi9cbiAgICAgIG51bGwsIC8qIDMgKi9cbiAgICAgIG51bGwsIC8qIDUgKi9cbiAgICAgIHBvaW50c1tiXSwgLyogNyAqL1xuICAgIF07XG5cbiAgICAvLyBUcnkgdG8gYXZvaWQgUHJvamVjdGl2ZSBwb2ludHMsIGlmIHBvc3NpYmxlXG4gICAgaWYgKHBvaW50c1thXS55LmNtcChwb2ludHNbYl0ueSkgPT09IDApIHtcbiAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0uYWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfSBlbHNlIGlmIChwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkucmVkTmVnKCkpID09PSAwKSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gW1xuICAgICAgLTMsIC8qIC0xIC0xICovXG4gICAgICAtMSwgLyogLTEgMCAqL1xuICAgICAgLTUsIC8qIC0xIDEgKi9cbiAgICAgIC03LCAvKiAwIC0xICovXG4gICAgICAwLCAvKiAwIDAgKi9cbiAgICAgIDcsIC8qIDAgMSAqL1xuICAgICAgNSwgLyogMSAtMSAqL1xuICAgICAgMSwgLyogMSAwICovXG4gICAgICAzLCAgLyogMSAxICovXG4gICAgXTtcblxuICAgIHZhciBqc2YgPSBnZXRKU0YoY29lZmZzW2FdLCBjb2VmZnNbYl0pO1xuICAgIG1heCA9IE1hdGgubWF4KGpzZlswXS5sZW5ndGgsIG1heCk7XG4gICAgbmFmW2FdID0gbmV3IEFycmF5KG1heCk7XG4gICAgbmFmW2JdID0gbmV3IEFycmF5KG1heCk7XG4gICAgZm9yIChqID0gMDsgaiA8IG1heDsgaisrKSB7XG4gICAgICB2YXIgamEgPSBqc2ZbMF1bal0gfCAwO1xuICAgICAgdmFyIGpiID0ganNmWzFdW2pdIHwgMDtcblxuICAgICAgbmFmW2FdW2pdID0gaW5kZXhbKGphICsgMSkgKiAzICsgKGpiICsgMSldO1xuICAgICAgbmFmW2JdW2pdID0gMDtcbiAgICAgIHduZFthXSA9IGNvbWI7XG4gICAgfVxuICB9XG5cbiAgdmFyIGFjYyA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICB2YXIgdG1wID0gdGhpcy5fd25hZlQ0O1xuICBmb3IgKGkgPSBtYXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGsgPSAwO1xuXG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgdmFyIHplcm8gPSB0cnVlO1xuICAgICAgZm9yIChqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIHRtcFtqXSA9IG5hZltqXVtpXSB8IDA7XG4gICAgICAgIGlmICh0bXBbal0gIT09IDApXG4gICAgICAgICAgemVybyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF6ZXJvKVxuICAgICAgICBicmVhaztcbiAgICAgIGsrKztcbiAgICAgIGktLTtcbiAgICB9XG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGsrKztcbiAgICBhY2MgPSBhY2MuZGJscChrKTtcbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcblxuICAgIGZvciAoaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgdmFyIHogPSB0bXBbal07XG4gICAgICBwO1xuICAgICAgaWYgKHogPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgZWxzZSBpZiAoeiA+IDApXG4gICAgICAgIHAgPSB3bmRbal1bKHogLSAxKSA+PiAxXTtcbiAgICAgIGVsc2UgaWYgKHogPCAwKVxuICAgICAgICBwID0gd25kW2pdWygteiAtIDEpID4+IDFdLm5lZygpO1xuXG4gICAgICBpZiAocC50eXBlID09PSAnYWZmaW5lJylcbiAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHApO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHApO1xuICAgIH1cbiAgfVxuICAvLyBaZXJvaWZ5IHJlZmVyZW5jZXNcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgIHduZFtpXSA9IG51bGw7XG5cbiAgaWYgKGphY29iaWFuUmVzdWx0KVxuICAgIHJldHVybiBhY2M7XG4gIGVsc2VcbiAgICByZXR1cm4gYWNjLnRvUCgpO1xufTtcblxuZnVuY3Rpb24gQmFzZVBvaW50KGN1cnZlLCB0eXBlKSB7XG4gIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wcmVjb21wdXRlZCA9IG51bGw7XG59XG5CYXNlQ3VydmUuQmFzZVBvaW50ID0gQmFzZVBvaW50O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEoLypvdGhlciovKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLnZhbGlkYXRlKHRoaXMpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzLCBlbmMpIHtcbiAgYnl0ZXMgPSB1dGlsc18xJDEudG9BcnJheShieXRlcywgZW5jKTtcblxuICB2YXIgbGVuID0gdGhpcy5wLmJ5dGVMZW5ndGgoKTtcblxuICAvLyB1bmNvbXByZXNzZWQsIGh5YnJpZC1vZGQsIGh5YnJpZC1ldmVuXG4gIGlmICgoYnl0ZXNbMF0gPT09IDB4MDQgfHwgYnl0ZXNbMF0gPT09IDB4MDYgfHwgYnl0ZXNbMF0gPT09IDB4MDcpICYmXG4gICAgICBieXRlcy5sZW5ndGggLSAxID09PSAyICogbGVuKSB7XG4gICAgaWYgKGJ5dGVzWzBdID09PSAweDA2KVxuICAgICAgYXNzZXJ0JDEoYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gJSAyID09PSAwKTtcbiAgICBlbHNlIGlmIChieXRlc1swXSA9PT0gMHgwNylcbiAgICAgIGFzc2VydCQxKGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdICUgMiA9PT0gMSk7XG5cbiAgICB2YXIgcmVzID0gIHRoaXMucG9pbnQoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksXG4gICAgICBieXRlcy5zbGljZSgxICsgbGVuLCAxICsgMiAqIGxlbikpO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmICgoYnl0ZXNbMF0gPT09IDB4MDIgfHwgYnl0ZXNbMF0gPT09IDB4MDMpICYmXG4gICAgICAgICAgICAgIGJ5dGVzLmxlbmd0aCAtIDEgPT09IGxlbikge1xuICAgIHJldHVybiB0aGlzLnBvaW50RnJvbVgoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksIGJ5dGVzWzBdID09PSAweDAzKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcG9pbnQgZm9ybWF0Jyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZUNvbXByZXNzZWQgPSBmdW5jdGlvbiBlbmNvZGVDb21wcmVzc2VkKGVuYykge1xuICByZXR1cm4gdGhpcy5lbmNvZGUoZW5jLCB0cnVlKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIF9lbmNvZGUoY29tcGFjdCkge1xuICB2YXIgbGVuID0gdGhpcy5jdXJ2ZS5wLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIHggPSB0aGlzLmdldFgoKS50b0FycmF5KCdiZScsIGxlbik7XG5cbiAgaWYgKGNvbXBhY3QpXG4gICAgcmV0dXJuIFsgdGhpcy5nZXRZKCkuaXNFdmVuKCkgPyAweDAyIDogMHgwMyBdLmNvbmNhdCh4KTtcblxuICByZXR1cm4gWyAweDA0IF0uY29uY2F0KHgsIHRoaXMuZ2V0WSgpLnRvQXJyYXkoJ2JlJywgbGVuKSk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShlbmMsIGNvbXBhY3QpIHtcbiAgcmV0dXJuIHV0aWxzXzEkMS5lbmNvZGUodGhpcy5fZW5jb2RlKGNvbXBhY3QpLCBlbmMpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5wcmVjb21wdXRlID0gZnVuY3Rpb24gcHJlY29tcHV0ZShwb3dlcikge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gdGhpcztcblxuICB2YXIgcHJlY29tcHV0ZWQgPSB7XG4gICAgZG91YmxlczogbnVsbCxcbiAgICBuYWY6IG51bGwsXG4gICAgYmV0YTogbnVsbCxcbiAgfTtcbiAgcHJlY29tcHV0ZWQubmFmID0gdGhpcy5fZ2V0TkFGUG9pbnRzKDgpO1xuICBwcmVjb21wdXRlZC5kb3VibGVzID0gdGhpcy5fZ2V0RG91Ymxlcyg0LCBwb3dlcik7XG4gIHByZWNvbXB1dGVkLmJldGEgPSB0aGlzLl9nZXRCZXRhKCk7XG4gIHRoaXMucHJlY29tcHV0ZWQgPSBwcmVjb21wdXRlZDtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2hhc0RvdWJsZXMgPSBmdW5jdGlvbiBfaGFzRG91YmxlcyhrKSB7XG4gIGlmICghdGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRvdWJsZXMgPSB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG4gIGlmICghZG91YmxlcylcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIGRvdWJsZXMucG9pbnRzLmxlbmd0aCA+PSBNYXRoLmNlaWwoKGsuYml0TGVuZ3RoKCkgKyAxKSAvIGRvdWJsZXMuc3RlcCk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXREb3VibGVzID0gZnVuY3Rpb24gX2dldERvdWJsZXMoc3RlcCwgcG93ZXIpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzKVxuICAgIHJldHVybiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG5cbiAgdmFyIGRvdWJsZXMgPSBbIHRoaXMgXTtcbiAgdmFyIGFjYyA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG93ZXI7IGkgKz0gc3RlcCkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RlcDsgaisrKVxuICAgICAgYWNjID0gYWNjLmRibCgpO1xuICAgIGRvdWJsZXMucHVzaChhY2MpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RlcDogc3RlcCxcbiAgICBwb2ludHM6IGRvdWJsZXMsXG4gIH07XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXROQUZQb2ludHMgPSBmdW5jdGlvbiBfZ2V0TkFGUG9pbnRzKHduZCkge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLm5hZilcbiAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5uYWY7XG5cbiAgdmFyIHJlcyA9IFsgdGhpcyBdO1xuICB2YXIgbWF4ID0gKDEgPDwgd25kKSAtIDE7XG4gIHZhciBkYmwgPSBtYXggPT09IDEgPyBudWxsIDogdGhpcy5kYmwoKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBtYXg7IGkrKylcbiAgICByZXNbaV0gPSByZXNbaSAtIDFdLmFkZChkYmwpO1xuICByZXR1cm4ge1xuICAgIHduZDogd25kLFxuICAgIHBvaW50czogcmVzLFxuICB9O1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uIF9nZXRCZXRhKCkge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZGJscCA9IGZ1bmN0aW9uIGRibHAoaykge1xuICB2YXIgciA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgazsgaSsrKVxuICAgIHIgPSByLmRibCgpO1xuICByZXR1cm4gcjtcbn07XG5cbnZhciBpbmhlcml0c19icm93c2VyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgICB9XG4gIH07XG59XG59KTtcblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cblxudmFyIGFzc2VydCQyID0gdXRpbHNfMSQxLmFzc2VydDtcblxuZnVuY3Rpb24gU2hvcnRDdXJ2ZShjb25mKSB7XG4gIGJhc2UuY2FsbCh0aGlzLCAnc2hvcnQnLCBjb25mKTtcblxuICB0aGlzLmEgPSBuZXcgQk4oY29uZi5hLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmIgPSBuZXcgQk4oY29uZi5iLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLnRpbnYgPSB0aGlzLnR3by5yZWRJbnZtKCk7XG5cbiAgdGhpcy56ZXJvQSA9IHRoaXMuYS5mcm9tUmVkKCkuY21wbigwKSA9PT0gMDtcbiAgdGhpcy50aHJlZUEgPSB0aGlzLmEuZnJvbVJlZCgpLnN1Yih0aGlzLnApLmNtcG4oLTMpID09PSAwO1xuXG4gIC8vIElmIHRoZSBjdXJ2ZSBpcyBlbmRvbW9ycGhpYywgcHJlY2FsY3VsYXRlIGJldGEgYW5kIGxhbWJkYVxuICB0aGlzLmVuZG8gPSB0aGlzLl9nZXRFbmRvbW9ycGhpc20oY29uZik7XG4gIHRoaXMuX2VuZG9XbmFmVDEgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX2VuZG9XbmFmVDIgPSBuZXcgQXJyYXkoNCk7XG59XG5pbmhlcml0c19icm93c2VyKFNob3J0Q3VydmUsIGJhc2UpO1xudmFyIHNob3J0XzEgPSBTaG9ydEN1cnZlO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb21vcnBoaXNtID0gZnVuY3Rpb24gX2dldEVuZG9tb3JwaGlzbShjb25mKSB7XG4gIC8vIE5vIGVmZmljaWVudCBlbmRvbW9ycGhpc21cbiAgaWYgKCF0aGlzLnplcm9BIHx8ICF0aGlzLmcgfHwgIXRoaXMubiB8fCB0aGlzLnAubW9kbigzKSAhPT0gMSlcbiAgICByZXR1cm47XG5cbiAgLy8gQ29tcHV0ZSBiZXRhIGFuZCBsYW1iZGEsIHRoYXQgbGFtYmRhICogUCA9IChiZXRhICogUHg7IFB5KVxuICB2YXIgYmV0YTtcbiAgdmFyIGxhbWJkYTtcbiAgaWYgKGNvbmYuYmV0YSkge1xuICAgIGJldGEgPSBuZXcgQk4oY29uZi5iZXRhLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBiZXRhcyA9IHRoaXMuX2dldEVuZG9Sb290cyh0aGlzLnApO1xuICAgIC8vIENob29zZSB0aGUgc21hbGxlc3QgYmV0YVxuICAgIGJldGEgPSBiZXRhc1swXS5jbXAoYmV0YXNbMV0pIDwgMCA/IGJldGFzWzBdIDogYmV0YXNbMV07XG4gICAgYmV0YSA9IGJldGEudG9SZWQodGhpcy5yZWQpO1xuICB9XG4gIGlmIChjb25mLmxhbWJkYSkge1xuICAgIGxhbWJkYSA9IG5ldyBCTihjb25mLmxhbWJkYSwgMTYpO1xuICB9IGVsc2Uge1xuICAgIC8vIENob29zZSB0aGUgbGFtYmRhIHRoYXQgaXMgbWF0Y2hpbmcgc2VsZWN0ZWQgYmV0YVxuICAgIHZhciBsYW1iZGFzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMubik7XG4gICAgaWYgKHRoaXMuZy5tdWwobGFtYmRhc1swXSkueC5jbXAodGhpcy5nLngucmVkTXVsKGJldGEpKSA9PT0gMCkge1xuICAgICAgbGFtYmRhID0gbGFtYmRhc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFtYmRhID0gbGFtYmRhc1sxXTtcbiAgICAgIGFzc2VydCQyKHRoaXMuZy5tdWwobGFtYmRhKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKTtcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgYmFzaXMgdmVjdG9ycywgdXNlZCBmb3IgYmFsYW5jZWQgbGVuZ3RoLXR3byByZXByZXNlbnRhdGlvblxuICB2YXIgYmFzaXM7XG4gIGlmIChjb25mLmJhc2lzKSB7XG4gICAgYmFzaXMgPSBjb25mLmJhc2lzLm1hcChmdW5jdGlvbih2ZWMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGE6IG5ldyBCTih2ZWMuYSwgMTYpLFxuICAgICAgICBiOiBuZXcgQk4odmVjLmIsIDE2KSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYmFzaXMgPSB0aGlzLl9nZXRFbmRvQmFzaXMobGFtYmRhKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmV0YTogYmV0YSxcbiAgICBsYW1iZGE6IGxhbWJkYSxcbiAgICBiYXNpczogYmFzaXMsXG4gIH07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb1Jvb3RzID0gZnVuY3Rpb24gX2dldEVuZG9Sb290cyhudW0pIHtcbiAgLy8gRmluZCByb290cyBvZiBmb3IgeF4yICsgeCArIDEgaW4gRlxuICAvLyBSb290ID0gKC0xICstIFNxcnQoLTMpKSAvIDJcbiAgLy9cbiAgdmFyIHJlZCA9IG51bSA9PT0gdGhpcy5wID8gdGhpcy5yZWQgOiBCTi5tb250KG51bSk7XG4gIHZhciB0aW52ID0gbmV3IEJOKDIpLnRvUmVkKHJlZCkucmVkSW52bSgpO1xuICB2YXIgbnRpbnYgPSB0aW52LnJlZE5lZygpO1xuXG4gIHZhciBzID0gbmV3IEJOKDMpLnRvUmVkKHJlZCkucmVkTmVnKCkucmVkU3FydCgpLnJlZE11bCh0aW52KTtcblxuICB2YXIgbDEgPSBudGludi5yZWRBZGQocykuZnJvbVJlZCgpO1xuICB2YXIgbDIgPSBudGludi5yZWRTdWIocykuZnJvbVJlZCgpO1xuICByZXR1cm4gWyBsMSwgbDIgXTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvQmFzaXMgPSBmdW5jdGlvbiBfZ2V0RW5kb0Jhc2lzKGxhbWJkYSkge1xuICAvLyBhcHJ4U3FydCA+PSBzcXJ0KHRoaXMubilcbiAgdmFyIGFwcnhTcXJ0ID0gdGhpcy5uLnVzaHJuKE1hdGguZmxvb3IodGhpcy5uLmJpdExlbmd0aCgpIC8gMikpO1xuXG4gIC8vIDMuNzRcbiAgLy8gUnVuIEVHQ0QsIHVudGlsIHIoTCArIDEpIDwgYXByeFNxcnRcbiAgdmFyIHUgPSBsYW1iZGE7XG4gIHZhciB2ID0gdGhpcy5uLmNsb25lKCk7XG4gIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgdmFyIHkxID0gbmV3IEJOKDApO1xuICB2YXIgeDIgPSBuZXcgQk4oMCk7XG4gIHZhciB5MiA9IG5ldyBCTigxKTtcblxuICAvLyBOT1RFOiBhbGwgdmVjdG9ycyBhcmUgcm9vdHMgb2Y6IGEgKyBiICogbGFtYmRhID0gMCAobW9kIG4pXG4gIHZhciBhMDtcbiAgdmFyIGIwO1xuICAvLyBGaXJzdCB2ZWN0b3JcbiAgdmFyIGExO1xuICB2YXIgYjE7XG4gIC8vIFNlY29uZCB2ZWN0b3JcbiAgdmFyIGEyO1xuICB2YXIgYjI7XG5cbiAgdmFyIHByZXZSO1xuICB2YXIgaSA9IDA7XG4gIHZhciByO1xuICB2YXIgeDtcbiAgd2hpbGUgKHUuY21wbigwKSAhPT0gMCkge1xuICAgIHZhciBxID0gdi5kaXYodSk7XG4gICAgciA9IHYuc3ViKHEubXVsKHUpKTtcbiAgICB4ID0geDIuc3ViKHEubXVsKHgxKSk7XG4gICAgdmFyIHkgPSB5Mi5zdWIocS5tdWwoeTEpKTtcblxuICAgIGlmICghYTEgJiYgci5jbXAoYXByeFNxcnQpIDwgMCkge1xuICAgICAgYTAgPSBwcmV2Ui5uZWcoKTtcbiAgICAgIGIwID0geDE7XG4gICAgICBhMSA9IHIubmVnKCk7XG4gICAgICBiMSA9IHg7XG4gICAgfSBlbHNlIGlmIChhMSAmJiArK2kgPT09IDIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2UiA9IHI7XG5cbiAgICB2ID0gdTtcbiAgICB1ID0gcjtcbiAgICB4MiA9IHgxO1xuICAgIHgxID0geDtcbiAgICB5MiA9IHkxO1xuICAgIHkxID0geTtcbiAgfVxuICBhMiA9IHIubmVnKCk7XG4gIGIyID0geDtcblxuICB2YXIgbGVuMSA9IGExLnNxcigpLmFkZChiMS5zcXIoKSk7XG4gIHZhciBsZW4yID0gYTIuc3FyKCkuYWRkKGIyLnNxcigpKTtcbiAgaWYgKGxlbjIuY21wKGxlbjEpID49IDApIHtcbiAgICBhMiA9IGEwO1xuICAgIGIyID0gYjA7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgc2lnbnNcbiAgaWYgKGExLm5lZ2F0aXZlKSB7XG4gICAgYTEgPSBhMS5uZWcoKTtcbiAgICBiMSA9IGIxLm5lZygpO1xuICB9XG4gIGlmIChhMi5uZWdhdGl2ZSkge1xuICAgIGEyID0gYTIubmVnKCk7XG4gICAgYjIgPSBiMi5uZWcoKTtcbiAgfVxuXG4gIHJldHVybiBbXG4gICAgeyBhOiBhMSwgYjogYjEgfSxcbiAgICB7IGE6IGEyLCBiOiBiMiB9LFxuICBdO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9TcGxpdCA9IGZ1bmN0aW9uIF9lbmRvU3BsaXQoaykge1xuICB2YXIgYmFzaXMgPSB0aGlzLmVuZG8uYmFzaXM7XG4gIHZhciB2MSA9IGJhc2lzWzBdO1xuICB2YXIgdjIgPSBiYXNpc1sxXTtcblxuICB2YXIgYzEgPSB2Mi5iLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuICB2YXIgYzIgPSB2MS5iLm5lZygpLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuXG4gIHZhciBwMSA9IGMxLm11bCh2MS5hKTtcbiAgdmFyIHAyID0gYzIubXVsKHYyLmEpO1xuICB2YXIgcTEgPSBjMS5tdWwodjEuYik7XG4gIHZhciBxMiA9IGMyLm11bCh2Mi5iKTtcblxuICAvLyBDYWxjdWxhdGUgYW5zd2VyXG4gIHZhciBrMSA9IGsuc3ViKHAxKS5zdWIocDIpO1xuICB2YXIgazIgPSBxMS5hZGQocTIpLm5lZygpO1xuICByZXR1cm4geyBrMTogazEsIGsyOiBrMiB9O1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uIHBvaW50RnJvbVgoeCwgb2RkKSB7XG4gIHggPSBuZXcgQk4oeCwgMTYpO1xuICBpZiAoIXgucmVkKVxuICAgIHggPSB4LnRvUmVkKHRoaXMucmVkKTtcblxuICB2YXIgeTIgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKHgucmVkTXVsKHRoaXMuYSkpLnJlZElBZGQodGhpcy5iKTtcbiAgdmFyIHkgPSB5Mi5yZWRTcXJ0KCk7XG4gIGlmICh5LnJlZFNxcigpLnJlZFN1Yih5MikuY21wKHRoaXMuemVybykgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG5cbiAgLy8gWFhYIElzIHRoZXJlIGFueSB3YXkgdG8gdGVsbCBpZiB0aGUgbnVtYmVyIGlzIG9kZCB3aXRob3V0IGNvbnZlcnRpbmcgaXRcbiAgLy8gdG8gbm9uLXJlZCBmb3JtP1xuICB2YXIgaXNPZGQgPSB5LmZyb21SZWQoKS5pc09kZCgpO1xuICBpZiAob2RkICYmICFpc09kZCB8fCAhb2RkICYmIGlzT2RkKVxuICAgIHkgPSB5LnJlZE5lZygpO1xuXG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICBpZiAocG9pbnQuaW5mKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHZhciB4ID0gcG9pbnQueDtcbiAgdmFyIHkgPSBwb2ludC55O1xuXG4gIHZhciBheCA9IHRoaXMuYS5yZWRNdWwoeCk7XG4gIHZhciByaHMgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKGF4KS5yZWRJQWRkKHRoaXMuYik7XG4gIHJldHVybiB5LnJlZFNxcigpLnJlZElTdWIocmhzKS5jbXBuKDApID09PSAwO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9XbmFmTXVsQWRkID1cbiAgICBmdW5jdGlvbiBfZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIGphY29iaWFuUmVzdWx0KSB7XG4gICAgICB2YXIgbnBvaW50cyA9IHRoaXMuX2VuZG9XbmFmVDE7XG4gICAgICB2YXIgbmNvZWZmcyA9IHRoaXMuX2VuZG9XbmFmVDI7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3BsaXQgPSB0aGlzLl9lbmRvU3BsaXQoY29lZmZzW2ldKTtcbiAgICAgICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgICAgIHZhciBiZXRhID0gcC5fZ2V0QmV0YSgpO1xuXG4gICAgICAgIGlmIChzcGxpdC5rMS5uZWdhdGl2ZSkge1xuICAgICAgICAgIHNwbGl0LmsxLmluZWcoKTtcbiAgICAgICAgICBwID0gcC5uZWcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwbGl0LmsyLm5lZ2F0aXZlKSB7XG4gICAgICAgICAgc3BsaXQuazIuaW5lZygpO1xuICAgICAgICAgIGJldGEgPSBiZXRhLm5lZyh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5wb2ludHNbaSAqIDJdID0gcDtcbiAgICAgICAgbnBvaW50c1tpICogMiArIDFdID0gYmV0YTtcbiAgICAgICAgbmNvZWZmc1tpICogMl0gPSBzcGxpdC5rMTtcbiAgICAgICAgbmNvZWZmc1tpICogMiArIDFdID0gc3BsaXQuazI7XG4gICAgICB9XG4gICAgICB2YXIgcmVzID0gdGhpcy5fd25hZk11bEFkZCgxLCBucG9pbnRzLCBuY29lZmZzLCBpICogMiwgamFjb2JpYW5SZXN1bHQpO1xuXG4gICAgICAvLyBDbGVhbi11cCByZWZlcmVuY2VzIHRvIHBvaW50cyBhbmQgY29lZmZpY2llbnRzXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGkgKiAyOyBqKyspIHtcbiAgICAgICAgbnBvaW50c1tqXSA9IG51bGw7XG4gICAgICAgIG5jb2VmZnNbal0gPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgaXNSZWQpIHtcbiAgYmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2FmZmluZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gbnVsbDtcbiAgICB0aGlzLnkgPSBudWxsO1xuICAgIHRoaXMuaW5mID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBCTih5LCAxNik7XG4gICAgLy8gRm9yY2UgcmVkZ29tZXJ5IHJlcHJlc2VudGF0aW9uIHdoZW4gbG9hZGluZyBmcm9tIEpTT05cbiAgICBpZiAoaXNSZWQpIHtcbiAgICAgIHRoaXMueC5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgICB0aGlzLnkuZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy55LnJlZClcbiAgICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgdGhpcy5pbmYgPSBmYWxzZTtcbiAgfVxufVxuaW5oZXJpdHNfYnJvd3NlcihQb2ludCwgYmFzZS5CYXNlUG9pbnQpO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHksIGlzUmVkKSB7XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcywgeCwgeSwgaXNSZWQpO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqLCByZWQpIHtcbiAgcmV0dXJuIFBvaW50LmZyb21KU09OKHRoaXMsIG9iaiwgcmVkKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uIF9nZXRCZXRhKCkge1xuICBpZiAoIXRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm47XG5cbiAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG4gIGlmIChwcmUgJiYgcHJlLmJldGEpXG4gICAgcmV0dXJuIHByZS5iZXRhO1xuXG4gIHZhciBiZXRhID0gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngucmVkTXVsKHRoaXMuY3VydmUuZW5kby5iZXRhKSwgdGhpcy55KTtcbiAgaWYgKHByZSkge1xuICAgIHZhciBjdXJ2ZSA9IHRoaXMuY3VydmU7XG4gICAgdmFyIGVuZG9NdWwgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gY3VydmUucG9pbnQocC54LnJlZE11bChjdXJ2ZS5lbmRvLmJldGEpLCBwLnkpO1xuICAgIH07XG4gICAgcHJlLmJldGEgPSBiZXRhO1xuICAgIGJldGEucHJlY29tcHV0ZWQgPSB7XG4gICAgICBiZXRhOiBudWxsLFxuICAgICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgICAgcG9pbnRzOiBwcmUubmFmLnBvaW50cy5tYXAoZW5kb011bCksXG4gICAgICB9LFxuICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuICAgICAgICBwb2ludHM6IHByZS5kb3VibGVzLnBvaW50cy5tYXAoZW5kb011bCksXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGJldGE7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnkgXTtcblxuICByZXR1cm4gWyB0aGlzLngsIHRoaXMueSwgdGhpcy5wcmVjb21wdXRlZCAmJiB7XG4gICAgZG91YmxlczogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzICYmIHtcbiAgICAgIHN0ZXA6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5zdGVwLFxuICAgICAgcG9pbnRzOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMucG9pbnRzLnNsaWNlKDEpLFxuICAgIH0sXG4gICAgbmFmOiB0aGlzLnByZWNvbXB1dGVkLm5hZiAmJiB7XG4gICAgICB3bmQ6IHRoaXMucHJlY29tcHV0ZWQubmFmLnduZCxcbiAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5uYWYucG9pbnRzLnNsaWNlKDEpLFxuICAgIH0sXG4gIH0gXTtcbn07XG5cblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaiwgcmVkKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJylcbiAgICBvYmogPSBKU09OLnBhcnNlKG9iaik7XG4gIHZhciByZXMgPSBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcbiAgaWYgKCFvYmpbMl0pXG4gICAgcmV0dXJuIHJlcztcblxuICBmdW5jdGlvbiBvYmoycG9pbnQob2JqKSB7XG4gICAgcmV0dXJuIGN1cnZlLnBvaW50KG9ialswXSwgb2JqWzFdLCByZWQpO1xuICB9XG5cbiAgdmFyIHByZSA9IG9ialsyXTtcbiAgcmVzLnByZWNvbXB1dGVkID0ge1xuICAgIGJldGE6IG51bGwsXG4gICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgIHBvaW50czogWyByZXMgXS5jb25jYXQocHJlLmRvdWJsZXMucG9pbnRzLm1hcChvYmoycG9pbnQpKSxcbiAgICB9LFxuICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgcG9pbnRzOiBbIHJlcyBdLmNvbmNhdChwcmUubmFmLnBvaW50cy5tYXAob2JqMnBvaW50KSksXG4gICAgfSxcbiAgfTtcbiAgcmV0dXJuIHJlcztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkuZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgcmV0dXJuIHRoaXMuaW5mO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHA7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBQICsgUCA9IDJQXG4gIGlmICh0aGlzLmVxKHApKVxuICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG4gIC8vIFAgKyAoLVApID0gT1xuICBpZiAodGhpcy5uZWcoKS5lcShwKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICAvLyBQICsgUSA9IE9cbiAgaWYgKHRoaXMueC5jbXAocC54KSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgYyA9IHRoaXMueS5yZWRTdWIocC55KTtcbiAgaWYgKGMuY21wbigwKSAhPT0gMClcbiAgICBjID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihwLngpLnJlZEludm0oKSk7XG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngpLnJlZElTdWIocC54KTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyAyUCA9IE9cbiAgdmFyIHlzMSA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgaWYgKHlzMS5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuXG4gIHZhciB4MiA9IHRoaXMueC5yZWRTcXIoKTtcbiAgdmFyIGR5aW52ID0geXMxLnJlZEludm0oKTtcbiAgdmFyIGMgPSB4Mi5yZWRBZGQoeDIpLnJlZElBZGQoeDIpLnJlZElBZGQoYSkucmVkTXVsKGR5aW52KTtcblxuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54LnJlZEFkZCh0aGlzLngpKTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG4gIHJldHVybiB0aGlzLnkuZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrKSB7XG4gIGsgPSBuZXcgQk4oaywgMTYpO1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG4gIGVsc2UgaWYgKHRoaXMuX2hhc0RvdWJsZXMoaykpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2ZpeGVkTmFmTXVsKHRoaXMsIGspO1xuICBlbHNlIGlmICh0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKFsgdGhpcyBdLCBbIGsgXSk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLCBrKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWxBZGQgPSBmdW5jdGlvbiBtdWxBZGQoazEsIHAyLCBrMikge1xuICB2YXIgcG9pbnRzID0gWyB0aGlzLCBwMiBdO1xuICB2YXIgY29lZmZzID0gWyBrMSwgazIgXTtcbiAgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgcG9pbnRzLCBjb2VmZnMsIDIpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmptdWxBZGQgPSBmdW5jdGlvbiBqbXVsQWRkKGsxLCBwMiwgazIpIHtcbiAgdmFyIHBvaW50cyA9IFsgdGhpcywgcDIgXTtcbiAgdmFyIGNvZWZmcyA9IFsgazEsIGsyIF07XG4gIGlmICh0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzLCB0cnVlKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIHBvaW50cywgY29lZmZzLCAyLCB0cnVlKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcbiAgcmV0dXJuIHRoaXMgPT09IHAgfHxcbiAgICAgICAgIHRoaXMuaW5mID09PSBwLmluZiAmJlxuICAgICAgICAgICAgICh0aGlzLmluZiB8fCB0aGlzLnguY21wKHAueCkgPT09IDAgJiYgdGhpcy55LmNtcChwLnkpID09PSAwKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoX3ByZWNvbXB1dGUpIHtcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHZhciByZXMgPSB0aGlzLmN1cnZlLnBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpKTtcbiAgaWYgKF9wcmVjb21wdXRlICYmIHRoaXMucHJlY29tcHV0ZWQpIHtcbiAgICB2YXIgcHJlID0gdGhpcy5wcmVjb21wdXRlZDtcbiAgICB2YXIgbmVnYXRlID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHAubmVnKCk7XG4gICAgfTtcbiAgICByZXMucHJlY29tcHV0ZWQgPSB7XG4gICAgICBuYWY6IHByZS5uYWYgJiYge1xuICAgICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgICBwb2ludHM6IHByZS5uYWYucG9pbnRzLm1hcChuZWdhdGUpLFxuICAgICAgfSxcbiAgICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKG5lZ2F0ZSksXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cblBvaW50LnByb3RvdHlwZS50b0ogPSBmdW5jdGlvbiB0b0ooKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG5cbiAgdmFyIHJlcyA9IHRoaXMuY3VydmUuanBvaW50KHRoaXMueCwgdGhpcy55LCB0aGlzLmN1cnZlLm9uZSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBKUG9pbnQoY3VydmUsIHgsIHksIHopIHtcbiAgYmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2phY29iaWFuJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwgJiYgeiA9PT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueSA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueiA9IG5ldyBCTigwKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBCTih5LCAxNik7XG4gICAgdGhpcy56ID0gbmV3IEJOKHosIDE2KTtcbiAgfVxuICBpZiAoIXRoaXMueC5yZWQpXG4gICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgaWYgKCF0aGlzLnkucmVkKVxuICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gIGlmICghdGhpcy56LnJlZClcbiAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuXG4gIHRoaXMuek9uZSA9IHRoaXMueiA9PT0gdGhpcy5jdXJ2ZS5vbmU7XG59XG5pbmhlcml0c19icm93c2VyKEpQb2ludCwgYmFzZS5CYXNlUG9pbnQpO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5qcG9pbnQgPSBmdW5jdGlvbiBqcG9pbnQoeCwgeSwgeikge1xuICByZXR1cm4gbmV3IEpQb2ludCh0aGlzLCB4LCB5LCB6KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUudG9QID0gZnVuY3Rpb24gdG9QKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIHppbnYgPSB0aGlzLnoucmVkSW52bSgpO1xuICB2YXIgemludjIgPSB6aW52LnJlZFNxcigpO1xuICB2YXIgYXggPSB0aGlzLngucmVkTXVsKHppbnYyKTtcbiAgdmFyIGF5ID0gdGhpcy55LnJlZE11bCh6aW52MikucmVkTXVsKHppbnYpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KGF4LCBheSk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZygpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpLCB0aGlzLnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gMTJNICsgNFMgKyA3QVxuICB2YXIgcHoyID0gcC56LnJlZFNxcigpO1xuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciB1MSA9IHRoaXMueC5yZWRNdWwocHoyKTtcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG4gIHZhciBzMSA9IHRoaXMueS5yZWRNdWwocHoyLnJlZE11bChwLnopKTtcbiAgdmFyIHMyID0gcC55LnJlZE11bCh6Mi5yZWRNdWwodGhpcy56KSk7XG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG4gIGlmIChoLmNtcG4oMCkgPT09IDApIHtcbiAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuICB9XG5cbiAgdmFyIGgyID0gaC5yZWRTcXIoKTtcbiAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cbiAgdmFyIG54ID0gci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7XG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG4gIHZhciBueiA9IHRoaXMuei5yZWRNdWwocC56KS5yZWRNdWwoaCk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5taXhlZEFkZCA9IGZ1bmN0aW9uIG1peGVkQWRkKHApIHtcbiAgLy8gTyArIFAgPSBQXG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gcC50b0ooKTtcblxuICAvLyBQICsgTyA9IFBcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIDhNICsgM1MgKyA3QVxuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciB1MSA9IHRoaXMueDtcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG4gIHZhciBzMSA9IHRoaXMueTtcbiAgdmFyIHMyID0gcC55LnJlZE11bCh6MikucmVkTXVsKHRoaXMueik7XG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG4gIGlmIChoLmNtcG4oMCkgPT09IDApIHtcbiAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuICB9XG5cbiAgdmFyIGgyID0gaC5yZWRTcXIoKTtcbiAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cbiAgdmFyIG54ID0gci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7XG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG4gIHZhciBueiA9IHRoaXMuei5yZWRNdWwoaCk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChwb3cpIHtcbiAgaWYgKHBvdyA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAoIXBvdylcbiAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuICB2YXIgaTtcbiAgaWYgKHRoaXMuY3VydmUuemVyb0EgfHwgdGhpcy5jdXJ2ZS50aHJlZUEpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgZm9yIChpID0gMDsgaSA8IHBvdzsgaSsrKVxuICAgICAgciA9IHIuZGJsKCk7XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICAvLyAxTSArIDJTICsgMUEgKyBOICogKDRTICsgNU0gKyA4QSlcbiAgLy8gTiA9IDEgPT4gNk0gKyA2UyArIDlBXG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuICB2YXIgdGludiA9IHRoaXMuY3VydmUudGludjtcblxuICB2YXIganggPSB0aGlzLng7XG4gIHZhciBqeSA9IHRoaXMueTtcbiAgdmFyIGp6ID0gdGhpcy56O1xuICB2YXIgano0ID0ganoucmVkU3FyKCkucmVkU3FyKCk7XG5cbiAgLy8gUmV1c2UgcmVzdWx0c1xuICB2YXIganlkID0gankucmVkQWRkKGp5KTtcbiAgZm9yIChpID0gMDsgaSA8IHBvdzsgaSsrKSB7XG4gICAgdmFyIGp4MiA9IGp4LnJlZFNxcigpO1xuICAgIHZhciBqeWQyID0ganlkLnJlZFNxcigpO1xuICAgIHZhciBqeWQ0ID0ganlkMi5yZWRTcXIoKTtcbiAgICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICAgIHZhciB0MSA9IGp4LnJlZE11bChqeWQyKTtcbiAgICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG4gICAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG4gICAgdmFyIGRueSA9IGMucmVkTXVsKHQyKTtcbiAgICBkbnkgPSBkbnkucmVkSUFkZChkbnkpLnJlZElTdWIoanlkNCk7XG4gICAgdmFyIG56ID0ganlkLnJlZE11bChqeik7XG4gICAgaWYgKGkgKyAxIDwgcG93KVxuICAgICAgano0ID0gano0LnJlZE11bChqeWQ0KTtcblxuICAgIGp4ID0gbng7XG4gICAganogPSBuejtcbiAgICBqeWQgPSBkbnk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQoangsIGp5ZC5yZWRNdWwodGludiksIGp6KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKHRoaXMuY3VydmUuemVyb0EpXG4gICAgcmV0dXJuIHRoaXMuX3plcm9EYmwoKTtcbiAgZWxzZSBpZiAodGhpcy5jdXJ2ZS50aHJlZUEpXG4gICAgcmV0dXJuIHRoaXMuX3RocmVlRGJsKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fZGJsKCk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl96ZXJvRGJsID0gZnVuY3Rpb24gX3plcm9EYmwoKSB7XG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIC8vIFogPSAxXG4gIGlmICh0aGlzLnpPbmUpIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctbWRibC0yMDA3LWJsXG4gICAgLy8gMU0gKyA1UyArIDE0QVxuXG4gICAgLy8gWFggPSBYMV4yXG4gICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIFlZID0gWTFeMlxuICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBZWVlZID0gWVleMlxuICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gICAgLy8gUyA9IDIgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpXG4gICAgdmFyIHMgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICAgIHMgPSBzLnJlZElBZGQocyk7XG4gICAgLy8gTSA9IDMgKiBYWCArIGE7IGEgPSAwXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuICAgIC8vIFQgPSBNIF4gMiAtIDIqU1xuICAgIHZhciB0ID0gbS5yZWRTcXIoKS5yZWRJU3ViKHMpLnJlZElTdWIocyk7XG5cbiAgICAvLyA4ICogWVlZWVxuICAgIHZhciB5eXl5OCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG5cbiAgICAvLyBYMyA9IFRcbiAgICBueCA9IHQ7XG4gICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG4gICAgbnkgPSBtLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO1xuICAgIC8vIFozID0gMipZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOS1sXG4gICAgLy8gMk0gKyA1UyArIDEzQVxuXG4gICAgLy8gQSA9IFgxXjJcbiAgICB2YXIgYSA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBCID0gWTFeMlxuICAgIHZhciBiID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIEMgPSBCXjJcbiAgICB2YXIgYyA9IGIucmVkU3FyKCk7XG4gICAgLy8gRCA9IDIgKiAoKFgxICsgQileMiAtIEEgLSBDKVxuICAgIHZhciBkID0gdGhpcy54LnJlZEFkZChiKS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYyk7XG4gICAgZCA9IGQucmVkSUFkZChkKTtcbiAgICAvLyBFID0gMyAqIEFcbiAgICB2YXIgZSA9IGEucmVkQWRkKGEpLnJlZElBZGQoYSk7XG4gICAgLy8gRiA9IEVeMlxuICAgIHZhciBmID0gZS5yZWRTcXIoKTtcblxuICAgIC8vIDggKiBDXG4gICAgdmFyIGM4ID0gYy5yZWRJQWRkKGMpO1xuICAgIGM4ID0gYzgucmVkSUFkZChjOCk7XG4gICAgYzggPSBjOC5yZWRJQWRkKGM4KTtcblxuICAgIC8vIFgzID0gRiAtIDIgKiBEXG4gICAgbnggPSBmLnJlZElTdWIoZCkucmVkSVN1YihkKTtcbiAgICAvLyBZMyA9IEUgKiAoRCAtIFgzKSAtIDggKiBDXG4gICAgbnkgPSBlLnJlZE11bChkLnJlZElTdWIobngpKS5yZWRJU3ViKGM4KTtcbiAgICAvLyBaMyA9IDIgKiBZMSAqIFoxXG4gICAgbnogPSB0aGlzLnkucmVkTXVsKHRoaXMueik7XG4gICAgbnogPSBuei5yZWRJQWRkKG56KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX3RocmVlRGJsID0gZnVuY3Rpb24gX3RocmVlRGJsKCkge1xuICB2YXIgbng7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICAvLyBaID0gMVxuICBpZiAodGhpcy56T25lKSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0zLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLW1kYmwtMjAwNy1ibFxuICAgIC8vIDFNICsgNVMgKyAxNUFcblxuICAgIC8vIFhYID0gWDFeMlxuICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBZWSA9IFkxXjJcbiAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gWVlZWSA9IFlZXjJcbiAgICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgICBzID0gcy5yZWRJQWRkKHMpO1xuICAgIC8vIE0gPSAzICogWFggKyBhXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpLnJlZElBZGQodGhpcy5jdXJ2ZS5hKTtcbiAgICAvLyBUID0gTV4yIC0gMiAqIFNcbiAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuICAgIC8vIFgzID0gVFxuICAgIG54ID0gdDtcbiAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcbiAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcbiAgICAvLyBaMyA9IDIgKiBZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMy5odG1sI2RvdWJsaW5nLWRibC0yMDAxLWJcbiAgICAvLyAzTSArIDVTXG5cbiAgICAvLyBkZWx0YSA9IFoxXjJcbiAgICB2YXIgZGVsdGEgPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgLy8gZ2FtbWEgPSBZMV4yXG4gICAgdmFyIGdhbW1hID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIGJldGEgPSBYMSAqIGdhbW1hXG4gICAgdmFyIGJldGEgPSB0aGlzLngucmVkTXVsKGdhbW1hKTtcbiAgICAvLyBhbHBoYSA9IDMgKiAoWDEgLSBkZWx0YSkgKiAoWDEgKyBkZWx0YSlcbiAgICB2YXIgYWxwaGEgPSB0aGlzLngucmVkU3ViKGRlbHRhKS5yZWRNdWwodGhpcy54LnJlZEFkZChkZWx0YSkpO1xuICAgIGFscGhhID0gYWxwaGEucmVkQWRkKGFscGhhKS5yZWRJQWRkKGFscGhhKTtcbiAgICAvLyBYMyA9IGFscGhhXjIgLSA4ICogYmV0YVxuICAgIHZhciBiZXRhNCA9IGJldGEucmVkSUFkZChiZXRhKTtcbiAgICBiZXRhNCA9IGJldGE0LnJlZElBZGQoYmV0YTQpO1xuICAgIHZhciBiZXRhOCA9IGJldGE0LnJlZEFkZChiZXRhNCk7XG4gICAgbnggPSBhbHBoYS5yZWRTcXIoKS5yZWRJU3ViKGJldGE4KTtcbiAgICAvLyBaMyA9IChZMSArIFoxKV4yIC0gZ2FtbWEgLSBkZWx0YVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnopLnJlZFNxcigpLnJlZElTdWIoZ2FtbWEpLnJlZElTdWIoZGVsdGEpO1xuICAgIC8vIFkzID0gYWxwaGEgKiAoNCAqIGJldGEgLSBYMykgLSA4ICogZ2FtbWFeMlxuICAgIHZhciBnZ2FtbWE4ID0gZ2FtbWEucmVkU3FyKCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgbnkgPSBhbHBoYS5yZWRNdWwoYmV0YTQucmVkSVN1YihueCkpLnJlZElTdWIoZ2dhbW1hOCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl9kYmwgPSBmdW5jdGlvbiBfZGJsKCkge1xuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuICAvLyA0TSArIDZTICsgMTBBXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICB2YXIgangyID0gangucmVkU3FyKCk7XG4gIHZhciBqeTIgPSBqeS5yZWRTcXIoKTtcblxuICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICB2YXIganhkNCA9IGp4LnJlZEFkZChqeCk7XG4gIGp4ZDQgPSBqeGQ0LnJlZElBZGQoanhkNCk7XG4gIHZhciB0MSA9IGp4ZDQucmVkTXVsKGp5Mik7XG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTtcbiAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG5cbiAgdmFyIGp5ZDggPSBqeTIucmVkU3FyKCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIHZhciBueSA9IGMucmVkTXVsKHQyKS5yZWRJU3ViKGp5ZDgpO1xuICB2YXIgbnogPSBqeS5yZWRBZGQoankpLnJlZE11bChqeik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50cnBsID0gZnVuY3Rpb24gdHJwbCgpIHtcbiAgaWYgKCF0aGlzLmN1cnZlLnplcm9BKVxuICAgIHJldHVybiB0aGlzLmRibCgpLmFkZCh0aGlzKTtcblxuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbCN0cmlwbGluZy10cGwtMjAwNy1ibFxuICAvLyA1TSArIDEwUyArIC4uLlxuXG4gIC8vIFhYID0gWDFeMlxuICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIFlZID0gWTFeMlxuICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gIC8vIFpaID0gWjFeMlxuICB2YXIgenogPSB0aGlzLnoucmVkU3FyKCk7XG4gIC8vIFlZWVkgPSBZWV4yXG4gIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gIC8vIE0gPSAzICogWFggKyBhICogWloyOyBhID0gMFxuICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7XG4gIC8vIE1NID0gTV4yXG4gIHZhciBtbSA9IG0ucmVkU3FyKCk7XG4gIC8vIEUgPSA2ICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKSAtIE1NXG4gIHZhciBlID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgZSA9IGUucmVkSUFkZChlKTtcbiAgZSA9IGUucmVkQWRkKGUpLnJlZElBZGQoZSk7XG4gIGUgPSBlLnJlZElTdWIobW0pO1xuICAvLyBFRSA9IEVeMlxuICB2YXIgZWUgPSBlLnJlZFNxcigpO1xuICAvLyBUID0gMTYqWVlZWVxuICB2YXIgdCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgLy8gVSA9IChNICsgRSleMiAtIE1NIC0gRUUgLSBUXG4gIHZhciB1ID0gbS5yZWRJQWRkKGUpLnJlZFNxcigpLnJlZElTdWIobW0pLnJlZElTdWIoZWUpLnJlZElTdWIodCk7XG4gIC8vIFgzID0gNCAqIChYMSAqIEVFIC0gNCAqIFlZICogVSlcbiAgdmFyIHl5dTQgPSB5eS5yZWRNdWwodSk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHZhciBueCA9IHRoaXMueC5yZWRNdWwoZWUpLnJlZElTdWIoeXl1NCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIC8vIFkzID0gOCAqIFkxICogKFUgKiAoVCAtIFUpIC0gRSAqIEVFKVxuICB2YXIgbnkgPSB0aGlzLnkucmVkTXVsKHUucmVkTXVsKHQucmVkSVN1Yih1KSkucmVkSVN1YihlLnJlZE11bChlZSkpKTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgLy8gWjMgPSAoWjEgKyBFKV4yIC0gWlogLSBFRVxuICB2YXIgbnogPSB0aGlzLnoucmVkQWRkKGUpLnJlZFNxcigpLnJlZElTdWIoenopLnJlZElTdWIoZWUpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGssIGtiYXNlKSB7XG4gIGsgPSBuZXcgQk4oaywga2Jhc2UpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcbiAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG4gICAgcmV0dXJuIHRoaXMuZXEocC50b0ooKSk7XG5cbiAgaWYgKHRoaXMgPT09IHApXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8geDEgKiB6Ml4yID09IHgyICogejFeMlxuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIGlmICh0aGlzLngucmVkTXVsKHB6MikucmVkSVN1YihwLngucmVkTXVsKHoyKSkuY21wbigwKSAhPT0gMClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8geTEgKiB6Ml4zID09IHkyICogejFeM1xuICB2YXIgejMgPSB6Mi5yZWRNdWwodGhpcy56KTtcbiAgdmFyIHB6MyA9IHB6Mi5yZWRNdWwocC56KTtcbiAgcmV0dXJuIHRoaXMueS5yZWRNdWwocHozKS5yZWRJU3ViKHAueS5yZWRNdWwoejMpKS5jbXBuKDApID09PSAwO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5lcVhUb1AgPSBmdW5jdGlvbiBlcVhUb1AoeCkge1xuICB2YXIgenMgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciByeCA9IHgudG9SZWQodGhpcy5jdXJ2ZS5yZWQpLnJlZE11bCh6cyk7XG4gIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB2YXIgeGMgPSB4LmNsb25lKCk7XG4gIHZhciB0ID0gdGhpcy5jdXJ2ZS5yZWROLnJlZE11bCh6cyk7XG4gIGZvciAoOzspIHtcbiAgICB4Yy5pYWRkKHRoaXMuY3VydmUubik7XG4gICAgaWYgKHhjLmNtcCh0aGlzLmN1cnZlLnApID49IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByeC5yZWRJQWRkKHQpO1xuICAgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgSlBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIEpQb2ludCB4OiAnICsgdGhpcy54LnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgejogJyArIHRoaXMuei50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuICByZXR1cm4gdGhpcy56LmNtcG4oMCkgPT09IDA7XG59O1xuXG52YXIgY3VydmVfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlID0gZXhwb3J0cztcblxuY3VydmUuYmFzZSA9IGJhc2U7XG5jdXJ2ZS5zaG9ydCA9IHNob3J0XzE7XG5jdXJ2ZS5tb250ID0gLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoLi9tb250KSovKG51bGwpO1xuY3VydmUuZWR3YXJkcyA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vZWR3YXJkcykqLyhudWxsKTtcbn0pO1xuXG52YXIgY3VydmVzXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZXMgPSBleHBvcnRzO1xuXG5cblxuXG5cbnZhciBhc3NlcnQgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5mdW5jdGlvbiBQcmVzZXRDdXJ2ZShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnR5cGUgPT09ICdzaG9ydCcpXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBjdXJ2ZV8xLnNob3J0KG9wdGlvbnMpO1xuICBlbHNlIGlmIChvcHRpb25zLnR5cGUgPT09ICdlZHdhcmRzJylcbiAgICB0aGlzLmN1cnZlID0gbmV3IGN1cnZlXzEuZWR3YXJkcyhvcHRpb25zKTtcbiAgZWxzZVxuICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmVfMS5tb250KG9wdGlvbnMpO1xuICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG4gIHRoaXMubiA9IHRoaXMuY3VydmUubjtcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuXG4gIGFzc2VydCh0aGlzLmcudmFsaWRhdGUoKSwgJ0ludmFsaWQgY3VydmUnKTtcbiAgYXNzZXJ0KHRoaXMuZy5tdWwodGhpcy5uKS5pc0luZmluaXR5KCksICdJbnZhbGlkIGN1cnZlLCBHKk4gIT0gTycpO1xufVxuY3VydmVzLlByZXNldEN1cnZlID0gUHJlc2V0Q3VydmU7XG5cbmZ1bmN0aW9uIGRlZmluZUN1cnZlKG5hbWUsIG9wdGlvbnMpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3VydmUgPSBuZXcgUHJlc2V0Q3VydmUob3B0aW9ucyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLCBuYW1lLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGN1cnZlLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY3VydmU7XG4gICAgfSxcbiAgfSk7XG59XG5cbmRlZmluZUN1cnZlKCdwMTkyJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ3AxOTInLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICBiOiAnNjQyMTA1MTkgZTU5YzgwZTcgMGZhN2U5YWIgNzIyNDMwNDkgZmViOGRlZWMgYzE0NmI5YjEnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgOTlkZWY4MzYgMTQ2YmM5YjEgYjRkMjI4MzEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMTg4ZGE4MGUgYjAzMDkwZjYgN2NiZjIwZWIgNDNhMTg4MDAgZjRmZjBhZmQgODJmZjEwMTInLFxuICAgICcwNzE5MmI5NSBmZmM4ZGE3OCA2MzEwMTFlZCA2YjI0Y2RkNSA3M2Y5NzdhMSAxZTc5NDgxMScsXG4gIF0sXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AyMjQnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAncDIyNCcsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZScsXG4gIGI6ICdiNDA1MGE4NSAwYzA0YjNhYiBmNTQxMzI1NiA1MDQ0YjBiNyBkN2JmZDhiYSAyNzBiMzk0MyAyMzU1ZmZiNCcsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmMTZhMiBlMGI4ZjAzZSAxM2RkMjk0NSA1YzVjMmEzZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICdiNzBlMGNiZCA2YmI0YmY3ZiAzMjEzOTBiOSA0YTAzYzFkMyA1NmMyMTEyMiAzNDMyODBkNiAxMTVjMWQyMScsXG4gICAgJ2JkMzc2Mzg4IGI1ZjcyM2ZiIDRjMjJkZmU2IGNkNDM3NWEwIDVhMDc0NzY0IDQ0ZDU4MTk5IDg1MDA3ZTM0JyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDI1NicsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICc1YWM2MzVkOCBhYTNhOTNlNyBiM2ViYmQ1NSA3Njk4ODZiYyA2NTFkMDZiMCBjYzUzYjBmNiAzYmNlM2MzZSAyN2QyNjA0YicsXG4gIG46ICdmZmZmZmZmZiAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBiY2U2ZmFhZCBhNzE3OWU4NCBmM2I5Y2FjMiBmYzYzMjU1MScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc2YjE3ZDFmMiBlMTJjNDI0NyBmOGJjZTZlNSA2M2E0NDBmMiA3NzAzN2Q4MSAyZGViMzNhMCBmNGExMzk0NSBkODk4YzI5NicsXG4gICAgJzRmZTM0MmUyIGZlMWE3ZjliIDhlZTdlYjRhIDdjMGY5ZTE2IDJiY2UzMzU3IDZiMzE1ZWNlIGNiYjY0MDY4IDM3YmY1MWY1JyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDM4NCcsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmMnLFxuICBiOiAnYjMzMTJmYTcgZTIzZWU3ZTQgOTg4ZTA1NmIgZTNmODJkMTkgMTgxZDljNmUgZmU4MTQxMTIgMDMxNDA4OGYgJyArXG4gICAgICc1MDEzODc1YSBjNjU2Mzk4ZCA4YTJlZDE5ZCAyYTg1YzhlZCBkM2VjMmFlZicsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBjNzYzNGQ4MSAnICtcbiAgICAgJ2Y0MzcyZGRmIDU4MWEwZGIyIDQ4YjBhNzdhIGVjZWMxOTZhIGNjYzUyOTczJyxcbiAgaGFzaDogaGFzaC5zaGEzODQsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJ2FhODdjYTIyIGJlOGIwNTM3IDhlYjFjNzFlIGYzMjBhZDc0IDZlMWQzYjYyIDhiYTc5Yjk4IDU5Zjc0MWUwIDgyNTQyYTM4ICcgK1xuICAgICc1NTAyZjI1ZCBiZjU1Mjk2YyAzYTU0NWUzOCA3Mjc2MGFiNycsXG4gICAgJzM2MTdkZTRhIDk2MjYyYzZmIDVkOWU5OGJmIDkyOTJkYzI5IGY4ZjQxZGJkIDI4OWExNDdjIGU5ZGEzMTEzIGI1ZjBiOGMwICcgK1xuICAgICcwYTYwYjFjZSAxZDdlODE5ZCA3YTQzMWQ3YyA5MGVhMGU1ZicsXG4gIF0sXG59KTtcblxuZGVmaW5lQ3VydmUoJ3A1MjEnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICcwMDAwMDA1MSA5NTNlYjk2MSA4ZTFjOWExZiA5MjlhMjFhMCBiNjg1NDBlZSBhMmRhNzI1YiAnICtcbiAgICAgJzk5YjMxNWYzIGI4YjQ4OTkxIDhlZjEwOWUxIDU2MTkzOTUxIGVjN2U5MzdiIDE2NTJjMGJkICcgK1xuICAgICAnM2JiMWJmMDcgMzU3M2RmODggM2QyYzM0ZjEgZWY0NTFmZDQgNmI1MDNmMDAnLFxuICBuOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYSA1MTg2ODc4MyBiZjJmOTY2YiA3ZmNjMDE0OCAnICtcbiAgICAgJ2Y3MDlhNWQwIDNiYjVjOWI4IDg5OWM0N2FlIGJiNmZiNzFlIDkxMzg2NDA5JyxcbiAgaGFzaDogaGFzaC5zaGE1MTIsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzAwMDAwMGM2IDg1OGUwNmI3IDA0MDRlOWNkIDllM2VjYjY2IDIzOTViNDQyIDljNjQ4MTM5ICcgK1xuICAgICcwNTNmYjUyMSBmODI4YWY2MCA2YjRkM2RiYSBhMTRiNWU3NyBlZmU3NTkyOCBmZTFkYzEyNyAnICtcbiAgICAnYTJmZmE4ZGUgMzM0OGIzYzEgODU2YTQyOWIgZjk3ZTdlMzEgYzJlNWJkNjYnLFxuICAgICcwMDAwMDExOCAzOTI5NmE3OCA5YTNiYzAwNCA1YzhhNWZiNCAyYzdkMWJkOSA5OGY1NDQ0OSAnICtcbiAgICAnNTc5YjQ0NjggMTdhZmJkMTcgMjczZTY2MmMgOTdlZTcyOTkgNWVmNDI2NDAgYzU1MGI5MDEgJyArXG4gICAgJzNmYWQwNzYxIDM1M2M3MDg2IGEyNzJjMjQwIDg4YmU5NDc2IDlmZDE2NjUwJyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgnY3VydmUyNTUxOScsIHtcbiAgdHlwZTogJ21vbnQnLFxuICBwcmltZTogJ3AyNTUxOScsXG4gIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcbiAgYTogJzc2ZDA2JyxcbiAgYjogJzEnLFxuICBuOiAnMTAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwIDE0ZGVmOWRlYTJmNzljZDYgNTgxMjYzMWE1Y2Y1ZDNlZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc5JyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgnZWQyNTUxOScsIHtcbiAgdHlwZTogJ2Vkd2FyZHMnLFxuICBwcmltZTogJ3AyNTUxOScsXG4gIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcbiAgYTogJy0xJyxcbiAgYzogJzEnLFxuICAvLyAtMTIxNjY1ICogKDEyMTY2Nl4oLTEpKSAobW9kIFApXG4gIGQ6ICc1MjAzNmNlZTJiNmZmZTczIDhjYzc0MDc5Nzc3OWU4OTggMDA3MDBhNGQ0MTQxZDhhYiA3NWViNGRjYTEzNTk3OGEzJyxcbiAgbjogJzEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWQnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMjE2OTM2ZDNjZDZlNTNmZWMwYTRlMjMxZmRkNmRjNWM2OTJjYzc2MDk1MjVhN2IyYzk1NjJkNjA4ZjI1ZDUxYScsXG5cbiAgICAvLyA0LzVcbiAgICAnNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY1OCcsXG4gIF0sXG59KTtcblxudmFyIHByZTtcbnRyeSB7XG4gIHByZSA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vcHJlY29tcHV0ZWQvc2VjcDI1NmsxKSovKG51bGwpLmNyYXNoKCk7XG59IGNhdGNoIChlKSB7XG4gIHByZSA9IHVuZGVmaW5lZDtcbn1cblxuZGVmaW5lQ3VydmUoJ3NlY3AyNTZrMScsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdrMjU2JyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyxcbiAgYTogJzAnLFxuICBiOiAnNycsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBiYWFlZGNlNiBhZjQ4YTAzYiBiZmQyNWU4YyBkMDM2NDE0MScsXG4gIGg6ICcxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG5cbiAgLy8gUHJlY29tcHV0ZWQgZW5kb21vcnBoaXNtXG4gIGJldGE6ICc3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyxcbiAgbGFtYmRhOiAnNTM2M2FkNGNjMDVjMzBlMGE1MjYxYzAyODgxMjY0NWExMjJlMjJlYTIwODE2Njc4ZGYwMjk2N2MxYjIzYmQ3MicsXG4gIGJhc2lzOiBbXG4gICAge1xuICAgICAgYTogJzMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1JyxcbiAgICAgIGI6ICctZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnLFxuICAgIH0sXG4gICAge1xuICAgICAgYTogJzExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcsXG4gICAgICBiOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnLFxuICAgIH0sXG4gIF0sXG5cbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnNzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OCcsXG4gICAgJzQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjgnLFxuICAgIHByZSxcbiAgXSxcbn0pO1xufSk7XG5cbid1c2Ugc3RyaWN0JztcblxuXG5cblxuXG5mdW5jdGlvbiBIbWFjRFJCRyhvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIbWFjRFJCRykpXG4gICAgcmV0dXJuIG5ldyBIbWFjRFJCRyhvcHRpb25zKTtcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuICB0aGlzLnByZWRSZXNpc3QgPSAhIW9wdGlvbnMucHJlZFJlc2lzdDtcblxuICB0aGlzLm91dExlbiA9IHRoaXMuaGFzaC5vdXRTaXplO1xuICB0aGlzLm1pbkVudHJvcHkgPSBvcHRpb25zLm1pbkVudHJvcHkgfHwgdGhpcy5oYXNoLmhtYWNTdHJlbmd0aDtcblxuICB0aGlzLl9yZXNlZWQgPSBudWxsO1xuICB0aGlzLnJlc2VlZEludGVydmFsID0gbnVsbDtcbiAgdGhpcy5LID0gbnVsbDtcbiAgdGhpcy5WID0gbnVsbDtcblxuICB2YXIgZW50cm9weSA9IHV0aWxzXzEudG9BcnJheShvcHRpb25zLmVudHJvcHksIG9wdGlvbnMuZW50cm9weUVuYyB8fCAnaGV4Jyk7XG4gIHZhciBub25jZSA9IHV0aWxzXzEudG9BcnJheShvcHRpb25zLm5vbmNlLCBvcHRpb25zLm5vbmNlRW5jIHx8ICdoZXgnKTtcbiAgdmFyIHBlcnMgPSB1dGlsc18xLnRvQXJyYXkob3B0aW9ucy5wZXJzLCBvcHRpb25zLnBlcnNFbmMgfHwgJ2hleCcpO1xuICBtaW5pbWFsaXN0aWNBc3NlcnQoZW50cm9weS5sZW5ndGggPj0gKHRoaXMubWluRW50cm9weSAvIDgpLFxuICAgICAgICAgJ05vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogJyArIHRoaXMubWluRW50cm9weSArICcgYml0cycpO1xuICB0aGlzLl9pbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKTtcbn1cbnZhciBobWFjRHJiZyA9IEhtYWNEUkJHO1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKSB7XG4gIHZhciBzZWVkID0gZW50cm9weS5jb25jYXQobm9uY2UpLmNvbmNhdChwZXJzKTtcblxuICB0aGlzLksgPSBuZXcgQXJyYXkodGhpcy5vdXRMZW4gLyA4KTtcbiAgdGhpcy5WID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5WLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5LW2ldID0gMHgwMDtcbiAgICB0aGlzLlZbaV0gPSAweDAxO1xuICB9XG5cbiAgdGhpcy5fdXBkYXRlKHNlZWQpO1xuICB0aGlzLl9yZXNlZWQgPSAxO1xuICB0aGlzLnJlc2VlZEludGVydmFsID0gMHgxMDAwMDAwMDAwMDAwOyAgLy8gMl40OFxufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLl9obWFjID0gZnVuY3Rpb24gaG1hYygpIHtcbiAgcmV0dXJuIG5ldyBoYXNoLmhtYWModGhpcy5oYXNoLCB0aGlzLkspO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc2VlZCkge1xuICB2YXIga21hYyA9IHRoaXMuX2htYWMoKVxuICAgICAgICAgICAgICAgICAudXBkYXRlKHRoaXMuVilcbiAgICAgICAgICAgICAgICAgLnVwZGF0ZShbIDB4MDAgXSk7XG4gIGlmIChzZWVkKVxuICAgIGttYWMgPSBrbWFjLnVwZGF0ZShzZWVkKTtcbiAgdGhpcy5LID0ga21hYy5kaWdlc3QoKTtcbiAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xuICBpZiAoIXNlZWQpXG4gICAgcmV0dXJuO1xuXG4gIHRoaXMuSyA9IHRoaXMuX2htYWMoKVxuICAgICAgICAgICAgICAgLnVwZGF0ZSh0aGlzLlYpXG4gICAgICAgICAgICAgICAudXBkYXRlKFsgMHgwMSBdKVxuICAgICAgICAgICAgICAgLnVwZGF0ZShzZWVkKVxuICAgICAgICAgICAgICAgLmRpZ2VzdCgpO1xuICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUucmVzZWVkID0gZnVuY3Rpb24gcmVzZWVkKGVudHJvcHksIGVudHJvcHlFbmMsIGFkZCwgYWRkRW5jKSB7XG4gIC8vIE9wdGlvbmFsIGVudHJvcHkgZW5jXG4gIGlmICh0eXBlb2YgZW50cm9weUVuYyAhPT0gJ3N0cmluZycpIHtcbiAgICBhZGRFbmMgPSBhZGQ7XG4gICAgYWRkID0gZW50cm9weUVuYztcbiAgICBlbnRyb3B5RW5jID0gbnVsbDtcbiAgfVxuXG4gIGVudHJvcHkgPSB1dGlsc18xLnRvQXJyYXkoZW50cm9weSwgZW50cm9weUVuYyk7XG4gIGFkZCA9IHV0aWxzXzEudG9BcnJheShhZGQsIGFkZEVuYyk7XG5cbiAgbWluaW1hbGlzdGljQXNzZXJ0KGVudHJvcHkubGVuZ3RoID49ICh0aGlzLm1pbkVudHJvcHkgLyA4KSxcbiAgICAgICAgICdOb3QgZW5vdWdoIGVudHJvcHkuIE1pbmltdW0gaXM6ICcgKyB0aGlzLm1pbkVudHJvcHkgKyAnIGJpdHMnKTtcblxuICB0aGlzLl91cGRhdGUoZW50cm9weS5jb25jYXQoYWRkIHx8IFtdKSk7XG4gIHRoaXMuX3Jlc2VlZCA9IDE7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZShsZW4sIGVuYywgYWRkLCBhZGRFbmMpIHtcbiAgaWYgKHRoaXMuX3Jlc2VlZCA+IHRoaXMucmVzZWVkSW50ZXJ2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNlZWQgaXMgcmVxdWlyZWQnKTtcblxuICAvLyBPcHRpb25hbCBlbmNvZGluZ1xuICBpZiAodHlwZW9mIGVuYyAhPT0gJ3N0cmluZycpIHtcbiAgICBhZGRFbmMgPSBhZGQ7XG4gICAgYWRkID0gZW5jO1xuICAgIGVuYyA9IG51bGw7XG4gIH1cblxuICAvLyBPcHRpb25hbCBhZGRpdGlvbmFsIGRhdGFcbiAgaWYgKGFkZCkge1xuICAgIGFkZCA9IHV0aWxzXzEudG9BcnJheShhZGQsIGFkZEVuYyB8fCAnaGV4Jyk7XG4gICAgdGhpcy5fdXBkYXRlKGFkZCk7XG4gIH1cblxuICB2YXIgdGVtcCA9IFtdO1xuICB3aGlsZSAodGVtcC5sZW5ndGggPCBsZW4pIHtcbiAgICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG4gICAgdGVtcCA9IHRlbXAuY29uY2F0KHRoaXMuVik7XG4gIH1cblxuICB2YXIgcmVzID0gdGVtcC5zbGljZSgwLCBsZW4pO1xuICB0aGlzLl91cGRhdGUoYWRkKTtcbiAgdGhpcy5fcmVzZWVkKys7XG4gIHJldHVybiB1dGlsc18xLmVuY29kZShyZXMsIGVuYyk7XG59O1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG52YXIgYXNzZXJ0JDMgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5mdW5jdGlvbiBLZXlQYWlyKGVjLCBvcHRpb25zKSB7XG4gIHRoaXMuZWMgPSBlYztcbiAgdGhpcy5wcml2ID0gbnVsbDtcbiAgdGhpcy5wdWIgPSBudWxsO1xuXG4gIC8vIEtleVBhaXIoZWMsIHsgcHJpdjogLi4uLCBwdWI6IC4uLiB9KVxuICBpZiAob3B0aW9ucy5wcml2KVxuICAgIHRoaXMuX2ltcG9ydFByaXZhdGUob3B0aW9ucy5wcml2LCBvcHRpb25zLnByaXZFbmMpO1xuICBpZiAob3B0aW9ucy5wdWIpXG4gICAgdGhpcy5faW1wb3J0UHVibGljKG9wdGlvbnMucHViLCBvcHRpb25zLnB1YkVuYyk7XG59XG52YXIga2V5ID0gS2V5UGFpcjtcblxuS2V5UGFpci5mcm9tUHVibGljID0gZnVuY3Rpb24gZnJvbVB1YmxpYyhlYywgcHViLCBlbmMpIHtcbiAgaWYgKHB1YiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHB1YjtcblxuICByZXR1cm4gbmV3IEtleVBhaXIoZWMsIHtcbiAgICBwdWI6IHB1YixcbiAgICBwdWJFbmM6IGVuYyxcbiAgfSk7XG59O1xuXG5LZXlQYWlyLmZyb21Qcml2YXRlID0gZnVuY3Rpb24gZnJvbVByaXZhdGUoZWMsIHByaXYsIGVuYykge1xuICBpZiAocHJpdiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHByaXY7XG5cbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVjLCB7XG4gICAgcHJpdjogcHJpdixcbiAgICBwcml2RW5jOiBlbmMsXG4gIH0pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgdmFyIHB1YiA9IHRoaXMuZ2V0UHVibGljKCk7XG5cbiAgaWYgKHB1Yi5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnSW52YWxpZCBwdWJsaWMga2V5JyB9O1xuICBpZiAoIXB1Yi52YWxpZGF0ZSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ1B1YmxpYyBrZXkgaXMgbm90IGEgcG9pbnQnIH07XG4gIGlmICghcHViLm11bCh0aGlzLmVjLmN1cnZlLm4pLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5ICogTiAhPSBPJyB9O1xuXG4gIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgcmVhc29uOiBudWxsIH07XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQdWJsaWMgPSBmdW5jdGlvbiBnZXRQdWJsaWMoY29tcGFjdCwgZW5jKSB7XG4gIC8vIGNvbXBhY3QgaXMgb3B0aW9uYWwgYXJndW1lbnRcbiAgaWYgKHR5cGVvZiBjb21wYWN0ID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGNvbXBhY3Q7XG4gICAgY29tcGFjdCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXRoaXMucHViKVxuICAgIHRoaXMucHViID0gdGhpcy5lYy5nLm11bCh0aGlzLnByaXYpO1xuXG4gIGlmICghZW5jKVxuICAgIHJldHVybiB0aGlzLnB1YjtcblxuICByZXR1cm4gdGhpcy5wdWIuZW5jb2RlKGVuYywgY29tcGFjdCk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQcml2YXRlID0gZnVuY3Rpb24gZ2V0UHJpdmF0ZShlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHRoaXMucHJpdi50b1N0cmluZygxNiwgMik7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5wcml2O1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFByaXZhdGUgPSBmdW5jdGlvbiBfaW1wb3J0UHJpdmF0ZShrZXksIGVuYykge1xuICB0aGlzLnByaXYgPSBuZXcgQk4oa2V5LCBlbmMgfHwgMTYpO1xuXG4gIC8vIEVuc3VyZSB0aGF0IHRoZSBwcml2IHdvbid0IGJlIGJpZ2dlciB0aGFuIG4sIG90aGVyd2lzZSB3ZSBtYXkgZmFpbFxuICAvLyBpbiBmaXhlZCBtdWx0aXBsaWNhdGlvbiBtZXRob2RcbiAgdGhpcy5wcml2ID0gdGhpcy5wcml2LnVtb2QodGhpcy5lYy5jdXJ2ZS5uKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLl9pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbiBfaW1wb3J0UHVibGljKGtleSwgZW5jKSB7XG4gIGlmIChrZXkueCB8fCBrZXkueSkge1xuICAgIC8vIE1vbnRnb21lcnkgcG9pbnRzIG9ubHkgaGF2ZSBhbiBgeGAgY29vcmRpbmF0ZS5cbiAgICAvLyBXZWllcnN0cmFzcy9FZHdhcmRzIHBvaW50cyBvbiB0aGUgb3RoZXIgaGFuZCBoYXZlIGJvdGggYHhgIGFuZFxuICAgIC8vIGB5YCBjb29yZGluYXRlcy5cbiAgICBpZiAodGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnbW9udCcpIHtcbiAgICAgIGFzc2VydCQzKGtleS54LCAnTmVlZCB4IGNvb3JkaW5hdGUnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ3Nob3J0JyB8fFxuICAgICAgICAgICAgICAgdGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnZWR3YXJkcycpIHtcbiAgICAgIGFzc2VydCQzKGtleS54ICYmIGtleS55LCAnTmVlZCBib3RoIHggYW5kIHkgY29vcmRpbmF0ZScpO1xuICAgIH1cbiAgICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUucG9pbnQoa2V5LngsIGtleS55KTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5wdWIgPSB0aGlzLmVjLmN1cnZlLmRlY29kZVBvaW50KGtleSwgZW5jKTtcbn07XG5cbi8vIEVDREhcbktleVBhaXIucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uIGRlcml2ZShwdWIpIHtcbiAgaWYoIXB1Yi52YWxpZGF0ZSgpKSB7XG4gICAgYXNzZXJ0JDMocHViLnZhbGlkYXRlKCksICdwdWJsaWMgcG9pbnQgbm90IHZhbGlkYXRlZCcpO1xuICB9XG4gIHJldHVybiBwdWIubXVsKHRoaXMucHJpdikuZ2V0WCgpO1xufTtcblxuLy8gRUNEU0FcbktleVBhaXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1zZywgZW5jLCBvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmVjLnNpZ24obXNnLCB0aGlzLCBlbmMsIG9wdGlvbnMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1zZywgc2lnbmF0dXJlKSB7XG4gIHJldHVybiB0aGlzLmVjLnZlcmlmeShtc2csIHNpZ25hdHVyZSwgdGhpcyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgcmV0dXJuICc8S2V5IHByaXY6ICcgKyAodGhpcy5wcml2ICYmIHRoaXMucHJpdi50b1N0cmluZygxNiwgMikpICtcbiAgICAgICAgICcgcHViOiAnICsgKHRoaXMucHViICYmIHRoaXMucHViLmluc3BlY3QoKSkgKyAnID4nO1xufTtcblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuXG52YXIgYXNzZXJ0JDQgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5mdW5jdGlvbiBTaWduYXR1cmUob3B0aW9ucywgZW5jKSB7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgU2lnbmF0dXJlKVxuICAgIHJldHVybiBvcHRpb25zO1xuXG4gIGlmICh0aGlzLl9pbXBvcnRERVIob3B0aW9ucywgZW5jKSlcbiAgICByZXR1cm47XG5cbiAgYXNzZXJ0JDQob3B0aW9ucy5yICYmIG9wdGlvbnMucywgJ1NpZ25hdHVyZSB3aXRob3V0IHIgb3IgcycpO1xuICB0aGlzLnIgPSBuZXcgQk4ob3B0aW9ucy5yLCAxNik7XG4gIHRoaXMucyA9IG5ldyBCTihvcHRpb25zLnMsIDE2KTtcbiAgaWYgKG9wdGlvbnMucmVjb3ZlcnlQYXJhbSA9PT0gdW5kZWZpbmVkKVxuICAgIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG51bGw7XG4gIGVsc2VcbiAgICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBvcHRpb25zLnJlY292ZXJ5UGFyYW07XG59XG52YXIgc2lnbmF0dXJlID0gU2lnbmF0dXJlO1xuXG5mdW5jdGlvbiBQb3NpdGlvbigpIHtcbiAgdGhpcy5wbGFjZSA9IDA7XG59XG5cbmZ1bmN0aW9uIGdldExlbmd0aChidWYsIHApIHtcbiAgdmFyIGluaXRpYWwgPSBidWZbcC5wbGFjZSsrXTtcbiAgaWYgKCEoaW5pdGlhbCAmIDB4ODApKSB7XG4gICAgcmV0dXJuIGluaXRpYWw7XG4gIH1cbiAgdmFyIG9jdGV0TGVuID0gaW5pdGlhbCAmIDB4ZjtcblxuICAvLyBJbmRlZmluaXRlIGxlbmd0aCBvciBvdmVyZmxvd1xuICBpZiAob2N0ZXRMZW4gPT09IDAgfHwgb2N0ZXRMZW4gPiA0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHZhbCA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBvZmYgPSBwLnBsYWNlOyBpIDwgb2N0ZXRMZW47IGkrKywgb2ZmKyspIHtcbiAgICB2YWwgPDw9IDg7XG4gICAgdmFsIHw9IGJ1ZltvZmZdO1xuICAgIHZhbCA+Pj49IDA7XG4gIH1cblxuICAvLyBMZWFkaW5nIHplcm9lc1xuICBpZiAodmFsIDw9IDB4N2YpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwLnBsYWNlID0gb2ZmO1xuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBybVBhZGRpbmcoYnVmKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGggLSAxO1xuICB3aGlsZSAoIWJ1ZltpXSAmJiAhKGJ1ZltpICsgMV0gJiAweDgwKSAmJiBpIDwgbGVuKSB7XG4gICAgaSsrO1xuICB9XG4gIGlmIChpID09PSAwKSB7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuICByZXR1cm4gYnVmLnNsaWNlKGkpO1xufVxuXG5TaWduYXR1cmUucHJvdG90eXBlLl9pbXBvcnRERVIgPSBmdW5jdGlvbiBfaW1wb3J0REVSKGRhdGEsIGVuYykge1xuICBkYXRhID0gdXRpbHNfMSQxLnRvQXJyYXkoZGF0YSwgZW5jKTtcbiAgdmFyIHAgPSBuZXcgUG9zaXRpb24oKTtcbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgzMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICBpZiAobGVuID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoKGxlbiArIHAucGxhY2UpICE9PSBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBybGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICBpZiAocmxlbiA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHIgPSBkYXRhLnNsaWNlKHAucGxhY2UsIHJsZW4gKyBwLnBsYWNlKTtcbiAgcC5wbGFjZSArPSBybGVuO1xuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBzbGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICBpZiAoc2xlbiA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRhdGEubGVuZ3RoICE9PSBzbGVuICsgcC5wbGFjZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcyA9IGRhdGEuc2xpY2UocC5wbGFjZSwgc2xlbiArIHAucGxhY2UpO1xuICBpZiAoclswXSA9PT0gMCkge1xuICAgIGlmIChyWzFdICYgMHg4MCkge1xuICAgICAgciA9IHIuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExlYWRpbmcgemVyb2VzXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChzWzBdID09PSAwKSB7XG4gICAgaWYgKHNbMV0gJiAweDgwKSB7XG4gICAgICBzID0gcy5zbGljZSgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGVhZGluZyB6ZXJvZXNcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnIgPSBuZXcgQk4ocik7XG4gIHRoaXMucyA9IG5ldyBCTihzKTtcbiAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdExlbmd0aChhcnIsIGxlbikge1xuICBpZiAobGVuIDwgMHg4MCkge1xuICAgIGFyci5wdXNoKGxlbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvY3RldHMgPSAxICsgKE1hdGgubG9nKGxlbikgLyBNYXRoLkxOMiA+Pj4gMyk7XG4gIGFyci5wdXNoKG9jdGV0cyB8IDB4ODApO1xuICB3aGlsZSAoLS1vY3RldHMpIHtcbiAgICBhcnIucHVzaCgobGVuID4+PiAob2N0ZXRzIDw8IDMpKSAmIDB4ZmYpO1xuICB9XG4gIGFyci5wdXNoKGxlbik7XG59XG5cblNpZ25hdHVyZS5wcm90b3R5cGUudG9ERVIgPSBmdW5jdGlvbiB0b0RFUihlbmMpIHtcbiAgdmFyIHIgPSB0aGlzLnIudG9BcnJheSgpO1xuICB2YXIgcyA9IHRoaXMucy50b0FycmF5KCk7XG5cbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoclswXSAmIDB4ODApXG4gICAgciA9IFsgMCBdLmNvbmNhdChyKTtcbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoc1swXSAmIDB4ODApXG4gICAgcyA9IFsgMCBdLmNvbmNhdChzKTtcblxuICByID0gcm1QYWRkaW5nKHIpO1xuICBzID0gcm1QYWRkaW5nKHMpO1xuXG4gIHdoaWxlICghc1swXSAmJiAhKHNbMV0gJiAweDgwKSkge1xuICAgIHMgPSBzLnNsaWNlKDEpO1xuICB9XG4gIHZhciBhcnIgPSBbIDB4MDIgXTtcbiAgY29uc3RydWN0TGVuZ3RoKGFyciwgci5sZW5ndGgpO1xuICBhcnIgPSBhcnIuY29uY2F0KHIpO1xuICBhcnIucHVzaCgweDAyKTtcbiAgY29uc3RydWN0TGVuZ3RoKGFyciwgcy5sZW5ndGgpO1xuICB2YXIgYmFja0hhbGYgPSBhcnIuY29uY2F0KHMpO1xuICB2YXIgcmVzID0gWyAweDMwIF07XG4gIGNvbnN0cnVjdExlbmd0aChyZXMsIGJhY2tIYWxmLmxlbmd0aCk7XG4gIHJlcyA9IHJlcy5jb25jYXQoYmFja0hhbGYpO1xuICByZXR1cm4gdXRpbHNfMSQxLmVuY29kZShyZXMsIGVuYyk7XG59O1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5cblxudmFyIHJhbmQgPSAvKlJpY01vbzpldGhlcnM6cmVxdWlyZShicm9yYW5kKSovKGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkJyk7IH0pO1xudmFyIGFzc2VydCQ1ID0gdXRpbHNfMSQxLmFzc2VydDtcblxuXG5cblxuZnVuY3Rpb24gRUMob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRUMpKVxuICAgIHJldHVybiBuZXcgRUMob3B0aW9ucyk7XG5cbiAgLy8gU2hvcnRjdXQgYGVsbGlwdGljLmVjKGN1cnZlLW5hbWUpYFxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgYXNzZXJ0JDUoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnZlc18xLCBvcHRpb25zKSxcbiAgICAgICdVbmtub3duIGN1cnZlICcgKyBvcHRpb25zKTtcblxuICAgIG9wdGlvbnMgPSBjdXJ2ZXNfMVtvcHRpb25zXTtcbiAgfVxuXG4gIC8vIFNob3J0Y3V0IGZvciBgZWxsaXB0aWMuZWMoZWxsaXB0aWMuY3VydmVzLmN1cnZlTmFtZSlgXG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgY3VydmVzXzEuUHJlc2V0Q3VydmUpXG4gICAgb3B0aW9ucyA9IHsgY3VydmU6IG9wdGlvbnMgfTtcblxuICB0aGlzLmN1cnZlID0gb3B0aW9ucy5jdXJ2ZS5jdXJ2ZTtcbiAgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uO1xuICB0aGlzLm5oID0gdGhpcy5uLnVzaHJuKDEpO1xuICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG5cbiAgLy8gUG9pbnQgb24gY3VydmVcbiAgdGhpcy5nID0gb3B0aW9ucy5jdXJ2ZS5nO1xuICB0aGlzLmcucHJlY29tcHV0ZShvcHRpb25zLmN1cnZlLm4uYml0TGVuZ3RoKCkgKyAxKTtcblxuICAvLyBIYXNoIGZvciBmdW5jdGlvbiBmb3IgRFJCR1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2ggfHwgb3B0aW9ucy5jdXJ2ZS5oYXNoO1xufVxudmFyIGVjID0gRUM7XG5cbkVDLnByb3RvdHlwZS5rZXlQYWlyID0gZnVuY3Rpb24ga2V5UGFpcihvcHRpb25zKSB7XG4gIHJldHVybiBuZXcga2V5KHRoaXMsIG9wdGlvbnMpO1xufTtcblxuRUMucHJvdG90eXBlLmtleUZyb21Qcml2YXRlID0gZnVuY3Rpb24ga2V5RnJvbVByaXZhdGUocHJpdiwgZW5jKSB7XG4gIHJldHVybiBrZXkuZnJvbVByaXZhdGUodGhpcywgcHJpdiwgZW5jKTtcbn07XG5cbkVDLnByb3RvdHlwZS5rZXlGcm9tUHVibGljID0gZnVuY3Rpb24ga2V5RnJvbVB1YmxpYyhwdWIsIGVuYykge1xuICByZXR1cm4ga2V5LmZyb21QdWJsaWModGhpcywgcHViLCBlbmMpO1xufTtcblxuRUMucHJvdG90eXBlLmdlbktleVBhaXIgPSBmdW5jdGlvbiBnZW5LZXlQYWlyKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fTtcblxuICAvLyBJbnN0YW50aWF0ZSBIbWFjX0RSQkdcbiAgdmFyIGRyYmcgPSBuZXcgaG1hY0RyYmcoe1xuICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG4gICAgcGVyc0VuYzogb3B0aW9ucy5wZXJzRW5jIHx8ICd1dGY4JyxcbiAgICBlbnRyb3B5OiBvcHRpb25zLmVudHJvcHkgfHwgcmFuZCh0aGlzLmhhc2guaG1hY1N0cmVuZ3RoKSxcbiAgICBlbnRyb3B5RW5jOiBvcHRpb25zLmVudHJvcHkgJiYgb3B0aW9ucy5lbnRyb3B5RW5jIHx8ICd1dGY4JyxcbiAgICBub25jZTogdGhpcy5uLnRvQXJyYXkoKSxcbiAgfSk7XG5cbiAgdmFyIGJ5dGVzID0gdGhpcy5uLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIG5zMiA9IHRoaXMubi5zdWIobmV3IEJOKDIpKTtcbiAgZm9yICg7Oykge1xuICAgIHZhciBwcml2ID0gbmV3IEJOKGRyYmcuZ2VuZXJhdGUoYnl0ZXMpKTtcbiAgICBpZiAocHJpdi5jbXAobnMyKSA+IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHByaXYuaWFkZG4oMSk7XG4gICAgcmV0dXJuIHRoaXMua2V5RnJvbVByaXZhdGUocHJpdik7XG4gIH1cbn07XG5cbkVDLnByb3RvdHlwZS5fdHJ1bmNhdGVUb04gPSBmdW5jdGlvbiBfdHJ1bmNhdGVUb04obXNnLCB0cnVuY09ubHkpIHtcbiAgdmFyIGRlbHRhID0gbXNnLmJ5dGVMZW5ndGgoKSAqIDggLSB0aGlzLm4uYml0TGVuZ3RoKCk7XG4gIGlmIChkZWx0YSA+IDApXG4gICAgbXNnID0gbXNnLnVzaHJuKGRlbHRhKTtcbiAgaWYgKCF0cnVuY09ubHkgJiYgbXNnLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIG1zZy5zdWIodGhpcy5uKTtcbiAgZWxzZVxuICAgIHJldHVybiBtc2c7XG59O1xuXG5FQy5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obXNnLCBrZXksIGVuYywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGVuYyA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gZW5jO1xuICAgIGVuYyA9IG51bGw7XG4gIH1cbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fTtcblxuICBrZXkgPSB0aGlzLmtleUZyb21Qcml2YXRlKGtleSwgZW5jKTtcbiAgbXNnID0gdGhpcy5fdHJ1bmNhdGVUb04obmV3IEJOKG1zZywgMTYpKTtcblxuICAvLyBaZXJvLWV4dGVuZCBrZXkgdG8gcHJvdmlkZSBlbm91Z2ggZW50cm9weVxuICB2YXIgYnl0ZXMgPSB0aGlzLm4uYnl0ZUxlbmd0aCgpO1xuICB2YXIgYmtleSA9IGtleS5nZXRQcml2YXRlKCkudG9BcnJheSgnYmUnLCBieXRlcyk7XG5cbiAgLy8gWmVyby1leHRlbmQgbm9uY2UgdG8gaGF2ZSB0aGUgc2FtZSBieXRlIHNpemUgYXMgTlxuICB2YXIgbm9uY2UgPSBtc2cudG9BcnJheSgnYmUnLCBieXRlcyk7XG5cbiAgLy8gSW5zdGFudGlhdGUgSG1hY19EUkJHXG4gIHZhciBkcmJnID0gbmV3IGhtYWNEcmJnKHtcbiAgICBoYXNoOiB0aGlzLmhhc2gsXG4gICAgZW50cm9weTogYmtleSxcbiAgICBub25jZTogbm9uY2UsXG4gICAgcGVyczogb3B0aW9ucy5wZXJzLFxuICAgIHBlcnNFbmM6IG9wdGlvbnMucGVyc0VuYyB8fCAndXRmOCcsXG4gIH0pO1xuXG4gIC8vIE51bWJlciBvZiBieXRlcyB0byBnZW5lcmF0ZVxuICB2YXIgbnMxID0gdGhpcy5uLnN1YihuZXcgQk4oMSkpO1xuXG4gIGZvciAodmFyIGl0ZXIgPSAwOyA7IGl0ZXIrKykge1xuICAgIHZhciBrID0gb3B0aW9ucy5rID9cbiAgICAgIG9wdGlvbnMuayhpdGVyKSA6XG4gICAgICBuZXcgQk4oZHJiZy5nZW5lcmF0ZSh0aGlzLm4uYnl0ZUxlbmd0aCgpKSk7XG4gICAgayA9IHRoaXMuX3RydW5jYXRlVG9OKGssIHRydWUpO1xuICAgIGlmIChrLmNtcG4oMSkgPD0gMCB8fCBrLmNtcChuczEpID49IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBrcCA9IHRoaXMuZy5tdWwoayk7XG4gICAgaWYgKGtwLmlzSW5maW5pdHkoKSlcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIGtwWCA9IGtwLmdldFgoKTtcbiAgICB2YXIgciA9IGtwWC51bW9kKHRoaXMubik7XG4gICAgaWYgKHIuY21wbigwKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIHMgPSBrLmludm0odGhpcy5uKS5tdWwoci5tdWwoa2V5LmdldFByaXZhdGUoKSkuaWFkZChtc2cpKTtcbiAgICBzID0gcy51bW9kKHRoaXMubik7XG4gICAgaWYgKHMuY21wbigwKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIHJlY292ZXJ5UGFyYW0gPSAoa3AuZ2V0WSgpLmlzT2RkKCkgPyAxIDogMCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGtwWC5jbXAocikgIT09IDAgPyAyIDogMCk7XG5cbiAgICAvLyBVc2UgY29tcGxlbWVudCBvZiBgc2AsIGlmIGl0IGlzID4gYG4gLyAyYFxuICAgIGlmIChvcHRpb25zLmNhbm9uaWNhbCAmJiBzLmNtcCh0aGlzLm5oKSA+IDApIHtcbiAgICAgIHMgPSB0aGlzLm4uc3ViKHMpO1xuICAgICAgcmVjb3ZlcnlQYXJhbSBePSAxO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgc2lnbmF0dXJlKHsgcjogciwgczogcywgcmVjb3ZlcnlQYXJhbTogcmVjb3ZlcnlQYXJhbSB9KTtcbiAgfVxufTtcblxuRUMucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSQxLCBrZXksIGVuYykge1xuICBtc2cgPSB0aGlzLl90cnVuY2F0ZVRvTihuZXcgQk4obXNnLCAxNikpO1xuICBrZXkgPSB0aGlzLmtleUZyb21QdWJsaWMoa2V5LCBlbmMpO1xuICBzaWduYXR1cmUkMSA9IG5ldyBzaWduYXR1cmUoc2lnbmF0dXJlJDEsICdoZXgnKTtcblxuICAvLyBQZXJmb3JtIHByaW1pdGl2ZSB2YWx1ZXMgdmFsaWRhdGlvblxuICB2YXIgciA9IHNpZ25hdHVyZSQxLnI7XG4gIHZhciBzID0gc2lnbmF0dXJlJDEucztcbiAgaWYgKHIuY21wbigxKSA8IDAgfHwgci5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHMuY21wbigxKSA8IDAgfHwgcy5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBWYWxpZGF0ZSBzaWduYXR1cmVcbiAgdmFyIHNpbnYgPSBzLmludm0odGhpcy5uKTtcbiAgdmFyIHUxID0gc2ludi5tdWwobXNnKS51bW9kKHRoaXMubik7XG4gIHZhciB1MiA9IHNpbnYubXVsKHIpLnVtb2QodGhpcy5uKTtcbiAgdmFyIHA7XG5cbiAgaWYgKCF0aGlzLmN1cnZlLl9tYXh3ZWxsVHJpY2spIHtcbiAgICBwID0gdGhpcy5nLm11bEFkZCh1MSwga2V5LmdldFB1YmxpYygpLCB1Mik7XG4gICAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHAuZ2V0WCgpLnVtb2QodGhpcy5uKS5jbXAocikgPT09IDA7XG4gIH1cblxuICAvLyBOT1RFOiBHcmVnIE1heHdlbGwncyB0cmljaywgaW5zcGlyZWQgYnk6XG4gIC8vIGh0dHBzOi8vZ2l0LmlvL3ZhZDNLXG5cbiAgcCA9IHRoaXMuZy5qbXVsQWRkKHUxLCBrZXkuZ2V0UHVibGljKCksIHUyKTtcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBDb21wYXJlIGBwLnhgIG9mIEphY29iaWFuIHBvaW50IHdpdGggYHJgLFxuICAvLyB0aGlzIHdpbGwgZG8gYHAueCA9PSByICogcC56XjJgIGluc3RlYWQgb2YgbXVsdGlwbHlpbmcgYHAueGAgYnkgdGhlXG4gIC8vIGludmVyc2Ugb2YgYHAuel4yYFxuICByZXR1cm4gcC5lcVhUb1Aocik7XG59O1xuXG5FQy5wcm90b3R5cGUucmVjb3ZlclB1YktleSA9IGZ1bmN0aW9uKG1zZywgc2lnbmF0dXJlJDEsIGosIGVuYykge1xuICBhc3NlcnQkNSgoMyAmIGopID09PSBqLCAnVGhlIHJlY292ZXJ5IHBhcmFtIGlzIG1vcmUgdGhhbiB0d28gYml0cycpO1xuICBzaWduYXR1cmUkMSA9IG5ldyBzaWduYXR1cmUoc2lnbmF0dXJlJDEsIGVuYyk7XG5cbiAgdmFyIG4gPSB0aGlzLm47XG4gIHZhciBlID0gbmV3IEJOKG1zZyk7XG4gIHZhciByID0gc2lnbmF0dXJlJDEucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUkMS5zO1xuXG4gIC8vIEEgc2V0IExTQiBzaWduaWZpZXMgdGhhdCB0aGUgeS1jb29yZGluYXRlIGlzIG9kZFxuICB2YXIgaXNZT2RkID0gaiAmIDE7XG4gIHZhciBpc1NlY29uZEtleSA9IGogPj4gMTtcbiAgaWYgKHIuY21wKHRoaXMuY3VydmUucC51bW9kKHRoaXMuY3VydmUubikpID49IDAgJiYgaXNTZWNvbmRLZXkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBzZW5jb25kIGtleSBjYW5kaW5hdGUnKTtcblxuICAvLyAxLjEuIExldCB4ID0gciArIGpuLlxuICBpZiAoaXNTZWNvbmRLZXkpXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLmFkZCh0aGlzLmN1cnZlLm4pLCBpc1lPZGQpO1xuICBlbHNlXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLCBpc1lPZGQpO1xuXG4gIHZhciBySW52ID0gc2lnbmF0dXJlJDEuci5pbnZtKG4pO1xuICB2YXIgczEgPSBuLnN1YihlKS5tdWwockludikudW1vZChuKTtcbiAgdmFyIHMyID0gcy5tdWwockludikudW1vZChuKTtcblxuICAvLyAxLjYuMSBDb21wdXRlIFEgPSByXi0xIChzUiAtICBlRylcbiAgLy8gICAgICAgICAgICAgICBRID0gcl4tMSAoc1IgKyAtZUcpXG4gIHJldHVybiB0aGlzLmcubXVsQWRkKHMxLCByLCBzMik7XG59O1xuXG5FQy5wcm90b3R5cGUuZ2V0S2V5UmVjb3ZlcnlQYXJhbSA9IGZ1bmN0aW9uKGUsIHNpZ25hdHVyZSQxLCBRLCBlbmMpIHtcbiAgc2lnbmF0dXJlJDEgPSBuZXcgc2lnbmF0dXJlKHNpZ25hdHVyZSQxLCBlbmMpO1xuICBpZiAoc2lnbmF0dXJlJDEucmVjb3ZlcnlQYXJhbSAhPT0gbnVsbClcbiAgICByZXR1cm4gc2lnbmF0dXJlJDEucmVjb3ZlcnlQYXJhbTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBRcHJpbWU7XG4gICAgdHJ5IHtcbiAgICAgIFFwcmltZSA9IHRoaXMucmVjb3ZlclB1YktleShlLCBzaWduYXR1cmUkMSwgaSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKFFwcmltZS5lcShRKSlcbiAgICAgIHJldHVybiBpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgdmFsaWQgcmVjb3ZlcnkgZmFjdG9yJyk7XG59O1xuXG52YXIgZWxsaXB0aWNfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIGVsbGlwdGljID0gZXhwb3J0cztcblxuZWxsaXB0aWMudmVyc2lvbiA9IC8qUmljTW9vOmV0aGVycyoveyB2ZXJzaW9uOiBcIjYuNS40XCIgfS52ZXJzaW9uO1xuZWxsaXB0aWMudXRpbHMgPSB1dGlsc18xJDE7XG5lbGxpcHRpYy5yYW5kID0gLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoYnJvcmFuZCkqLyhmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCcpOyB9KTtcbmVsbGlwdGljLmN1cnZlID0gY3VydmVfMTtcbmVsbGlwdGljLmN1cnZlcyA9IGN1cnZlc18xO1xuXG4vLyBQcm90b2NvbHNcbmVsbGlwdGljLmVjID0gZWM7XG5lbGxpcHRpYy5lZGRzYSA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vZWxsaXB0aWMvZWRkc2EpKi8obnVsbCk7XG59KTtcblxudmFyIEVDJDEgPSBlbGxpcHRpY18xLmVjO1xuXG5leHBvcnQgeyBFQyQxIGFzIEVDIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGxpcHRpYy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJCTiIsImhhc2giLCJjb21tb25qc0dsb2JhbCIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJnbG9iYWwiLCJzZWxmIiwiZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMiLCJ4IiwiX19lc01vZHVsZSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImNyZWF0ZUNvbW1vbmpzTW9kdWxlIiwiZm4iLCJiYXNlZGlyIiwibW9kdWxlIiwicGF0aCIsImV4cG9ydHMiLCJyZXF1aXJlIiwiYmFzZSIsImNvbW1vbmpzUmVxdWlyZSIsInVuZGVmaW5lZCIsImdldERlZmF1bHRFeHBvcnRGcm9tTmFtZXNwYWNlSWZQcmVzZW50IiwibiIsImdldERlZmF1bHRFeHBvcnRGcm9tTmFtZXNwYWNlSWZOb3ROYW1lZCIsImtleXMiLCJsZW5ndGgiLCJnZXRBdWdtZW50ZWROYW1lc3BhY2UiLCJhIiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImZvckVhY2giLCJrIiwiZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsImVudW1lcmFibGUiLCJFcnJvciIsIm1pbmltYWxpc3RpY0Fzc2VydCIsImFzc2VydCIsInZhbCIsIm1zZyIsImVxdWFsIiwiYXNzZXJ0RXF1YWwiLCJsIiwiciIsInV0aWxzXzEiLCJ1dGlscyIsInRvQXJyYXkiLCJlbmMiLCJBcnJheSIsImlzQXJyYXkiLCJzbGljZSIsInJlcyIsImkiLCJyZXBsYWNlIiwicHVzaCIsInBhcnNlSW50IiwiYyIsImNoYXJDb2RlQXQiLCJoaSIsImxvIiwiemVybzIiLCJ3b3JkIiwidG9IZXgiLCJ0b1N0cmluZyIsImVuY29kZSIsImFyciIsInV0aWxzXzEkMSIsImdldE5BRiIsIm51bSIsInciLCJiaXRzIiwibmFmIiwiTWF0aCIsIm1heCIsImJpdExlbmd0aCIsImZpbGwiLCJ3cyIsImNsb25lIiwieiIsIm1vZCIsImFuZGxuIiwiaXNPZGQiLCJpc3VibiIsIml1c2hybiIsImdldEpTRiIsImsxIiwiazIiLCJqc2YiLCJkMSIsImQyIiwibTgiLCJjbXBuIiwibTE0IiwibTI0IiwidTEiLCJ1MiIsImNhY2hlZFByb3BlcnR5Iiwib2JqIiwibmFtZSIsImNvbXB1dGVyIiwia2V5IiwicGFyc2VCeXRlcyIsImJ5dGVzIiwiaW50RnJvbUxFIiwiYXNzZXJ0JDEiLCJCYXNlQ3VydmUiLCJ0eXBlIiwiY29uZiIsInAiLCJyZWQiLCJwcmltZSIsIm1vbnQiLCJ6ZXJvIiwidG9SZWQiLCJvbmUiLCJ0d28iLCJnIiwicG9pbnRGcm9tSlNPTiIsImdSZWQiLCJfd25hZlQxIiwiX3duYWZUMiIsIl93bmFmVDMiLCJfd25hZlQ0IiwiX2JpdExlbmd0aCIsImFkanVzdENvdW50IiwiZGl2IiwicmVkTiIsIl9tYXh3ZWxsVHJpY2siLCJwb2ludCIsInZhbGlkYXRlIiwiX2ZpeGVkTmFmTXVsIiwicHJlY29tcHV0ZWQiLCJkb3VibGVzIiwiX2dldERvdWJsZXMiLCJJIiwic3RlcCIsInJlcHIiLCJqIiwibmFmVyIsImpwb2ludCIsImIiLCJtaXhlZEFkZCIsInBvaW50cyIsIm5lZyIsImFkZCIsInRvUCIsIl93bmFmTXVsIiwibmFmUG9pbnRzIiwiX2dldE5BRlBvaW50cyIsInduZCIsImFjYyIsImRibHAiLCJfd25hZk11bEFkZCIsImRlZlciLCJjb2VmZnMiLCJsZW4iLCJqYWNvYmlhblJlc3VsdCIsInduZFdpZHRoIiwiY29tYiIsInkiLCJjbXAiLCJ0b0oiLCJyZWROZWciLCJpbmRleCIsImphIiwiamIiLCJ0bXAiLCJCYXNlUG9pbnQiLCJjdXJ2ZSIsImVxIiwiZGVjb2RlUG9pbnQiLCJieXRlTGVuZ3RoIiwicG9pbnRGcm9tWCIsImVuY29kZUNvbXByZXNzZWQiLCJfZW5jb2RlIiwiY29tcGFjdCIsImdldFgiLCJnZXRZIiwiaXNFdmVuIiwiY29uY2F0IiwicHJlY29tcHV0ZSIsInBvd2VyIiwiYmV0YSIsIl9nZXRCZXRhIiwiX2hhc0RvdWJsZXMiLCJjZWlsIiwiZGJsIiwiaW5oZXJpdHNfYnJvd3NlciIsImNyZWF0ZSIsImluaGVyaXRzIiwiY3RvciIsInN1cGVyQ3RvciIsInN1cGVyXyIsImNvbnN0cnVjdG9yIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJUZW1wQ3RvciIsImFzc2VydCQyIiwiU2hvcnRDdXJ2ZSIsInRpbnYiLCJyZWRJbnZtIiwiemVyb0EiLCJmcm9tUmVkIiwidGhyZWVBIiwic3ViIiwiZW5kbyIsIl9nZXRFbmRvbW9ycGhpc20iLCJfZW5kb1duYWZUMSIsIl9lbmRvV25hZlQyIiwic2hvcnRfMSIsIm1vZG4iLCJsYW1iZGEiLCJiZXRhcyIsIl9nZXRFbmRvUm9vdHMiLCJsYW1iZGFzIiwibXVsIiwicmVkTXVsIiwiYmFzaXMiLCJtYXAiLCJ2ZWMiLCJfZ2V0RW5kb0Jhc2lzIiwibnRpbnYiLCJzIiwicmVkU3FydCIsImwxIiwicmVkQWRkIiwibDIiLCJyZWRTdWIiLCJhcHJ4U3FydCIsInVzaHJuIiwiZmxvb3IiLCJ1IiwidiIsIngxIiwieTEiLCJ4MiIsInkyIiwiYTAiLCJiMCIsImExIiwiYjEiLCJhMiIsImIyIiwicHJldlIiLCJxIiwibGVuMSIsInNxciIsImxlbjIiLCJuZWdhdGl2ZSIsIl9lbmRvU3BsaXQiLCJ2MSIsInYyIiwiYzEiLCJkaXZSb3VuZCIsImMyIiwicDEiLCJwMiIsInExIiwicTIiLCJvZGQiLCJyZWRTcXIiLCJyZWRJQWRkIiwiaW5mIiwiYXgiLCJyaHMiLCJyZWRJU3ViIiwiX2VuZG9XbmFmTXVsQWRkIiwibnBvaW50cyIsIm5jb2VmZnMiLCJzcGxpdCIsImluZWciLCJQb2ludCIsImlzUmVkIiwiZm9yY2VSZWQiLCJmcm9tSlNPTiIsInByZSIsImVuZG9NdWwiLCJ0b0pTT04iLCJKU09OIiwicGFyc2UiLCJvYmoycG9pbnQiLCJpbnNwZWN0IiwiaXNJbmZpbml0eSIsIm54IiwibnkiLCJ5czEiLCJkeWludiIsIm11bEFkZCIsImptdWxBZGQiLCJfcHJlY29tcHV0ZSIsIm5lZ2F0ZSIsIkpQb2ludCIsInpPbmUiLCJ6aW52IiwiemludjIiLCJheSIsInB6MiIsInoyIiwiczEiLCJzMiIsImgiLCJoMiIsImgzIiwibnoiLCJwb3ciLCJqeCIsImp5IiwianoiLCJqejQiLCJqeWQiLCJqeDIiLCJqeWQyIiwianlkNCIsInQxIiwidDIiLCJkbnkiLCJfemVyb0RibCIsIl90aHJlZURibCIsIl9kYmwiLCJ4eCIsInl5IiwieXl5eSIsIm0iLCJ0IiwieXl5eTgiLCJlIiwiZiIsImM4IiwiZGVsdGEiLCJnYW1tYSIsImFscGhhIiwiYmV0YTQiLCJiZXRhOCIsImdnYW1tYTgiLCJqeTIiLCJqeGQ0IiwianlkOCIsInRycGwiLCJ6eiIsIm1tIiwiZWUiLCJ5eXU0Iiwia2Jhc2UiLCJ6MyIsInB6MyIsImVxWFRvUCIsInpzIiwicngiLCJ4YyIsImlhZGQiLCJjdXJ2ZV8xIiwic2hvcnQiLCJlZHdhcmRzIiwiY3VydmVzXzEiLCJjdXJ2ZXMiLCJQcmVzZXRDdXJ2ZSIsIm9wdGlvbnMiLCJkZWZpbmVDdXJ2ZSIsInNoYTI1NiIsInNoYTM4NCIsInNoYTUxMiIsImNyYXNoIiwiSG1hY0RSQkciLCJwcmVkUmVzaXN0Iiwib3V0TGVuIiwib3V0U2l6ZSIsIm1pbkVudHJvcHkiLCJobWFjU3RyZW5ndGgiLCJfcmVzZWVkIiwicmVzZWVkSW50ZXJ2YWwiLCJLIiwiViIsImVudHJvcHkiLCJlbnRyb3B5RW5jIiwibm9uY2UiLCJub25jZUVuYyIsInBlcnMiLCJwZXJzRW5jIiwiX2luaXQiLCJobWFjRHJiZyIsImluaXQiLCJzZWVkIiwiX3VwZGF0ZSIsIl9obWFjIiwiaG1hYyIsInVwZGF0ZSIsImttYWMiLCJkaWdlc3QiLCJyZXNlZWQiLCJhZGRFbmMiLCJnZW5lcmF0ZSIsInRlbXAiLCJhc3NlcnQkMyIsIktleVBhaXIiLCJlYyIsInByaXYiLCJwdWIiLCJfaW1wb3J0UHJpdmF0ZSIsInByaXZFbmMiLCJfaW1wb3J0UHVibGljIiwicHViRW5jIiwiZnJvbVB1YmxpYyIsImZyb21Qcml2YXRlIiwiZ2V0UHVibGljIiwicmVzdWx0IiwicmVhc29uIiwiZ2V0UHJpdmF0ZSIsInVtb2QiLCJkZXJpdmUiLCJzaWduIiwidmVyaWZ5Iiwic2lnbmF0dXJlIiwiYXNzZXJ0JDQiLCJTaWduYXR1cmUiLCJfaW1wb3J0REVSIiwicmVjb3ZlcnlQYXJhbSIsIlBvc2l0aW9uIiwicGxhY2UiLCJnZXRMZW5ndGgiLCJidWYiLCJpbml0aWFsIiwib2N0ZXRMZW4iLCJvZmYiLCJybVBhZGRpbmciLCJkYXRhIiwicmxlbiIsInNsZW4iLCJjb25zdHJ1Y3RMZW5ndGgiLCJvY3RldHMiLCJsb2ciLCJMTjIiLCJ0b0RFUiIsImJhY2tIYWxmIiwicmFuZCIsImFzc2VydCQ1IiwiRUMiLCJuaCIsImtleVBhaXIiLCJrZXlGcm9tUHJpdmF0ZSIsImtleUZyb21QdWJsaWMiLCJnZW5LZXlQYWlyIiwiZHJiZyIsIm5zMiIsImlhZGRuIiwiX3RydW5jYXRlVG9OIiwidHJ1bmNPbmx5IiwiYmtleSIsIm5zMSIsIml0ZXIiLCJrcCIsImtwWCIsImludm0iLCJjYW5vbmljYWwiLCJzaWduYXR1cmUkMSIsInNpbnYiLCJyZWNvdmVyUHViS2V5IiwiaXNZT2RkIiwiaXNTZWNvbmRLZXkiLCJySW52IiwiZ2V0S2V5UmVjb3ZlcnlQYXJhbSIsIlEiLCJRcHJpbWUiLCJlbGxpcHRpY18xIiwiZWxsaXB0aWMiLCJ2ZXJzaW9uIiwiZWRkc2EiLCJFQyQxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/signing-key/lib.esm/elliptic.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/signing-key/lib.esm/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersproject/signing-key/lib.esm/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SigningKey: () => (/* binding */ SigningKey),\n/* harmony export */   computePublicKey: () => (/* binding */ computePublicKey),\n/* harmony export */   recoverPublicKey: () => (/* binding */ recoverPublicKey)\n/* harmony export */ });\n/* harmony import */ var _elliptic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./elliptic */ \"(ssr)/./node_modules/@ethersproject/signing-key/lib.esm/elliptic.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/signing-key/lib.esm/_version.js\");\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nlet _curve = null;\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new _elliptic__WEBPACK_IMPORTED_MODULE_2__.EC(\"secp256k1\");\n    }\n    return _curve;\n}\nclass SigningKey {\n    constructor(privateKey){\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"curve\", \"secp256k1\");\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"privateKey\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(privateKey));\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexDataLength)(this.privateKey) !== 32) {\n            logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n        const keyPair = getCurve().keyFromPrivate((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.privateKey));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, \"_isSigningKey\", true);\n    }\n    _addPoint(other) {\n        const p0 = getCurve().keyFromPublic((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.publicKey));\n        const p1 = getCurve().keyFromPublic((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n    signDigest(digest) {\n        const keyPair = getCurve().keyFromPrivate((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.privateKey));\n        const digestBytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, {\n            canonical: true\n        });\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.splitSignature)({\n            recoveryParam: signature.recoveryParam,\n            r: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexZeroPad)(\"0x\" + signature.r.toString(16), 32),\n            s: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexZeroPad)(\"0x\" + signature.s.toString(16), 32)\n        });\n    }\n    computeSharedSecret(otherKey) {\n        const keyPair = getCurve().keyFromPrivate((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(computePublicKey(otherKey)));\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexZeroPad)(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n    static isSigningKey(value) {\n        return !!(value && value._isSigningKey);\n    }\n}\nfunction recoverPublicKey(digest, signature) {\n    const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.splitSignature)(signature);\n    const rs = {\n        r: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(sig.r),\n        s: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(sig.s)\n    };\n    return \"0x\" + getCurve().recoverPubKey((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\nfunction computePublicKey(key, compressed) {\n    const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(key);\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n    } else if (bytes.length === 33) {\n        if (compressed) {\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n    } else if (bytes.length === 65) {\n        if (!compressed) {\n            return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2lnbmluZy1rZXkvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFhO0FBQ21CO0FBQ29FO0FBQ3pDO0FBQ1o7QUFDVjtBQUNyQyxNQUFNUyxTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDakMsSUFBSUUsU0FBUztBQUNiLFNBQVNDO0lBQ0wsSUFBSSxDQUFDRCxRQUFRO1FBQ1RBLFNBQVMsSUFBSVYseUNBQUVBLENBQUM7SUFDcEI7SUFDQSxPQUFPVTtBQUNYO0FBQ08sTUFBTUU7SUFDVEMsWUFBWUMsVUFBVSxDQUFFO1FBQ3BCUix5RUFBY0EsQ0FBQyxJQUFJLEVBQUUsU0FBUztRQUM5QkEseUVBQWNBLENBQUMsSUFBSSxFQUFFLGNBQWNILDZEQUFPQSxDQUFDVztRQUMzQyxJQUFJWixtRUFBYUEsQ0FBQyxJQUFJLENBQUNZLFVBQVUsTUFBTSxJQUFJO1lBQ3ZDTCxPQUFPTSxrQkFBa0IsQ0FBQyx1QkFBdUIsY0FBYztRQUNuRTtRQUNBLE1BQU1DLFVBQVVMLFdBQVdNLGNBQWMsQ0FBQ2hCLDhEQUFRQSxDQUFDLElBQUksQ0FBQ2EsVUFBVTtRQUNsRVIseUVBQWNBLENBQUMsSUFBSSxFQUFFLGFBQWEsT0FBT1UsUUFBUUUsU0FBUyxDQUFDLE9BQU87UUFDbEVaLHlFQUFjQSxDQUFDLElBQUksRUFBRSx1QkFBdUIsT0FBT1UsUUFBUUUsU0FBUyxDQUFDLE1BQU07UUFDM0VaLHlFQUFjQSxDQUFDLElBQUksRUFBRSxpQkFBaUI7SUFDMUM7SUFDQWEsVUFBVUMsS0FBSyxFQUFFO1FBQ2IsTUFBTUMsS0FBS1YsV0FBV1csYUFBYSxDQUFDckIsOERBQVFBLENBQUMsSUFBSSxDQUFDc0IsU0FBUztRQUMzRCxNQUFNQyxLQUFLYixXQUFXVyxhQUFhLENBQUNyQiw4REFBUUEsQ0FBQ21CO1FBQzdDLE9BQU8sT0FBT0MsR0FBR0ksR0FBRyxDQUFDQyxHQUFHLENBQUNGLEdBQUdDLEdBQUcsRUFBRUUsZ0JBQWdCLENBQUM7SUFDdEQ7SUFDQUMsV0FBV0MsTUFBTSxFQUFFO1FBQ2YsTUFBTWIsVUFBVUwsV0FBV00sY0FBYyxDQUFDaEIsOERBQVFBLENBQUMsSUFBSSxDQUFDYSxVQUFVO1FBQ2xFLE1BQU1nQixjQUFjN0IsOERBQVFBLENBQUM0QjtRQUM3QixJQUFJQyxZQUFZQyxNQUFNLEtBQUssSUFBSTtZQUMzQnRCLE9BQU9NLGtCQUFrQixDQUFDLHFCQUFxQixVQUFVYztRQUM3RDtRQUNBLE1BQU1HLFlBQVloQixRQUFRaUIsSUFBSSxDQUFDSCxhQUFhO1lBQUVJLFdBQVc7UUFBSztRQUM5RCxPQUFPN0Isb0VBQWNBLENBQUM7WUFDbEI4QixlQUFlSCxVQUFVRyxhQUFhO1lBQ3RDQyxHQUFHaEMsZ0VBQVVBLENBQUMsT0FBTzRCLFVBQVVJLENBQUMsQ0FBQ0MsUUFBUSxDQUFDLEtBQUs7WUFDL0NDLEdBQUdsQyxnRUFBVUEsQ0FBQyxPQUFPNEIsVUFBVU0sQ0FBQyxDQUFDRCxRQUFRLENBQUMsS0FBSztRQUNuRDtJQUNKO0lBQ0FFLG9CQUFvQkMsUUFBUSxFQUFFO1FBQzFCLE1BQU14QixVQUFVTCxXQUFXTSxjQUFjLENBQUNoQiw4REFBUUEsQ0FBQyxJQUFJLENBQUNhLFVBQVU7UUFDbEUsTUFBTTJCLGVBQWU5QixXQUFXVyxhQUFhLENBQUNyQiw4REFBUUEsQ0FBQ3lDLGlCQUFpQkY7UUFDeEUsT0FBT3BDLGdFQUFVQSxDQUFDLE9BQU9ZLFFBQVEyQixNQUFNLENBQUNGLGFBQWF2QixTQUFTLElBQUltQixRQUFRLENBQUMsS0FBSztJQUNwRjtJQUNBLE9BQU9PLGFBQWFDLEtBQUssRUFBRTtRQUN2QixPQUFPLENBQUMsQ0FBRUEsQ0FBQUEsU0FBU0EsTUFBTUMsYUFBYTtJQUMxQztBQUNKO0FBQ08sU0FBU0MsaUJBQWlCbEIsTUFBTSxFQUFFRyxTQUFTO0lBQzlDLE1BQU1nQixNQUFNM0Msb0VBQWNBLENBQUMyQjtJQUMzQixNQUFNaUIsS0FBSztRQUFFYixHQUFHbkMsOERBQVFBLENBQUMrQyxJQUFJWixDQUFDO1FBQUdFLEdBQUdyQyw4REFBUUEsQ0FBQytDLElBQUlWLENBQUM7SUFBRTtJQUNwRCxPQUFPLE9BQU8zQixXQUFXdUMsYUFBYSxDQUFDakQsOERBQVFBLENBQUM0QixTQUFTb0IsSUFBSUQsSUFBSWIsYUFBYSxFQUFFZ0IsTUFBTSxDQUFDLE9BQU87QUFDbEc7QUFDTyxTQUFTVCxpQkFBaUJVLEdBQUcsRUFBRUMsVUFBVTtJQUM1QyxNQUFNQyxRQUFRckQsOERBQVFBLENBQUNtRDtJQUN2QixJQUFJRSxNQUFNdkIsTUFBTSxLQUFLLElBQUk7UUFDckIsTUFBTXdCLGFBQWEsSUFBSTNDLFdBQVcwQztRQUNsQyxJQUFJRCxZQUFZO1lBQ1osT0FBTyxPQUFPMUMsV0FBV00sY0FBYyxDQUFDcUMsT0FBT3BDLFNBQVMsQ0FBQyxNQUFNO1FBQ25FO1FBQ0EsT0FBT3FDLFdBQVdoQyxTQUFTO0lBQy9CLE9BQ0ssSUFBSStCLE1BQU12QixNQUFNLEtBQUssSUFBSTtRQUMxQixJQUFJc0IsWUFBWTtZQUNaLE9BQU9sRCw2REFBT0EsQ0FBQ21EO1FBQ25CO1FBQ0EsT0FBTyxPQUFPM0MsV0FBV1csYUFBYSxDQUFDZ0MsT0FBT3BDLFNBQVMsQ0FBQyxPQUFPO0lBQ25FLE9BQ0ssSUFBSW9DLE1BQU12QixNQUFNLEtBQUssSUFBSTtRQUMxQixJQUFJLENBQUNzQixZQUFZO1lBQ2IsT0FBT2xELDZEQUFPQSxDQUFDbUQ7UUFDbkI7UUFDQSxPQUFPLE9BQU8zQyxXQUFXVyxhQUFhLENBQUNnQyxPQUFPcEMsU0FBUyxDQUFDLE1BQU07SUFDbEU7SUFDQSxPQUFPVCxPQUFPTSxrQkFBa0IsQ0FBQyxpQ0FBaUMsT0FBTztBQUM3RSxFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2lnbmluZy1rZXkvbGliLmVzbS9pbmRleC5qcz8yMmJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgRUMgfSBmcm9tIFwiLi9lbGxpcHRpY1wiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleERhdGFMZW5ndGgsIGhleGxpZnksIGhleFplcm9QYWQsIHNwbGl0U2lnbmF0dXJlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5sZXQgX2N1cnZlID0gbnVsbDtcbmZ1bmN0aW9uIGdldEN1cnZlKCkge1xuICAgIGlmICghX2N1cnZlKSB7XG4gICAgICAgIF9jdXJ2ZSA9IG5ldyBFQyhcInNlY3AyNTZrMVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIF9jdXJ2ZTtcbn1cbmV4cG9ydCBjbGFzcyBTaWduaW5nS2V5IHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlS2V5KSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY3VydmVcIiwgXCJzZWNwMjU2azFcIik7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJpdmF0ZUtleVwiLCBoZXhsaWZ5KHByaXZhdGVLZXkpKTtcbiAgICAgICAgaWYgKGhleERhdGFMZW5ndGgodGhpcy5wcml2YXRlS2V5KSAhPT0gMzIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHByaXZhdGUga2V5XCIsIFwicHJpdmF0ZUtleVwiLCBcIltbIFJFREFDVEVEIF1dXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleVBhaXIgPSBnZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKGFycmF5aWZ5KHRoaXMucHJpdmF0ZUtleSkpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInB1YmxpY0tleVwiLCBcIjB4XCIgKyBrZXlQYWlyLmdldFB1YmxpYyhmYWxzZSwgXCJoZXhcIikpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImNvbXByZXNzZWRQdWJsaWNLZXlcIiwgXCIweFwiICsga2V5UGFpci5nZXRQdWJsaWModHJ1ZSwgXCJoZXhcIikpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9pc1NpZ25pbmdLZXlcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIF9hZGRQb2ludChvdGhlcikge1xuICAgICAgICBjb25zdCBwMCA9IGdldEN1cnZlKCkua2V5RnJvbVB1YmxpYyhhcnJheWlmeSh0aGlzLnB1YmxpY0tleSkpO1xuICAgICAgICBjb25zdCBwMSA9IGdldEN1cnZlKCkua2V5RnJvbVB1YmxpYyhhcnJheWlmeShvdGhlcikpO1xuICAgICAgICByZXR1cm4gXCIweFwiICsgcDAucHViLmFkZChwMS5wdWIpLmVuY29kZUNvbXByZXNzZWQoXCJoZXhcIik7XG4gICAgfVxuICAgIHNpZ25EaWdlc3QoZGlnZXN0KSB7XG4gICAgICAgIGNvbnN0IGtleVBhaXIgPSBnZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKGFycmF5aWZ5KHRoaXMucHJpdmF0ZUtleSkpO1xuICAgICAgICBjb25zdCBkaWdlc3RCeXRlcyA9IGFycmF5aWZ5KGRpZ2VzdCk7XG4gICAgICAgIGlmIChkaWdlc3RCeXRlcy5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYmFkIGRpZ2VzdCBsZW5ndGhcIiwgXCJkaWdlc3RcIiwgZGlnZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBrZXlQYWlyLnNpZ24oZGlnZXN0Qnl0ZXMsIHsgY2Fub25pY2FsOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gc3BsaXRTaWduYXR1cmUoe1xuICAgICAgICAgICAgcmVjb3ZlcnlQYXJhbTogc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW0sXG4gICAgICAgICAgICByOiBoZXhaZXJvUGFkKFwiMHhcIiArIHNpZ25hdHVyZS5yLnRvU3RyaW5nKDE2KSwgMzIpLFxuICAgICAgICAgICAgczogaGV4WmVyb1BhZChcIjB4XCIgKyBzaWduYXR1cmUucy50b1N0cmluZygxNiksIDMyKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbXB1dGVTaGFyZWRTZWNyZXQob3RoZXJLZXkpIHtcbiAgICAgICAgY29uc3Qga2V5UGFpciA9IGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUoYXJyYXlpZnkodGhpcy5wcml2YXRlS2V5KSk7XG4gICAgICAgIGNvbnN0IG90aGVyS2V5UGFpciA9IGdldEN1cnZlKCkua2V5RnJvbVB1YmxpYyhhcnJheWlmeShjb21wdXRlUHVibGljS2V5KG90aGVyS2V5KSkpO1xuICAgICAgICByZXR1cm4gaGV4WmVyb1BhZChcIjB4XCIgKyBrZXlQYWlyLmRlcml2ZShvdGhlcktleVBhaXIuZ2V0UHVibGljKCkpLnRvU3RyaW5nKDE2KSwgMzIpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNTaWduaW5nS2V5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNTaWduaW5nS2V5KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHNpZyA9IHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgY29uc3QgcnMgPSB7IHI6IGFycmF5aWZ5KHNpZy5yKSwgczogYXJyYXlpZnkoc2lnLnMpIH07XG4gICAgcmV0dXJuIFwiMHhcIiArIGdldEN1cnZlKCkucmVjb3ZlclB1YktleShhcnJheWlmeShkaWdlc3QpLCBycywgc2lnLnJlY292ZXJ5UGFyYW0pLmVuY29kZShcImhleFwiLCBmYWxzZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVB1YmxpY0tleShrZXksIGNvbXByZXNzZWQpIHtcbiAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KGtleSk7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgY29uc3Qgc2lnbmluZ0tleSA9IG5ldyBTaWduaW5nS2V5KGJ5dGVzKTtcbiAgICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjB4XCIgKyBnZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKGJ5dGVzKS5nZXRQdWJsaWModHJ1ZSwgXCJoZXhcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ25pbmdLZXkucHVibGljS2V5O1xuICAgIH1cbiAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPT09IDMzKSB7XG4gICAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIGdldEN1cnZlKCkua2V5RnJvbVB1YmxpYyhieXRlcykuZ2V0UHVibGljKGZhbHNlLCBcImhleFwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NSkge1xuICAgICAgICBpZiAoIWNvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGJ5dGVzKS5nZXRQdWJsaWModHJ1ZSwgXCJoZXhcIik7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBwdWJsaWMgb3IgcHJpdmF0ZSBrZXlcIiwgXCJrZXlcIiwgXCJbUkVEQUNURURdXCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIkVDIiwiYXJyYXlpZnkiLCJoZXhEYXRhTGVuZ3RoIiwiaGV4bGlmeSIsImhleFplcm9QYWQiLCJzcGxpdFNpZ25hdHVyZSIsImRlZmluZVJlYWRPbmx5IiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsIl9jdXJ2ZSIsImdldEN1cnZlIiwiU2lnbmluZ0tleSIsImNvbnN0cnVjdG9yIiwicHJpdmF0ZUtleSIsInRocm93QXJndW1lbnRFcnJvciIsImtleVBhaXIiLCJrZXlGcm9tUHJpdmF0ZSIsImdldFB1YmxpYyIsIl9hZGRQb2ludCIsIm90aGVyIiwicDAiLCJrZXlGcm9tUHVibGljIiwicHVibGljS2V5IiwicDEiLCJwdWIiLCJhZGQiLCJlbmNvZGVDb21wcmVzc2VkIiwic2lnbkRpZ2VzdCIsImRpZ2VzdCIsImRpZ2VzdEJ5dGVzIiwibGVuZ3RoIiwic2lnbmF0dXJlIiwic2lnbiIsImNhbm9uaWNhbCIsInJlY292ZXJ5UGFyYW0iLCJyIiwidG9TdHJpbmciLCJzIiwiY29tcHV0ZVNoYXJlZFNlY3JldCIsIm90aGVyS2V5Iiwib3RoZXJLZXlQYWlyIiwiY29tcHV0ZVB1YmxpY0tleSIsImRlcml2ZSIsImlzU2lnbmluZ0tleSIsInZhbHVlIiwiX2lzU2lnbmluZ0tleSIsInJlY292ZXJQdWJsaWNLZXkiLCJzaWciLCJycyIsInJlY292ZXJQdWJLZXkiLCJlbmNvZGUiLCJrZXkiLCJjb21wcmVzc2VkIiwiYnl0ZXMiLCJzaWduaW5nS2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/signing-key/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/strings/lib.esm/_version.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersproject/strings/lib.esm/_version.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"strings/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc3RyaW5ncy9saWIuZXNtL192ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSxVQUFVLGdCQUFnQixDQUN2QyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3N0cmluZ3MvbGliLmVzbS9fdmVyc2lvbi5qcz9iNGY0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJzdHJpbmdzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/strings/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/strings/lib.esm/utf8.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/strings/lib.esm/utf8.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnicodeNormalizationForm: () => (/* binding */ UnicodeNormalizationForm),\n/* harmony export */   Utf8ErrorFuncs: () => (/* binding */ Utf8ErrorFuncs),\n/* harmony export */   Utf8ErrorReason: () => (/* binding */ Utf8ErrorReason),\n/* harmony export */   _toEscapedUtf8String: () => (/* binding */ _toEscapedUtf8String),\n/* harmony export */   _toUtf8String: () => (/* binding */ _toUtf8String),\n/* harmony export */   toUtf8Bytes: () => (/* binding */ toUtf8Bytes),\n/* harmony export */   toUtf8CodePoints: () => (/* binding */ toUtf8CodePoints),\n/* harmony export */   toUtf8String: () => (/* binding */ toUtf8String)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/strings/lib.esm/_version.js\");\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n///////////////////////////////\nvar UnicodeNormalizationForm;\n(function(UnicodeNormalizationForm) {\n    UnicodeNormalizationForm[\"current\"] = \"\";\n    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));\n;\nvar Utf8ErrorReason;\n(function(Utf8ErrorReason) {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"UNEXPECTED_CONTINUE\"] = \"unexpected continuation byte\";\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"BAD_PREFIX\"] = \"bad codepoint prefix\";\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"OVERRUN\"] = \"string overrun\";\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    Utf8ErrorReason[\"MISSING_CONTINUE\"] = \"missing continuation byte\";\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    Utf8ErrorReason[\"OUT_OF_RANGE\"] = \"out of UTF-8 range\";\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    Utf8ErrorReason[\"UTF16_SURROGATE\"] = \"UTF-16 surrogate\";\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    Utf8ErrorReason[\"OVERLONG\"] = \"overlong representation\";\n})(Utf8ErrorReason || (Utf8ErrorReason = {}));\n;\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for(let o = offset + 1; o < bytes.length; o++){\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n// Common error handing strategies\nconst Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(bytes);\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while(i < bytes.length){\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & (1 << 8 - extraLength - 1) - 1;\n        for(let j = 0; j < extraLength; j++){\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = res << 6 | nextChar & 0x3f;\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nfunction toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n    let result = [];\n    for(let i = 0; i < str.length; i++){\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        } else if (c < 0x800) {\n            result.push(c >> 6 | 0xc0);\n            result.push(c & 0x3f | 0x80);\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push(pair >> 18 | 0xf0);\n            result.push(pair >> 12 & 0x3f | 0x80);\n            result.push(pair >> 6 & 0x3f | 0x80);\n            result.push(pair & 0x3f | 0x80);\n        } else {\n            result.push(c >> 12 | 0xe0);\n            result.push(c >> 6 & 0x3f | 0x80);\n            result.push(c & 0x3f | 0x80);\n        }\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(result);\n}\n;\nfunction escapeChar(value) {\n    const hex = \"0000\" + value.toString(16);\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\nfunction _toEscapedUtf8String(bytes, onError) {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint)=>{\n        if (codePoint < 256) {\n            switch(codePoint){\n                case 8:\n                    return \"\\\\b\";\n                case 9:\n                    return \"\\\\t\";\n                case 10:\n                    return \"\\\\n\";\n                case 13:\n                    return \"\\\\r\";\n                case 34:\n                    return '\\\\\"';\n                case 92:\n                    return \"\\\\\\\\\";\n            }\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n        codePoint -= 0x10000;\n        return escapeChar((codePoint >> 10 & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint)=>{\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\");\n}\nfunction toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\nfunction toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n} //# sourceMappingURL=utf8.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc3RyaW5ncy9saWIuZXNtL3V0ZjguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUNtQztBQUNEO0FBQ1Y7QUFDckMsTUFBTUcsU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BO0FBQ2pDLCtCQUErQjtBQUN4QixJQUFJRSx5QkFBeUI7QUFDbkMsVUFBVUEsd0JBQXdCO0lBQy9CQSx3QkFBd0IsQ0FBQyxVQUFVLEdBQUc7SUFDdENBLHdCQUF3QixDQUFDLE1BQU0sR0FBRztJQUNsQ0Esd0JBQXdCLENBQUMsTUFBTSxHQUFHO0lBQ2xDQSx3QkFBd0IsQ0FBQyxPQUFPLEdBQUc7SUFDbkNBLHdCQUF3QixDQUFDLE9BQU8sR0FBRztBQUN2QyxHQUFHQSw0QkFBNkJBLENBQUFBLDJCQUEyQixDQUFDOztBQUVyRCxJQUFJQyxnQkFBZ0I7QUFDMUIsVUFBVUEsZUFBZTtJQUN0QixzRUFBc0U7SUFDdEUsOENBQThDO0lBQzlDQSxlQUFlLENBQUMsc0JBQXNCLEdBQUc7SUFDekMsMEVBQTBFO0lBQzFFLDhDQUE4QztJQUM5Q0EsZUFBZSxDQUFDLGFBQWEsR0FBRztJQUNoQyw0REFBNEQ7SUFDNUQsOENBQThDO0lBQzlDQSxlQUFlLENBQUMsVUFBVSxHQUFHO0lBQzdCLHlEQUF5RDtJQUN6RCw2REFBNkQ7SUFDN0RBLGVBQWUsQ0FBQyxtQkFBbUIsR0FBRztJQUN0Qyx5REFBeUQ7SUFDekQsMkNBQTJDO0lBQzNDLG1FQUFtRTtJQUNuRUEsZUFBZSxDQUFDLGVBQWUsR0FBRztJQUNsQyx1REFBdUQ7SUFDdkQsMkNBQTJDO0lBQzNDLDZFQUE2RTtJQUM3RUEsZUFBZSxDQUFDLGtCQUFrQixHQUFHO0lBQ3JDLDJDQUEyQztJQUMzQywyQ0FBMkM7SUFDM0Msa0VBQWtFO0lBQ2xFQSxlQUFlLENBQUMsV0FBVyxHQUFHO0FBQ2xDLEdBQUdBLG1CQUFvQkEsQ0FBQUEsa0JBQWtCLENBQUM7O0FB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Y2pDLGtCQUFrQnBCLE9BQU9xQjtBQUNsRDtBQUNPLFNBQVNtQyxpQkFBaUJ2QixHQUFHLEVBQUVDLE9BQU92Qyx5QkFBeUJ3QyxPQUFPO0lBQ3pFLE9BQU9mLGtCQUFrQlksWUFBWUMsS0FBS0M7QUFDOUMsRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3N0cmluZ3MvbGliLmVzbS91dGY4LmpzPzE0NGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBhcnJheWlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IHZhciBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm07XG4oZnVuY3Rpb24gKFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSkge1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcImN1cnJlbnRcIl0gPSBcIlwiO1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GQ1wiXSA9IFwiTkZDXCI7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZEXCJdID0gXCJORkRcIjtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORktDXCJdID0gXCJORktDXCI7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZLRFwiXSA9IFwiTkZLRFwiO1xufSkoVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtIHx8IChVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gPSB7fSkpO1xuO1xuZXhwb3J0IHZhciBVdGY4RXJyb3JSZWFzb247XG4oZnVuY3Rpb24gKFV0ZjhFcnJvclJlYXNvbikge1xuICAgIC8vIEEgY29udGludWF0aW9uIGJ5dGUgd2FzIHByZXNlbnQgd2hlcmUgdGhlcmUgd2FzIG5vdGhpbmcgdG8gY29udGludWVcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG4gICAgVXRmOEVycm9yUmVhc29uW1wiVU5FWFBFQ1RFRF9DT05USU5VRVwiXSA9IFwidW5leHBlY3RlZCBjb250aW51YXRpb24gYnl0ZVwiO1xuICAgIC8vIEFuIGludmFsaWQgKG5vbi1jb250aW51YXRpb24pIGJ5dGUgdG8gc3RhcnQgYSBVVEYtOCBjb2RlcG9pbnQgd2FzIGZvdW5kXG4gICAgLy8gLSBvZmZzZXQgPSB0aGUgaW5kZXggdGhlIGNvZGVwb2ludCBiZWdhbiBpblxuICAgIFV0ZjhFcnJvclJlYXNvbltcIkJBRF9QUkVGSVhcIl0gPSBcImJhZCBjb2RlcG9pbnQgcHJlZml4XCI7XG4gICAgLy8gVGhlIHN0cmluZyBpcyB0b28gc2hvcnQgdG8gcHJvY2VzcyB0aGUgZXhwZWN0ZWQgY29kZXBvaW50XG4gICAgLy8gLSBvZmZzZXQgPSB0aGUgaW5kZXggdGhlIGNvZGVwb2ludCBiZWdhbiBpblxuICAgIFV0ZjhFcnJvclJlYXNvbltcIk9WRVJSVU5cIl0gPSBcInN0cmluZyBvdmVycnVuXCI7XG4gICAgLy8gQSBtaXNzaW5nIGNvbnRpbnVhdGlvbiBieXRlIHdhcyBleHBlY3RlZCBidXQgbm90IGZvdW5kXG4gICAgLy8gLSBvZmZzZXQgPSB0aGUgaW5kZXggdGhlIGNvbnRpbnVhdGlvbiBieXRlIHdhcyBleHBlY3RlZCBhdFxuICAgIFV0ZjhFcnJvclJlYXNvbltcIk1JU1NJTkdfQ09OVElOVUVcIl0gPSBcIm1pc3NpbmcgY29udGludWF0aW9uIGJ5dGVcIjtcbiAgICAvLyBUaGUgY29tcHV0ZWQgY29kZSBwb2ludCBpcyBvdXRzaWRlIHRoZSByYW5nZSBmb3IgVVRGLThcbiAgICAvLyAtIG9mZnNldCAgICAgICA9IHN0YXJ0IG9mIHRoaXMgY29kZXBvaW50XG4gICAgLy8gLSBiYWRDb2RlcG9pbnQgPSB0aGUgY29tcHV0ZWQgY29kZXBvaW50OyBvdXRzaWRlIHRoZSBVVEYtOCByYW5nZVxuICAgIFV0ZjhFcnJvclJlYXNvbltcIk9VVF9PRl9SQU5HRVwiXSA9IFwib3V0IG9mIFVURi04IHJhbmdlXCI7XG4gICAgLy8gVVRGLTggc3RyaW5ncyBtYXkgbm90IGNvbnRhaW4gVVRGLTE2IHN1cnJvZ2F0ZSBwYWlyc1xuICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcbiAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IGluc2lkZSB0aGUgVVRGLTE2IHN1cnJvZ2F0ZSByYW5nZVxuICAgIFV0ZjhFcnJvclJlYXNvbltcIlVURjE2X1NVUlJPR0FURVwiXSA9IFwiVVRGLTE2IHN1cnJvZ2F0ZVwiO1xuICAgIC8vIFRoZSBzdHJpbmcgaXMgYW4gb3ZlcmxvbmcgcmVwcmVzZW50YXRpb25cbiAgICAvLyAtIG9mZnNldCAgICAgICA9IHN0YXJ0IG9mIHRoaXMgY29kZXBvaW50XG4gICAgLy8gLSBiYWRDb2RlcG9pbnQgPSB0aGUgY29tcHV0ZWQgY29kZXBvaW50OyBhbHJlYWR5IGJvdW5kcyBjaGVja2VkXG4gICAgVXRmOEVycm9yUmVhc29uW1wiT1ZFUkxPTkdcIl0gPSBcIm92ZXJsb25nIHJlcHJlc2VudGF0aW9uXCI7XG59KShVdGY4RXJyb3JSZWFzb24gfHwgKFV0ZjhFcnJvclJlYXNvbiA9IHt9KSk7XG47XG5mdW5jdGlvbiBlcnJvckZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGNvZGVwb2ludCBhdCBvZmZzZXQgJHtvZmZzZXR9OyAke3JlYXNvbn1gLCBcImJ5dGVzXCIsIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIGludmFsaWQgcHJlZml4IChpbmNsdWRpbmcgc3RyYXkgY29udGludWF0aW9uKSwgc2tpcCBhbnkgYWRkaXRpb25hbCBjb250aW51YXRpb24gYnl0ZXNcbiAgICBpZiAocmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uQkFEX1BSRUZJWCB8fCByZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5VTkVYUEVDVEVEX0NPTlRJTlVFKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgbyA9IG9mZnNldCArIDE7IG8gPCBieXRlcy5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgaWYgKGJ5dGVzW29dID4+IDYgIT09IDB4MDIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgLy8gVGhpcyBieXRlIHJ1bnMgdXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHNvIGp1c3QganVtcCB0byB0aGUgZW5kXG4gICAgLy8gKGJ1dCB0aGUgZmlyc3QgYnl0ZSB3YXMgcmVhZCBhbHJlYWR5IHJlYWQgYW5kIHRoZXJlZm9yZSBza2lwcGVkKVxuICAgIGlmIChyZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5PVkVSUlVOKSB7XG4gICAgICAgIHJldHVybiBieXRlcy5sZW5ndGggLSBvZmZzZXQgLSAxO1xuICAgIH1cbiAgICAvLyBOb3RoaW5nIHRvIHNraXBcbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICAvLyBPdmVybG9uZyByZXByZXNlbnRhdGlvbnMgYXJlIG90aGVyd2lzZSBcInZhbGlkXCIgY29kZSBwb2ludHM7IGp1c3Qgbm9uLWRlaXN0aW5ndGlzaGVkXG4gICAgaWYgKHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLk9WRVJMT05HKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKGJhZENvZGVwb2ludCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLyBQdXQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpbnRvIHRoZSBvdXRwdXRcbiAgICBvdXRwdXQucHVzaCgweGZmZmQpO1xuICAgIC8vIE90aGVyd2lzZSwgcHJvY2VzcyBhcyBpZiBpZ25vcmluZyBlcnJvcnNcbiAgICByZXR1cm4gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KTtcbn1cbi8vIENvbW1vbiBlcnJvciBoYW5kaW5nIHN0cmF0ZWdpZXNcbmV4cG9ydCBjb25zdCBVdGY4RXJyb3JGdW5jcyA9IE9iamVjdC5mcmVlemUoe1xuICAgIGVycm9yOiBlcnJvckZ1bmMsXG4gICAgaWdub3JlOiBpZ25vcmVGdW5jLFxuICAgIHJlcGxhY2U6IHJlcGxhY2VGdW5jXG59KTtcbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMzNTY0OTMvZGVjb2RlLXV0Zi04LXdpdGgtamF2YXNjcmlwdCMxMzY5MTQ5OVxuZnVuY3Rpb24gZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpIHtcbiAgICBpZiAob25FcnJvciA9PSBudWxsKSB7XG4gICAgICAgIG9uRXJyb3IgPSBVdGY4RXJyb3JGdW5jcy5lcnJvcjtcbiAgICB9XG4gICAgYnl0ZXMgPSBhcnJheWlmeShieXRlcyk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vIEludmFsaWQgYnl0ZXMgYXJlIGlnbm9yZWRcbiAgICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgLy8gMHh4eCB4eHh4XG4gICAgICAgIGlmIChjID4+IDcgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlieXRlOyBob3cgbWFueSBieXRlcyBsZWZ0IGZvciB0aGlzIGNoYXJhY3Rlcj9cbiAgICAgICAgbGV0IGV4dHJhTGVuZ3RoID0gbnVsbDtcbiAgICAgICAgbGV0IG92ZXJsb25nTWFzayA9IG51bGw7XG4gICAgICAgIC8vIDExMHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgaWYgKChjICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMTtcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2Y7XG4gICAgICAgICAgICAvLyAxMTEwIHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMjtcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2ZmO1xuICAgICAgICAgICAgLy8gMTExMSAweHh4IDEweHggeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAzO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHhmZmZmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKChjICYgMHhjMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLlVORVhQRUNURURfQ09OVElOVUUsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uQkFEX1BSRUZJWCwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gd2UgaGF2ZSBlbm91Z2ggYnl0ZXMgaW4gb3VyIGRhdGE/XG4gICAgICAgIGlmIChpIC0gMSArIGV4dHJhTGVuZ3RoID49IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5PVkVSUlVOLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIGxlbmd0aCBwcmVmaXggZnJvbSB0aGUgY2hhclxuICAgICAgICBsZXQgcmVzID0gYyAmICgoMSA8PCAoOCAtIGV4dHJhTGVuZ3RoIC0gMSkpIC0gMSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZXh0cmFMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IG5leHRDaGFyID0gYnl0ZXNbaV07XG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgICAgICBpZiAoKG5leHRDaGFyICYgMHhjMCkgIT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uTUlTU0lOR19DT05USU5VRSwgaSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHJlcyA9IChyZXMgPDwgNikgfCAobmV4dENoYXIgJiAweDNmKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWUgYWJvdmUgbG9vcCBmb3IgaW52YWxpZCBjb250aW51YXRpb24gYnl0ZVxuICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXhpbXVtIGNvZGUgcG9pbnRcbiAgICAgICAgaWYgKHJlcyA+IDB4MTBmZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk9VVF9PRl9SQU5HRSwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2VydmVkIGZvciBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgICBpZiAocmVzID49IDB4ZDgwMCAmJiByZXMgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLlVURjE2X1NVUlJPR0FURSwgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBvdmVybG9uZyBzZXF1ZW5jZXMgKG1vcmUgYnl0ZXMgdGhhbiBuZWVkZWQpXG4gICAgICAgIGlmIChyZXMgPD0gb3ZlcmxvbmdNYXNrKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk9WRVJMT05HLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTg3Mjk0MDUvaG93LXRvLWNvbnZlcnQtdXRmOC1zdHJpbmctdG8tYnl0ZS1hcnJheVxuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSA9IFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5jdXJyZW50KSB7XG4gICAgaWYgKGZvcm0gIT0gVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrTm9ybWFsaXplKCk7XG4gICAgICAgIHN0ciA9IHN0ci5ub3JtYWxpemUoZm9ybSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiA2KSB8IDB4YzApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmYzAwKSA9PSAweGQ4MDApIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnN0IGMyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoaSA+PSBzdHIubGVuZ3RoIHx8IChjMiAmIDB4ZmMwMCkgIT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdXRmLTggc3RyaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoYzIgJiAweDAzZmYpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgPj4gMTgpIHwgMHhmMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gMTIpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiAxMikgfCAweGUwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgoYyA+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5aWZ5KHJlc3VsdCk7XG59XG47XG5mdW5jdGlvbiBlc2NhcGVDaGFyKHZhbHVlKSB7XG4gICAgY29uc3QgaGV4ID0gKFwiMDAwMFwiICsgdmFsdWUudG9TdHJpbmcoMTYpKTtcbiAgICByZXR1cm4gXCJcXFxcdVwiICsgaGV4LnN1YnN0cmluZyhoZXgubGVuZ3RoIC0gNCk7XG59XG5leHBvcnQgZnVuY3Rpb24gX3RvRXNjYXBlZFV0ZjhTdHJpbmcoYnl0ZXMsIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gJ1wiJyArIGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLCBvbkVycm9yKS5tYXAoKGNvZGVQb2ludCkgPT4ge1xuICAgICAgICBpZiAoY29kZVBvaW50IDwgMjU2KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvZGVQb2ludCkge1xuICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFwiXFxcXGJcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDk6IHJldHVybiBcIlxcXFx0XCI7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFwiXFxcXG5cIjtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gXCJcXFxcclwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMzQ6IHJldHVybiBcIlxcXFxcXFwiXCI7XG4gICAgICAgICAgICAgICAgY2FzZSA5MjogcmV0dXJuIFwiXFxcXFxcXFxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPj0gMzIgJiYgY29kZVBvaW50IDwgMTI3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIGVzY2FwZUNoYXIoY29kZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgcmV0dXJuIGVzY2FwZUNoYXIoKChjb2RlUG9pbnQgPj4gMTApICYgMHgzZmYpICsgMHhkODAwKSArIGVzY2FwZUNoYXIoKGNvZGVQb2ludCAmIDB4M2ZmKSArIDB4ZGMwMCk7XG4gICAgfSkuam9pbihcIlwiKSArICdcIic7XG59XG5leHBvcnQgZnVuY3Rpb24gX3RvVXRmOFN0cmluZyhjb2RlUG9pbnRzKSB7XG4gICAgcmV0dXJuIGNvZGVQb2ludHMubWFwKChjb2RlUG9pbnQpID0+IHtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApLCAoKGNvZGVQb2ludCAmIDB4M2ZmKSArIDB4ZGMwMCkpO1xuICAgIH0pLmpvaW4oXCJcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4U3RyaW5nKGJ5dGVzLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuIF90b1V0ZjhTdHJpbmcoZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhDb2RlUG9pbnRzKHN0ciwgZm9ybSA9IFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5jdXJyZW50KSB7XG4gICAgcmV0dXJuIGdldFV0ZjhDb2RlUG9pbnRzKHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRmOC5qcy5tYXAiXSwibmFtZXMiOlsiYXJyYXlpZnkiLCJMb2dnZXIiLCJ2ZXJzaW9uIiwibG9nZ2VyIiwiVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtIiwiVXRmOEVycm9yUmVhc29uIiwiZXJyb3JGdW5jIiwicmVhc29uIiwib2Zmc2V0IiwiYnl0ZXMiLCJvdXRwdXQiLCJiYWRDb2RlcG9pbnQiLCJ0aHJvd0FyZ3VtZW50RXJyb3IiLCJpZ25vcmVGdW5jIiwiQkFEX1BSRUZJWCIsIlVORVhQRUNURURfQ09OVElOVUUiLCJpIiwibyIsImxlbmd0aCIsIk9WRVJSVU4iLCJyZXBsYWNlRnVuYyIsIk9WRVJMT05HIiwicHVzaCIsIlV0ZjhFcnJvckZ1bmNzIiwiT2JqZWN0IiwiZnJlZXplIiwiZXJyb3IiLCJpZ25vcmUiLCJyZXBsYWNlIiwiZ2V0VXRmOENvZGVQb2ludHMiLCJvbkVycm9yIiwicmVzdWx0IiwiYyIsImV4dHJhTGVuZ3RoIiwib3ZlcmxvbmdNYXNrIiwicmVzIiwiaiIsIm5leHRDaGFyIiwiTUlTU0lOR19DT05USU5VRSIsIk9VVF9PRl9SQU5HRSIsIlVURjE2X1NVUlJPR0FURSIsInRvVXRmOEJ5dGVzIiwic3RyIiwiZm9ybSIsImN1cnJlbnQiLCJjaGVja05vcm1hbGl6ZSIsIm5vcm1hbGl6ZSIsImNoYXJDb2RlQXQiLCJjMiIsIkVycm9yIiwicGFpciIsImVzY2FwZUNoYXIiLCJ2YWx1ZSIsImhleCIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiX3RvRXNjYXBlZFV0ZjhTdHJpbmciLCJtYXAiLCJjb2RlUG9pbnQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJqb2luIiwiX3RvVXRmOFN0cmluZyIsImNvZGVQb2ludHMiLCJ0b1V0ZjhTdHJpbmciLCJ0b1V0ZjhDb2RlUG9pbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/strings/lib.esm/utf8.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/transactions/lib.esm/_version.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ethersproject/transactions/lib.esm/_version.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"transactions/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFVBQVUscUJBQXFCLENBQzVDLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zL2xpYi5lc20vX3ZlcnNpb24uanM/NmZhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwidHJhbnNhY3Rpb25zLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/transactions/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/transactions/lib.esm/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/transactions/lib.esm/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TransactionTypes: () => (/* binding */ TransactionTypes),\n/* harmony export */   accessListify: () => (/* binding */ accessListify),\n/* harmony export */   computeAddress: () => (/* binding */ computeAddress),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   recoverAddress: () => (/* binding */ recoverAddress),\n/* harmony export */   serialize: () => (/* binding */ serialize)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/constants */ \"(ssr)/./node_modules/@ethersproject/constants/lib.esm/bignumbers.js\");\n/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/@ethersproject/keccak256/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/rlp */ \"(ssr)/./node_modules/@ethersproject/rlp/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/signing-key */ \"(ssr)/./node_modules/@ethersproject/signing-key/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/transactions/lib.esm/_version.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nvar TransactionTypes;\n(function(TransactionTypes) {\n    TransactionTypes[TransactionTypes[\"legacy\"] = 0] = \"legacy\";\n    TransactionTypes[TransactionTypes[\"eip2930\"] = 1] = \"eip2930\";\n    TransactionTypes[TransactionTypes[\"eip1559\"] = 2] = \"eip1559\";\n})(TransactionTypes || (TransactionTypes = {}));\n;\n///////////////////////////////\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(value);\n}\nfunction handleNumber(value) {\n    if (value === \"0x\") {\n        return _ethersproject_constants__WEBPACK_IMPORTED_MODULE_3__.Zero;\n    }\n    return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value);\n}\n// Legacy Transaction Fields\nconst transactionFields = [\n    {\n        name: \"nonce\",\n        maxLength: 32,\n        numeric: true\n    },\n    {\n        name: \"gasPrice\",\n        maxLength: 32,\n        numeric: true\n    },\n    {\n        name: \"gasLimit\",\n        maxLength: 32,\n        numeric: true\n    },\n    {\n        name: \"to\",\n        length: 20\n    },\n    {\n        name: \"value\",\n        maxLength: 32,\n        numeric: true\n    },\n    {\n        name: \"data\"\n    }\n];\nconst allowedTransactionKeys = {\n    chainId: true,\n    data: true,\n    gasLimit: true,\n    gasPrice: true,\n    nonce: true,\n    to: true,\n    type: true,\n    value: true\n};\nfunction computeAddress(key) {\n    const publicKey = (0,_ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_5__.computePublicKey)(key);\n    return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexDataSlice)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexDataSlice)(publicKey, 1)), 12));\n}\nfunction recoverAddress(digest, signature) {\n    return computeAddress((0,_ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_5__.recoverPublicKey)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(digest), signature));\n}\nfunction formatNumber(value, name) {\n    const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, \"transaction:\" + name, value);\n    }\n    return result;\n}\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index)=>{\n            if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexDataLength)(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${addr}:${index}]`, storageKey);\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\nfunction accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index)=>{\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${index}]`, set);\n                }\n                return accessSetify(set[0], set[1]);\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    const result = Object.keys(value).map((addr)=>{\n        const storageKeys = value[addr].reduce((accum, storageKey)=>{\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b)=>a.address.localeCompare(b.address));\n    return result;\n}\nfunction formatAccessList(value) {\n    return accessListify(value).map((set)=>[\n            set.address,\n            set.storageKeys\n        ]);\n}\nfunction _serializeEip1559(transaction, signature) {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice,\n                maxFeePerGas\n            });\n        }\n    }\n    const fields = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        transaction.to != null ? (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(transaction.to) : \"0x\",\n        formatNumber(transaction.value || 0, \"value\"),\n        transaction.data || \"0x\",\n        formatAccessList(transaction.accessList || [])\n    ];\n    if (signature) {\n        const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.splitSignature)(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.r));\n        fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.s));\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexConcat)([\n        \"0x02\",\n        _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(fields)\n    ]);\n}\nfunction _serializeEip2930(transaction, signature) {\n    const fields = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        transaction.to != null ? (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(transaction.to) : \"0x\",\n        formatNumber(transaction.value || 0, \"value\"),\n        transaction.data || \"0x\",\n        formatAccessList(transaction.accessList || [])\n    ];\n    if (signature) {\n        const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.splitSignature)(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.r));\n        fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.s));\n    }\n    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexConcat)([\n        \"0x01\",\n        _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(fields)\n    ]);\n}\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction, signature) {\n    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.checkProperties)(transaction, allowedTransactionKeys);\n    const raw = [];\n    transactionFields.forEach(function(fieldInfo) {\n        let value = transaction[fieldInfo.name] || [];\n        const options = {};\n        if (fieldInfo.numeric) {\n            options.hexPad = \"left\";\n        }\n        value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(value, options));\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, \"transaction:\" + fieldInfo.name, value);\n        }\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(value);\n            if (value.length > fieldInfo.maxLength) {\n                logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, \"transaction:\" + fieldInfo.name, value);\n            }\n        }\n        raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(value));\n    });\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n        if (typeof chainId !== \"number\") {\n            logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n    } else if (signature && !(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isBytesLike)(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(raw);\n    }\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.splitSignature)(signature);\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam;\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n            logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    } else if (sig.v !== v) {\n        logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n    raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(v));\n    raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(sig.r)));\n    raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(sig.s)));\n    return _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(raw);\n}\nfunction serialize(transaction, signature) {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n    // Typed Transactions (EIP-2718)\n    switch(transaction.type){\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n    return logger.throwError(`unsupported transaction type: ${transaction.type}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\nfunction _parseEipSignature(tx, fields, serialize) {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) {\n            throw new Error(\"bad recid\");\n        }\n        tx.v = recid;\n    } catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n    tx.r = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(fields[1], 32);\n    tx.s = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(fields[2], 32);\n    try {\n        const digest = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(serialize(tx));\n        tx.from = recoverAddress(digest, {\n            r: tx.r,\n            s: tx.s,\n            recoveryParam: tx.v\n        });\n    } catch (error) {}\n}\nfunction _parseEip1559(payload) {\n    const transaction = _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.decode(payload.slice(1));\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(payload));\n    }\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx = {\n        type: 2,\n        chainId: handleNumber(transaction[0]).toNumber(),\n        nonce: handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        maxFeePerGas: maxFeePerGas,\n        gasPrice: null,\n        gasLimit: handleNumber(transaction[4]),\n        to: handleAddress(transaction[5]),\n        value: handleNumber(transaction[6]),\n        data: transaction[7],\n        accessList: accessListify(transaction[8])\n    };\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) {\n        return tx;\n    }\n    tx.hash = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(payload);\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n    return tx;\n}\nfunction _parseEip2930(payload) {\n    const transaction = _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.decode(payload.slice(1));\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(payload));\n    }\n    const tx = {\n        type: 1,\n        chainId: handleNumber(transaction[0]).toNumber(),\n        nonce: handleNumber(transaction[1]).toNumber(),\n        gasPrice: handleNumber(transaction[2]),\n        gasLimit: handleNumber(transaction[3]),\n        to: handleAddress(transaction[4]),\n        value: handleNumber(transaction[5]),\n        data: transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) {\n        return tx;\n    }\n    tx.hash = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(payload);\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n    return tx;\n}\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction) {\n    const transaction = _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.decode(rawTransaction);\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n    const tx = {\n        nonce: handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to: handleAddress(transaction[3]),\n        value: handleNumber(transaction[4]),\n        data: transaction[5],\n        chainId: 0\n    };\n    // Legacy unsigned transaction\n    if (transaction.length === 6) {\n        return tx;\n    }\n    try {\n        tx.v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction[6]).toNumber();\n    } catch (error) {\n        // @TODO: What makes snese to do? The v is too big\n        return tx;\n    }\n    tx.r = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(transaction[7], 32);\n    tx.s = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(transaction[8], 32);\n    if (_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(tx.r).isZero() && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n    } else {\n        // Signed Transaction\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) {\n            tx.chainId = 0;\n        }\n        let recoveryParam = tx.v - 27;\n        const raw = transaction.slice(0, 6);\n        if (tx.chainId !== 0) {\n            raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n        const digest = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(_ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(raw));\n        try {\n            tx.from = recoverAddress(digest, {\n                r: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx.r),\n                s: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx.s),\n                recoveryParam: recoveryParam\n            });\n        } catch (error) {}\n        tx.hash = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(rawTransaction);\n    }\n    tx.type = null;\n    return tx;\n}\nfunction parse(rawTransaction) {\n    const payload = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(rawTransaction);\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) {\n        return _parse(payload);\n    }\n    // Typed Transaction (EIP-2718)\n    switch(payload[0]){\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n    return logger.throwError(`unsupported transaction type: ${payload[0]}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zL2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ3VDO0FBQ0M7QUFDa0c7QUFDdkc7QUFDSztBQUNPO0FBQ2xCO0FBQ3NDO0FBQ2pDO0FBQ1Y7QUFDckMsTUFBTW1CLFNBQVMsSUFBSUYseURBQU1BLENBQUNDLDZDQUFPQTtBQUMxQixJQUFJRSxpQkFBaUI7QUFDM0IsVUFBVUEsZ0JBQWdCO0lBQ3ZCQSxnQkFBZ0IsQ0FBQ0EsZ0JBQWdCLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztJQUNuREEsZ0JBQWdCLENBQUNBLGdCQUFnQixDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDcERBLGdCQUFnQixDQUFDQSxnQkFBZ0IsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0FBQ3hELEdBQUdBLG9CQUFxQkEsQ0FBQUEsbUJBQW1CLENBQUM7O0FBRTVDLCtCQUErQjtBQUMvQixTQUFTQyxjQUFjQyxLQUFLO0lBQ3hCLElBQUlBLFVBQVUsTUFBTTtRQUNoQixPQUFPO0lBQ1g7SUFDQSxPQUFPdEIsa0VBQVVBLENBQUNzQjtBQUN0QjtBQUNBLFNBQVNDLGFBQWFELEtBQUs7SUFDdkIsSUFBSUEsVUFBVSxNQUFNO1FBQ2hCLE9BQU9YLDBEQUFJQTtJQUNmO0lBQ0EsT0FBT1YsK0RBQVNBLENBQUN1QixJQUFJLENBQUNGO0FBQzFCO0FBQ0EsNEJBQTRCO0FBQzVCLE1BQU1HLG9CQUFvQjtJQUN0QjtRQUFFQyxNQUFNO1FBQVNDLFdBQVc7UUFBSUMsU0FBUztJQUFLO0lBQzlDO1FBQUVGLE1BQU07UUFBWUMsV0FBVztRQUFJQyxTQUFTO0lBQUs7SUFDakQ7UUFBRUYsTUFBTTtRQUFZQyxXQUFXO1FBQUlDLFNBQVM7SUFBSztJQUNqRDtRQUFFRixNQUFNO1FBQU1HLFFBQVE7SUFBRztJQUN6QjtRQUFFSCxNQUFNO1FBQVNDLFdBQVc7UUFB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ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9ucy9saWIuZXNtL2luZGV4LmpzPzg3YzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBoZXhDb25jYXQsIGhleERhdGFMZW5ndGgsIGhleERhdGFTbGljZSwgaGV4bGlmeSwgaGV4WmVyb1BhZCwgaXNCeXRlc0xpa2UsIHNwbGl0U2lnbmF0dXJlLCBzdHJpcFplcm9zLCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgWmVybyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9jb25zdGFudHNcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIjtcbmltcG9ydCB7IGNoZWNrUHJvcGVydGllcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgKiBhcyBSTFAgZnJvbSBcIkBldGhlcnNwcm9qZWN0L3JscFwiO1xuaW1wb3J0IHsgY29tcHV0ZVB1YmxpY0tleSwgcmVjb3ZlclB1YmxpY0tleSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleVwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZXhwb3J0IHZhciBUcmFuc2FjdGlvblR5cGVzO1xuKGZ1bmN0aW9uIChUcmFuc2FjdGlvblR5cGVzKSB7XG4gICAgVHJhbnNhY3Rpb25UeXBlc1tUcmFuc2FjdGlvblR5cGVzW1wibGVnYWN5XCJdID0gMF0gPSBcImxlZ2FjeVwiO1xuICAgIFRyYW5zYWN0aW9uVHlwZXNbVHJhbnNhY3Rpb25UeXBlc1tcImVpcDI5MzBcIl0gPSAxXSA9IFwiZWlwMjkzMFwiO1xuICAgIFRyYW5zYWN0aW9uVHlwZXNbVHJhbnNhY3Rpb25UeXBlc1tcImVpcDE1NTlcIl0gPSAyXSA9IFwiZWlwMTU1OVwiO1xufSkoVHJhbnNhY3Rpb25UeXBlcyB8fCAoVHJhbnNhY3Rpb25UeXBlcyA9IHt9KSk7XG47XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBoYW5kbGVBZGRyZXNzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZGRyZXNzKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU51bWJlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBaZXJvO1xuICAgIH1cbiAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xufVxuLy8gTGVnYWN5IFRyYW5zYWN0aW9uIEZpZWxkc1xuY29uc3QgdHJhbnNhY3Rpb25GaWVsZHMgPSBbXG4gICAgeyBuYW1lOiBcIm5vbmNlXCIsIG1heExlbmd0aDogMzIsIG51bWVyaWM6IHRydWUgfSxcbiAgICB7IG5hbWU6IFwiZ2FzUHJpY2VcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuICAgIHsgbmFtZTogXCJnYXNMaW1pdFwiLCBtYXhMZW5ndGg6IDMyLCBudW1lcmljOiB0cnVlIH0sXG4gICAgeyBuYW1lOiBcInRvXCIsIGxlbmd0aDogMjAgfSxcbiAgICB7IG5hbWU6IFwidmFsdWVcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuICAgIHsgbmFtZTogXCJkYXRhXCIgfSxcbl07XG5jb25zdCBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzID0ge1xuICAgIGNoYWluSWQ6IHRydWUsIGRhdGE6IHRydWUsIGdhc0xpbWl0OiB0cnVlLCBnYXNQcmljZTogdHJ1ZSwgbm9uY2U6IHRydWUsIHRvOiB0cnVlLCB0eXBlOiB0cnVlLCB2YWx1ZTogdHJ1ZVxufTtcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQWRkcmVzcyhrZXkpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBjb21wdXRlUHVibGljS2V5KGtleSk7XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoaGV4RGF0YVNsaWNlKGtlY2NhazI1NihoZXhEYXRhU2xpY2UocHVibGljS2V5LCAxKSksIDEyKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCBzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gY29tcHV0ZUFkZHJlc3MocmVjb3ZlclB1YmxpY0tleShhcnJheWlmeShkaWdlc3QpLCBzaWduYXR1cmUpKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcih2YWx1ZSwgbmFtZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN0cmlwWmVyb3MoQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvSGV4U3RyaW5nKCkpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbGVuZ3RoIGZvciBcIiArIG5hbWUsIChcInRyYW5zYWN0aW9uOlwiICsgbmFtZSksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFjY2Vzc1NldGlmeShhZGRyLCBzdG9yYWdlS2V5cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IGdldEFkZHJlc3MoYWRkciksXG4gICAgICAgIHN0b3JhZ2VLZXlzOiAoc3RvcmFnZUtleXMgfHwgW10pLm1hcCgoc3RvcmFnZUtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChoZXhEYXRhTGVuZ3RoKHN0b3JhZ2VLZXkpICE9PSAzMikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFjY2VzcyBsaXN0IHN0b3JhZ2VLZXlcIiwgYGFjY2Vzc0xpc3RbJHthZGRyfToke2luZGV4fV1gLCBzdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlS2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHNldCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNldCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFjY2VzcyBsaXN0IGV4cGVjdGVkIHRvIGJlIFsgYWRkcmVzcywgc3RvcmFnZUtleXNbXSBdXCIsIGB2YWx1ZVske2luZGV4fV1gLCBzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KHNldFswXSwgc2V0WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0LmFkZHJlc3MsIHNldC5zdG9yYWdlS2V5cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3Qua2V5cyh2YWx1ZSkubWFwKChhZGRyKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VLZXlzID0gdmFsdWVbYWRkcl0ucmVkdWNlKChhY2N1bSwgc3RvcmFnZUtleSkgPT4ge1xuICAgICAgICAgICAgYWNjdW1bc3RvcmFnZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoYWRkciwgT2JqZWN0LmtleXMoc3RvcmFnZUtleXMpLnNvcnQoKSk7XG4gICAgfSk7XG4gICAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IChhLmFkZHJlc3MubG9jYWxlQ29tcGFyZShiLmFkZHJlc3MpKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZvcm1hdEFjY2Vzc0xpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gYWNjZXNzTGlzdGlmeSh2YWx1ZSkubWFwKChzZXQpID0+IFtzZXQuYWRkcmVzcywgc2V0LnN0b3JhZ2VLZXlzXSk7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMTU1OSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gZXhwbGljaXQgZ2FzUHJpY2UsIG1ha2Ugc3VyZSBpdCBtYXRjaGVzIHRoZVxuICAgIC8vIEVJUC0xNTU5IGZlZXM7IG90aGVyd2lzZSB0aGV5IG1heSBub3QgdW5kZXJzdGFuZCB3aGF0IHRoZXlcbiAgICAvLyB0aGluayB0aGV5IGFyZSBzZXR0aW5nIGluIHRlcm1zIG9mIGZlZS5cbiAgICBpZiAodHJhbnNhY3Rpb24uZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBnYXNQcmljZSA9IEJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLmdhc1ByaWNlKTtcbiAgICAgICAgY29uc3QgbWF4RmVlUGVyR2FzID0gQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzIHx8IDApO1xuICAgICAgICBpZiAoIWdhc1ByaWNlLmVxKG1heEZlZVBlckdhcykpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNtYXRjaCBFSVAtMTU1OSBnYXNQcmljZSAhPSBtYXhGZWVQZXJHYXNcIiwgXCJ0eFwiLCB7XG4gICAgICAgICAgICAgICAgZ2FzUHJpY2UsIG1heEZlZVBlckdhc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24uY2hhaW5JZCB8fCAwLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5ub25jZSB8fCAwLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24ubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgMCwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLm1heEZlZVBlckdhcyB8fCAwLCBcIm1heEZlZVBlckdhc1wiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmdhc0xpbWl0IHx8IDAsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICgodHJhbnNhY3Rpb24udG8gIT0gbnVsbCkgPyBnZXRBZGRyZXNzKHRyYW5zYWN0aW9uLnRvKSA6IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi52YWx1ZSB8fCAwLCBcInZhbHVlXCIpLFxuICAgICAgICAodHJhbnNhY3Rpb24uZGF0YSB8fCBcIjB4XCIpLFxuICAgICAgICAoZm9ybWF0QWNjZXNzTGlzdCh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0IHx8IFtdKSlcbiAgICBdO1xuICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgY29uc3Qgc2lnID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy5yZWNvdmVyeVBhcmFtLCBcInJlY292ZXJ5UGFyYW1cIikpO1xuICAgICAgICBmaWVsZHMucHVzaChzdHJpcFplcm9zKHNpZy5yKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHN0cmlwWmVyb3Moc2lnLnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleENvbmNhdChbXCIweDAyXCIsIFJMUC5lbmNvZGUoZmllbGRzKV0pO1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDI5MzAodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmNoYWluSWQgfHwgMCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24ubm9uY2UgfHwgMCwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmdhc1ByaWNlIHx8IDAsIFwiZ2FzUHJpY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5nYXNMaW1pdCB8fCAwLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAoKHRyYW5zYWN0aW9uLnRvICE9IG51bGwpID8gZ2V0QWRkcmVzcyh0cmFuc2FjdGlvbi50bykgOiBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24udmFsdWUgfHwgMCwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgKHRyYW5zYWN0aW9uLmRhdGEgfHwgXCIweFwiKSxcbiAgICAgICAgKGZvcm1hdEFjY2Vzc0xpc3QodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCB8fCBbXSkpXG4gICAgXTtcbiAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgIGNvbnN0IHNpZyA9IHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcucmVjb3ZlcnlQYXJhbSwgXCJyZWNvdmVyeVBhcmFtXCIpKTtcbiAgICAgICAgZmllbGRzLnB1c2goc3RyaXBaZXJvcyhzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaChzdHJpcFplcm9zKHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhDb25jYXQoW1wiMHgwMVwiLCBSTFAuZW5jb2RlKGZpZWxkcyldKTtcbn1cbi8vIExlZ2FjeSBUcmFuc2FjdGlvbnMgYW5kIEVJUC0xNTVcbmZ1bmN0aW9uIF9zZXJpYWxpemUodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xuICAgIGNoZWNrUHJvcGVydGllcyh0cmFuc2FjdGlvbiwgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyk7XG4gICAgY29uc3QgcmF3ID0gW107XG4gICAgdHJhbnNhY3Rpb25GaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGRJbmZvKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRyYW5zYWN0aW9uW2ZpZWxkSW5mby5uYW1lXSB8fCAoW10pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIGlmIChmaWVsZEluZm8ubnVtZXJpYykge1xuICAgICAgICAgICAgb3B0aW9ucy5oZXhQYWQgPSBcImxlZnRcIjtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IGFycmF5aWZ5KGhleGxpZnkodmFsdWUsIG9wdGlvbnMpKTtcbiAgICAgICAgLy8gRml4ZWQtd2lkdGggZmllbGRcbiAgICAgICAgaWYgKGZpZWxkSW5mby5sZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSBmaWVsZEluZm8ubGVuZ3RoICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxlbmd0aCBmb3IgXCIgKyBmaWVsZEluZm8ubmFtZSwgKFwidHJhbnNhY3Rpb246XCIgKyBmaWVsZEluZm8ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBWYXJpYWJsZS13aWR0aCAod2l0aCBhIG1heGltdW0pXG4gICAgICAgIGlmIChmaWVsZEluZm8ubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHN0cmlwWmVyb3ModmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IGZpZWxkSW5mby5tYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsZW5ndGggZm9yIFwiICsgZmllbGRJbmZvLm5hbWUsIChcInRyYW5zYWN0aW9uOlwiICsgZmllbGRJbmZvLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmF3LnB1c2goaGV4bGlmeSh2YWx1ZSkpO1xuICAgIH0pO1xuICAgIGxldCBjaGFpbklkID0gMDtcbiAgICBpZiAodHJhbnNhY3Rpb24uY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgIC8vIEEgY2hhaW5JZCB3YXMgcHJvdmlkZWQ7IGlmIG5vbi16ZXJvIHdlJ2xsIHVzZSBFSVAtMTU1XG4gICAgICAgIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuICAgICAgICBpZiAodHlwZW9mIChjaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHJhbnNhY3Rpb24uY2hhaW5JZFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzaWduYXR1cmUgJiYgIWlzQnl0ZXNMaWtlKHNpZ25hdHVyZSkgJiYgc2lnbmF0dXJlLnYgPiAyOCkge1xuICAgICAgICAvLyBObyBjaGFpbklkIHByb3ZpZGVkLCBidXQgdGhlIHNpZ25hdHVyZSBpcyBzaWduaW5nIHdpdGggRUlQLTE1NTsgZGVyaXZlIGNoYWluSWRcbiAgICAgICAgY2hhaW5JZCA9IE1hdGguZmxvb3IoKHNpZ25hdHVyZS52IC0gMzUpIC8gMik7XG4gICAgfVxuICAgIC8vIFdlIGhhdmUgYW4gRUlQLTE1NSB0cmFuc2FjdGlvbiAoY2hhaW5JZCB3YXMgc3BlY2lmaWVkIGFuZCBub24temVybylcbiAgICBpZiAoY2hhaW5JZCAhPT0gMCkge1xuICAgICAgICByYXcucHVzaChoZXhsaWZ5KGNoYWluSWQpKTsgLy8gQFRPRE86IGhleFZhbHVlP1xuICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuICAgIH1cbiAgICAvLyBSZXF1ZXN0aW5nIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKCFzaWduYXR1cmUpIHtcbiAgICAgICAgcmV0dXJuIFJMUC5lbmNvZGUocmF3KTtcbiAgICB9XG4gICAgLy8gVGhlIHNwbGl0U2lnbmF0dXJlIHdpbGwgZW5zdXJlIHRoZSB0cmFuc2FjdGlvbiBoYXMgYSByZWNvdmVyeVBhcmFtIGluIHRoZVxuICAgIC8vIGNhc2UgdGhhdCB0aGUgc2lnblRyYW5zYWN0aW9uIGZ1bmN0aW9uIG9ubHkgYWRkcyBhIHYuXG4gICAgY29uc3Qgc2lnID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAvLyBXZSBwdXNoZWQgYSBjaGFpbklkIGFuZCBudWxsIHIsIHMgb24gZm9yIGhhc2hpbmcgb25seTsgcmVtb3ZlIHRob3NlXG4gICAgbGV0IHYgPSAyNyArIHNpZy5yZWNvdmVyeVBhcmFtO1xuICAgIGlmIChjaGFpbklkICE9PSAwKSB7XG4gICAgICAgIHJhdy5wb3AoKTtcbiAgICAgICAgcmF3LnBvcCgpO1xuICAgICAgICByYXcucG9wKCk7XG4gICAgICAgIHYgKz0gY2hhaW5JZCAqIDIgKyA4O1xuICAgICAgICAvLyBJZiBhbiBFSVAtMTU1IHYgKGRpcmVjdGx5IG9yIGluZGlyZWN0bHk7IG1heWJlIF92cykgd2FzIHByb3ZpZGVkLCBjaGVjayBpdCFcbiAgICAgICAgaWYgKHNpZy52ID4gMjggJiYgc2lnLnYgIT09IHYpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0cmFuc2FjdGlvbi5jaGFpbklkL3NpZ25hdHVyZS52IG1pc21hdGNoXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2lnLnYgIT09IHYpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRyYW5zYWN0aW9uLmNoYWluSWQvc2lnbmF0dXJlLnYgbWlzbWF0Y2hcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgcmF3LnB1c2goaGV4bGlmeSh2KSk7XG4gICAgcmF3LnB1c2goc3RyaXBaZXJvcyhhcnJheWlmeShzaWcucikpKTtcbiAgICByYXcucHVzaChzdHJpcFplcm9zKGFycmF5aWZ5KHNpZy5zKSkpO1xuICAgIHJldHVybiBSTFAuZW5jb2RlKHJhdyk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcbiAgICAvLyBMZWdhY3kgYW5kIEVJUC0xNTUgVHJhbnNhY3Rpb25zXG4gICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUgPT0gbnVsbCB8fCB0cmFuc2FjdGlvbi50eXBlID09PSAwKSB7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnR5cGVkIHRyYW5zYWN0aW9ucyBkbyBub3Qgc3VwcG9ydCBhY2Nlc3NMaXN0OyBpbmNsdWRlIHR5cGU6IDFcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zZXJpYWxpemUodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIC8vIFR5cGVkIFRyYW5zYWN0aW9ucyAoRUlQLTI3MTgpXG4gICAgc3dpdGNoICh0cmFuc2FjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMjkzMCh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAxNTU5KHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihgdW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZTogJHt0cmFuc2FjdGlvbi50eXBlfWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJzZXJpYWxpemVUcmFuc2FjdGlvblwiLFxuICAgICAgICB0cmFuc2FjdGlvblR5cGU6IHRyYW5zYWN0aW9uLnR5cGVcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcFNpZ25hdHVyZSh0eCwgZmllbGRzLCBzZXJpYWxpemUpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZWNpZCA9IGhhbmRsZU51bWJlcihmaWVsZHNbMF0pLnRvTnVtYmVyKCk7XG4gICAgICAgIGlmIChyZWNpZCAhPT0gMCAmJiByZWNpZCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHJlY2lkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHR4LnYgPSByZWNpZDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHYgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDFcIiwgXCJ2XCIsIGZpZWxkc1swXSk7XG4gICAgfVxuICAgIHR4LnIgPSBoZXhaZXJvUGFkKGZpZWxkc1sxXSwgMzIpO1xuICAgIHR4LnMgPSBoZXhaZXJvUGFkKGZpZWxkc1syXSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IGtlY2NhazI1NihzZXJpYWxpemUodHgpKTtcbiAgICAgICAgdHguZnJvbSA9IHJlY292ZXJBZGRyZXNzKGRpZ2VzdCwgeyByOiB0eC5yLCBzOiB0eC5zLCByZWNvdmVyeVBhcmFtOiB0eC52IH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxufVxuZnVuY3Rpb24gX3BhcnNlRWlwMTU1OShwYXlsb2FkKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBSTFAuZGVjb2RlKHBheWxvYWQuc2xpY2UoMSkpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5sZW5ndGggIT09IDkgJiYgdHJhbnNhY3Rpb24ubGVuZ3RoICE9PSAxMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb21wb25lbnQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDJcIiwgXCJwYXlsb2FkXCIsIGhleGxpZnkocGF5bG9hZCkpO1xuICAgIH1cbiAgICBjb25zdCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSk7XG4gICAgY29uc3QgbWF4RmVlUGVyR2FzID0gaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzNdKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMixcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzBdKS50b051bWJlcigpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzFdKS50b051bWJlcigpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogbWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgIG1heEZlZVBlckdhczogbWF4RmVlUGVyR2FzLFxuICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls0XSksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKHRyYW5zYWN0aW9uWzVdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls2XSksXG4gICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uWzddLFxuICAgICAgICBhY2Nlc3NMaXN0OiBhY2Nlc3NMaXN0aWZ5KHRyYW5zYWN0aW9uWzhdKSxcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0xNTU5IFRyYW5zYWN0aW9uXG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCA9PT0gOSkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHR4Lmhhc2ggPSBrZWNjYWsyNTYocGF5bG9hZCk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCB0cmFuc2FjdGlvbi5zbGljZSg5KSwgX3NlcmlhbGl6ZUVpcDE1NTkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcDI5MzAocGF5bG9hZCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gUkxQLmRlY29kZShwYXlsb2FkLnNsaWNlKDEpKTtcbiAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoICE9PSA4ICYmIHRyYW5zYWN0aW9uLmxlbmd0aCAhPT0gMTEpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29tcG9uZW50IGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAxXCIsIFwicGF5bG9hZFwiLCBoZXhsaWZ5KHBheWxvYWQpKTtcbiAgICB9XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblswXSkudG9OdW1iZXIoKSxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsxXSkudG9OdW1iZXIoKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSksXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bM10pLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyh0cmFuc2FjdGlvbls0XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bNV0pLFxuICAgICAgICBkYXRhOiB0cmFuc2FjdGlvbls2XSxcbiAgICAgICAgYWNjZXNzTGlzdDogYWNjZXNzTGlzdGlmeSh0cmFuc2FjdGlvbls3XSlcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0yOTMwIFRyYW5zYWN0aW9uXG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCA9PT0gOCkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHR4Lmhhc2ggPSBrZWNjYWsyNTYocGF5bG9hZCk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCB0cmFuc2FjdGlvbi5zbGljZSg4KSwgX3NlcmlhbGl6ZUVpcDI5MzApO1xuICAgIHJldHVybiB0eDtcbn1cbi8vIExlZ2FjeSBUcmFuc2FjdGlvbnMgYW5kIEVJUC0xNTVcbmZ1bmN0aW9uIF9wYXJzZShyYXdUcmFuc2FjdGlvbikge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gUkxQLmRlY29kZShyYXdUcmFuc2FjdGlvbik7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCAhPT0gOSAmJiB0cmFuc2FjdGlvbi5sZW5ndGggIT09IDYpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcmF3IHRyYW5zYWN0aW9uXCIsIFwicmF3VHJhbnNhY3Rpb25cIiwgcmF3VHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblswXSkudG9OdW1iZXIoKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsxXSksXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMl0pLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyh0cmFuc2FjdGlvblszXSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bNF0pLFxuICAgICAgICBkYXRhOiB0cmFuc2FjdGlvbls1XSxcbiAgICAgICAgY2hhaW5JZDogMFxuICAgIH07XG4gICAgLy8gTGVnYWN5IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCA9PT0gNikge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHR4LnYgPSBCaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbls2XSkudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIEBUT0RPOiBXaGF0IG1ha2VzIHNuZXNlIHRvIGRvPyBUaGUgdiBpcyB0b28gYmlnXG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdHguciA9IGhleFplcm9QYWQodHJhbnNhY3Rpb25bN10sIDMyKTtcbiAgICB0eC5zID0gaGV4WmVyb1BhZCh0cmFuc2FjdGlvbls4XSwgMzIpO1xuICAgIGlmIChCaWdOdW1iZXIuZnJvbSh0eC5yKS5pc1plcm8oKSAmJiBCaWdOdW1iZXIuZnJvbSh0eC5zKS5pc1plcm8oKSkge1xuICAgICAgICAvLyBFSVAtMTU1IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgICAgIHR4LmNoYWluSWQgPSB0eC52O1xuICAgICAgICB0eC52ID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFNpZ25lZCBUcmFuc2FjdGlvblxuICAgICAgICB0eC5jaGFpbklkID0gTWF0aC5mbG9vcigodHgudiAtIDM1KSAvIDIpO1xuICAgICAgICBpZiAodHguY2hhaW5JZCA8IDApIHtcbiAgICAgICAgICAgIHR4LmNoYWluSWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZWNvdmVyeVBhcmFtID0gdHgudiAtIDI3O1xuICAgICAgICBjb25zdCByYXcgPSB0cmFuc2FjdGlvbi5zbGljZSgwLCA2KTtcbiAgICAgICAgaWYgKHR4LmNoYWluSWQgIT09IDApIHtcbiAgICAgICAgICAgIHJhdy5wdXNoKGhleGxpZnkodHguY2hhaW5JZCkpO1xuICAgICAgICAgICAgcmF3LnB1c2goXCIweFwiKTtcbiAgICAgICAgICAgIHJhdy5wdXNoKFwiMHhcIik7XG4gICAgICAgICAgICByZWNvdmVyeVBhcmFtIC09IHR4LmNoYWluSWQgKiAyICsgODtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaWdlc3QgPSBrZWNjYWsyNTYoUkxQLmVuY29kZShyYXcpKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHR4LmZyb20gPSByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHsgcjogaGV4bGlmeSh0eC5yKSwgczogaGV4bGlmeSh0eC5zKSwgcmVjb3ZlcnlQYXJhbTogcmVjb3ZlcnlQYXJhbSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB0eC5oYXNoID0ga2VjY2FrMjU2KHJhd1RyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgdHgudHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHR4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHJhd1RyYW5zYWN0aW9uKSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IGFycmF5aWZ5KHJhd1RyYW5zYWN0aW9uKTtcbiAgICAvLyBMZWdhY3kgYW5kIEVJUC0xNTUgVHJhbnNhY3Rpb25zXG4gICAgaWYgKHBheWxvYWRbMF0gPiAweDdmKSB7XG4gICAgICAgIHJldHVybiBfcGFyc2UocGF5bG9hZCk7XG4gICAgfVxuICAgIC8vIFR5cGVkIFRyYW5zYWN0aW9uIChFSVAtMjcxOClcbiAgICBzd2l0Y2ggKHBheWxvYWRbMF0pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIF9wYXJzZUVpcDI5MzAocGF5bG9hZCk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBfcGFyc2VFaXAxNTU5KHBheWxvYWQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihgdW5zdXBwb3J0ZWQgdHJhbnNhY3Rpb24gdHlwZTogJHtwYXlsb2FkWzBdfWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgIG9wZXJhdGlvbjogXCJwYXJzZVRyYW5zYWN0aW9uXCIsXG4gICAgICAgIHRyYW5zYWN0aW9uVHlwZTogcGF5bG9hZFswXVxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbImdldEFkZHJlc3MiLCJCaWdOdW1iZXIiLCJhcnJheWlmeSIsImhleENvbmNhdCIsImhleERhdGFMZW5ndGgiLCJoZXhEYXRhU2xpY2UiLCJoZXhsaWZ5IiwiaGV4WmVyb1BhZCIsImlzQnl0ZXNMaWtlIiwic3BsaXRTaWduYXR1cmUiLCJzdHJpcFplcm9zIiwiWmVybyIsImtlY2NhazI1NiIsImNoZWNrUHJvcGVydGllcyIsIlJMUCIsImNvbXB1dGVQdWJsaWNLZXkiLCJyZWNvdmVyUHVibGljS2V5IiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsIlRyYW5zYWN0aW9uVHlwZXMiLCJoYW5kbGVBZGRyZXNzIiwidmFsdWUiLCJoYW5kbGVOdW1iZXIiLCJmcm9tIiwidHJhbnNhY3Rpb25GaWVsZHMiLCJuYW1lIiwibWF4TGVuZ3RoIiwibnVtZXJpYyIsImxlbmd0aCIsImFsbG93ZWRUcmFuc2FjdGlvbktleXMiLCJjaGFpbklkIiwiZGF0YSIsImdhc0xpbWl0IiwiZ2FzUHJpY2UiLCJub25jZSIsInRvIiwidHlwZSIsImNvbXB1dGVBZGRyZXNzIiwia2V5IiwicHVibGljS2V5IiwicmVjb3ZlckFkZHJlc3MiLCJkaWdlc3QiLCJzaWduYXR1cmUiLCJmb3JtYXROdW1iZXIiLCJyZXN1bHQiLCJ0b0hleFN0cmluZyIsInRocm93QXJndW1lbnRFcnJvciIsImFjY2Vzc1NldGlmeSIsImFkZHIiLCJzdG9yYWdlS2V5cyIsImFkZHJlc3MiLCJtYXAiLCJzdG9yYWdlS2V5IiwiaW5kZXgiLCJ0b0xvd2VyQ2FzZSIsImFjY2Vzc0xpc3RpZnkiLCJBcnJheSIsImlzQXJyYXkiLCJzZXQiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwiYWNjdW0iLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwiZm9ybWF0QWNjZXNzTGlzdCIsIl9zZXJpYWxpemVFaXAxNTU5IiwidHJhbnNhY3Rpb24iLCJtYXhGZWVQZXJHYXMiLCJlcSIsImZpZWxkcyIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwiYWNjZXNzTGlzdCIsInNpZyIsInB1c2giLCJyZWNvdmVyeVBhcmFtIiwiciIsInMiLCJlbmNvZGUiLCJfc2VyaWFsaXplRWlwMjkzMCIsIl9zZXJpYWxpemUiLCJyYXciLCJmb3JFYWNoIiwiZmllbGRJbmZvIiwib3B0aW9ucyIsImhleFBhZCIsInYiLCJNYXRoIiwiZmxvb3IiLCJwb3AiLCJzZXJpYWxpemUiLCJ0aHJvd0Vycm9yIiwiZXJyb3JzIiwiVU5TVVBQT1JURURfT1BFUkFUSU9OIiwib3BlcmF0aW9uIiwidHJhbnNhY3Rpb25UeXBlIiwiX3BhcnNlRWlwU2lnbmF0dXJlIiwidHgiLCJyZWNpZCIsInRvTnVtYmVyIiwiRXJyb3IiLCJlcnJvciIsIl9wYXJzZUVpcDE1NTkiLCJwYXlsb2FkIiwiZGVjb2RlIiwic2xpY2UiLCJoYXNoIiwiX3BhcnNlRWlwMjkzMCIsIl9wYXJzZSIsInJhd1RyYW5zYWN0aW9uIiwiaXNaZXJvIiwicGFyc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/transactions/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/units/lib.esm/_version.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ethersproject/units/lib.esm/_version.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"units/5.7.0\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvdW5pdHMvbGliLmVzbS9fdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsVUFBVSxjQUFjLENBQ3JDLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvdW5pdHMvbGliLmVzbS9fdmVyc2lvbi5qcz84MmYwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJ1bml0cy81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/units/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/units/lib.esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@ethersproject/units/lib.esm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   commify: () => (/* binding */ commify),\n/* harmony export */   formatEther: () => (/* binding */ formatEther),\n/* harmony export */   formatUnits: () => (/* binding */ formatUnits),\n/* harmony export */   parseEther: () => (/* binding */ parseEther),\n/* harmony export */   parseUnits: () => (/* binding */ parseUnits)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bignumber */ \"(ssr)/./node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/units/lib.esm/_version.js\");\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\"\n];\n// Some environments have issues with RegEx that contain back-tracking, so we cannot\n// use them.\nfunction commify(value) {\n    const comps = String(value).split(\".\");\n    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === \".\" || value === \"-.\") {\n        logger.throwArgumentError(\"invalid value\", \"value\", value);\n    }\n    // Make sure we have at least one whole digit (0 if none)\n    let whole = comps[0];\n    let negative = \"\";\n    if (whole.substring(0, 1) === \"-\") {\n        negative = \"-\";\n        whole = whole.substring(1);\n    }\n    // Make sure we have at least 1 whole digit with no leading zeros\n    while(whole.substring(0, 1) === \"0\"){\n        whole = whole.substring(1);\n    }\n    if (whole === \"\") {\n        whole = \"0\";\n    }\n    let suffix = \"\";\n    if (comps.length === 2) {\n        suffix = \".\" + (comps[1] || \"0\");\n    }\n    while(suffix.length > 2 && suffix[suffix.length - 1] === \"0\"){\n        suffix = suffix.substring(0, suffix.length - 1);\n    }\n    const formatted = [];\n    while(whole.length){\n        if (whole.length <= 3) {\n            formatted.unshift(whole);\n            break;\n        } else {\n            const index = whole.length - 3;\n            formatted.unshift(whole.substring(index));\n            whole = whole.substring(0, index);\n        }\n    }\n    return negative + formatted.join(\",\") + suffix;\n}\nfunction formatUnits(value, unitName) {\n    if (typeof unitName === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) {\n            unitName = 3 * index;\n        }\n    }\n    return (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.formatFixed)(value, unitName != null ? unitName : 18);\n}\nfunction parseUnits(value, unitName) {\n    if (typeof value !== \"string\") {\n        logger.throwArgumentError(\"value must be a string\", \"value\", value);\n    }\n    if (typeof unitName === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) {\n            unitName = 3 * index;\n        }\n    }\n    return (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.parseFixed)(value, unitName != null ? unitName : 18);\n}\nfunction formatEther(wei) {\n    return formatUnits(wei, 18);\n}\nfunction parseEther(ether) {\n    return parseUnits(ether, 18);\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvdW5pdHMvbGliLmVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFhO0FBQ3NEO0FBQ3BCO0FBQ1Y7QUFDckMsTUFBTUksU0FBUyxJQUFJRix5REFBTUEsQ0FBQ0MsNkNBQU9BO0FBQ2pDLE1BQU1FLFFBQVE7SUFDVjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0Qsb0ZBQW9GO0FBQ3BGLFlBQVk7QUFDTCxTQUFTQyxRQUFRQyxLQUFLO0lBQ3pCLE1BQU1DLFFBQVFDLE9BQU9GLE9BQU9HLEtBQUssQ0FBQztJQUNsQyxJQUFJRixNQUFNRyxNQUFNLEdBQUcsS0FBSyxDQUFDSCxLQUFLLENBQUMsRUFBRSxDQUFDSSxLQUFLLENBQUMsaUJBQWtCSixLQUFLLENBQUMsRUFBRSxJQUFJLENBQUNBLEtBQUssQ0FBQyxFQUFFLENBQUNJLEtBQUssQ0FBQyxlQUFnQkwsVUFBVSxPQUFPQSxVQUFVLE1BQU07UUFDbklILE9BQU9TLGtCQUFrQixDQUFDLGlCQUFpQixTQUFTTjtJQUN4RDtJQUNBLHlEQUF5RDtJQUN6RCxJQUFJTyxRQUFRTixLQUFLLENBQUMsRUFBRTtJQUNwQixJQUFJTyxXQUFXO0lBQ2YsSUFBSUQsTUFBTUUsU0FBUyxDQUFDLEdBQUcsT0FBTyxLQUFLO1FBQy9CRCxXQUFXO1FBQ1hELFFBQVFBLE1BQU1FLFNBQVMsQ0FBQztJQUM1QjtJQUNBLGlFQUFpRTtJQUNqRSxNQUFPRixNQUFNRSxTQUFTLENBQUMsR0FBRyxPQUFPLElBQUs7UUFDbENGLFFBQVFBLE1BQU1FLFNBQVMsQ0FBQztJQUM1QjtJQUNBLElBQUlGLFVBQVUsSUFBSTtRQUNkQSxRQUFRO0lBQ1o7SUFDQSxJQUFJRyxTQUFTO0lBQ2IsSUFBSVQsTUFBTUcsTUFBTSxLQUFLLEdBQUc7UUFDcEJNLFNBQVMsTUFBT1QsQ0FBQUEsS0FBSyxDQUFDLEVBQUUsSUFBSSxHQUFFO0lBQ2xDO0lBQ0EsTUFBT1MsT0FBT04sTUFBTSxHQUFHLEtBQUtNLE1BQU0sQ0FBQ0EsT0FBT04sTUFBTSxHQUFHLEVBQUUsS0FBSyxJQUFLO1FBQzNETSxTQUFTQSxPQUFPRCxTQUFTLENBQUMsR0FBR0MsT0FBT04sTUFBTSxHQUFHO0lBQ2pEO0lBQ0EsTUFBTU8sWUFBWSxFQUFFO0lBQ3BCLE1BQU9KLE1BQU1ILE1BQU0sQ0FBRTtRQUNqQixJQUFJRyxNQUFNSCxNQUFNLElBQUksR0FBRztZQUNuQk8sVUFBVUMsT0FBTyxDQUFDTDtZQUNsQjtRQUNKLE9BQ0s7WUFDRCxNQUFNTSxRQUFRTixNQUFNSCxNQUFNLEdBQUc7WUFDN0JPLFVBQVVDLE9BQU8sQ0FBQ0wsTUFBTUUsU0FBUyxDQUFDSTtZQUNsQ04sUUFBUUEsTUFBTUUsU0FBUyxDQUFDLEdBQUdJO1FBQy9CO0lBQ0o7SUFDQSxPQUFPTCxXQUFXRyxVQUFVRyxJQUFJLENBQUMsT0FBT0o7QUFDNUM7QUFDTyxTQUFTSyxZQUFZZixLQUFLLEVBQUVnQixRQUFRO0lBQ3ZDLElBQUksT0FBUUEsYUFBYyxVQUFVO1FBQ2hDLE1BQU1ILFFBQVFmLE1BQU1tQixPQUFPLENBQUNEO1FBQzVCLElBQUlILFVBQVUsQ0FBQyxHQUFHO1lBQ2RHLFdBQVcsSUFBSUg7UUFDbkI7SUFDSjtJQUNBLE9BQU9wQixxRUFBV0EsQ0FBQ08sT0FBTyxZQUFhLE9BQVFnQixXQUFXO0FBQzlEO0FBQ08sU0FBU0UsV0FBV2xCLEtBQUssRUFBRWdCLFFBQVE7SUFDdEMsSUFBSSxPQUFRaEIsVUFBVyxVQUFVO1FBQzdCSCxPQUFPUyxrQkFBa0IsQ0FBQywwQkFBMEIsU0FBU047SUFDakU7SUFDQSxJQUFJLE9BQVFnQixhQUFjLFVBQVU7UUFDaEMsTUFBTUgsUUFBUWYsTUFBTW1CLE9BQU8sQ0FBQ0Q7UUFDNUIsSUFBSUgsVUFBVSxDQUFDLEdBQUc7WUFDZEcsV0FBVyxJQUFJSDtRQUNuQjtJQUNKO0lBQ0EsT0FBT25CLG9FQUFVQSxDQUFDTSxPQUFPLFlBQWEsT0FBUWdCLFdBQVc7QUFDN0Q7QUFDTyxTQUFTRyxZQUFZQyxHQUFHO0lBQzNCLE9BQU9MLFlBQVlLLEtBQUs7QUFDNUI7QUFDTyxTQUFTQyxXQUFXQyxLQUFLO0lBQzVCLE9BQU9KLFdBQVdJLE9BQU87QUFDN0IsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3VuaXRzL2xpYi5lc20vaW5kZXguanM/MDc3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGZvcm1hdEZpeGVkLCBwYXJzZUZpeGVkIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuY29uc3QgbmFtZXMgPSBbXG4gICAgXCJ3ZWlcIixcbiAgICBcImt3ZWlcIixcbiAgICBcIm13ZWlcIixcbiAgICBcImd3ZWlcIixcbiAgICBcInN6YWJvXCIsXG4gICAgXCJmaW5uZXlcIixcbiAgICBcImV0aGVyXCIsXG5dO1xuLy8gU29tZSBlbnZpcm9ubWVudHMgaGF2ZSBpc3N1ZXMgd2l0aCBSZWdFeCB0aGF0IGNvbnRhaW4gYmFjay10cmFja2luZywgc28gd2UgY2Fubm90XG4vLyB1c2UgdGhlbS5cbmV4cG9ydCBmdW5jdGlvbiBjb21taWZ5KHZhbHVlKSB7XG4gICAgY29uc3QgY29tcHMgPSBTdHJpbmcodmFsdWUpLnNwbGl0KFwiLlwiKTtcbiAgICBpZiAoY29tcHMubGVuZ3RoID4gMiB8fCAhY29tcHNbMF0ubWF0Y2goL14tP1swLTldKiQvKSB8fCAoY29tcHNbMV0gJiYgIWNvbXBzWzFdLm1hdGNoKC9eWzAtOV0qJC8pKSB8fCB2YWx1ZSA9PT0gXCIuXCIgfHwgdmFsdWUgPT09IFwiLS5cIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYXQgbGVhc3Qgb25lIHdob2xlIGRpZ2l0ICgwIGlmIG5vbmUpXG4gICAgbGV0IHdob2xlID0gY29tcHNbMF07XG4gICAgbGV0IG5lZ2F0aXZlID0gXCJcIjtcbiAgICBpZiAod2hvbGUuc3Vic3RyaW5nKDAsIDEpID09PSBcIi1cIikge1xuICAgICAgICBuZWdhdGl2ZSA9IFwiLVwiO1xuICAgICAgICB3aG9sZSA9IHdob2xlLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYXQgbGVhc3QgMSB3aG9sZSBkaWdpdCB3aXRoIG5vIGxlYWRpbmcgemVyb3NcbiAgICB3aGlsZSAod2hvbGUuc3Vic3RyaW5nKDAsIDEpID09PSBcIjBcIikge1xuICAgICAgICB3aG9sZSA9IHdob2xlLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKHdob2xlID09PSBcIlwiKSB7XG4gICAgICAgIHdob2xlID0gXCIwXCI7XG4gICAgfVxuICAgIGxldCBzdWZmaXggPSBcIlwiO1xuICAgIGlmIChjb21wcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgc3VmZml4ID0gXCIuXCIgKyAoY29tcHNbMV0gfHwgXCIwXCIpO1xuICAgIH1cbiAgICB3aGlsZSAoc3VmZml4Lmxlbmd0aCA+IDIgJiYgc3VmZml4W3N1ZmZpeC5sZW5ndGggLSAxXSA9PT0gXCIwXCIpIHtcbiAgICAgICAgc3VmZml4ID0gc3VmZml4LnN1YnN0cmluZygwLCBzdWZmaXgubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdHRlZCA9IFtdO1xuICAgIHdoaWxlICh3aG9sZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHdob2xlLmxlbmd0aCA8PSAzKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWQudW5zaGlmdCh3aG9sZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gd2hvbGUubGVuZ3RoIC0gMztcbiAgICAgICAgICAgIGZvcm1hdHRlZC51bnNoaWZ0KHdob2xlLnN1YnN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgd2hvbGUgPSB3aG9sZS5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZWdhdGl2ZSArIGZvcm1hdHRlZC5qb2luKFwiLFwiKSArIHN1ZmZpeDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVbml0cyh2YWx1ZSwgdW5pdE5hbWUpIHtcbiAgICBpZiAodHlwZW9mICh1bml0TmFtZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBuYW1lcy5pbmRleE9mKHVuaXROYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdW5pdE5hbWUgPSAzICogaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdEZpeGVkKHZhbHVlLCAodW5pdE5hbWUgIT0gbnVsbCkgPyB1bml0TmFtZSA6IDE4KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVVuaXRzKHZhbHVlLCB1bml0TmFtZSkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgbXVzdCBiZSBhIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodW5pdE5hbWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuaW5kZXhPZih1bml0TmFtZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHVuaXROYW1lID0gMyAqIGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUZpeGVkKHZhbHVlLCAodW5pdE5hbWUgIT0gbnVsbCkgPyB1bml0TmFtZSA6IDE4KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRFdGhlcih3ZWkpIHtcbiAgICByZXR1cm4gZm9ybWF0VW5pdHMod2VpLCAxOCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFdGhlcihldGhlcikge1xuICAgIHJldHVybiBwYXJzZVVuaXRzKGV0aGVyLCAxOCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiZm9ybWF0Rml4ZWQiLCJwYXJzZUZpeGVkIiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsIm5hbWVzIiwiY29tbWlmeSIsInZhbHVlIiwiY29tcHMiLCJTdHJpbmciLCJzcGxpdCIsImxlbmd0aCIsIm1hdGNoIiwidGhyb3dBcmd1bWVudEVycm9yIiwid2hvbGUiLCJuZWdhdGl2ZSIsInN1YnN0cmluZyIsInN1ZmZpeCIsImZvcm1hdHRlZCIsInVuc2hpZnQiLCJpbmRleCIsImpvaW4iLCJmb3JtYXRVbml0cyIsInVuaXROYW1lIiwiaW5kZXhPZiIsInBhcnNlVW5pdHMiLCJmb3JtYXRFdGhlciIsIndlaSIsInBhcnNlRXRoZXIiLCJldGhlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/units/lib.esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/web/lib.esm/_version.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/web/lib.esm/_version.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"web/5.7.1\"; //# sourceMappingURL=_version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvd2ViL2xpYi5lc20vX3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFVBQVUsWUFBWSxDQUNuQyxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LXN0YXJ0ZXIta2l0Ly4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3dlYi9saWIuZXNtL192ZXJzaW9uLmpzPzMzZGMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIndlYi81LjcuMVwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/web/lib.esm/_version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/web/lib.esm/geturl.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ethersproject/web/lib.esm/geturl.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getUrl: () => (/* binding */ getUrl)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nfunction getUrl(href, options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (options == null) {\n            options = {};\n        }\n        const request = {\n            method: options.method || \"GET\",\n            headers: options.headers || {},\n            body: options.body || undefined\n        };\n        if (options.skipFetchSetup !== true) {\n            request.mode = \"cors\"; // no-cors, cors, *same-origin\n            request.cache = \"no-cache\"; // *default, no-cache, reload, force-cache, only-if-cached\n            request.credentials = \"same-origin\"; // include, *same-origin, omit\n            request.redirect = \"follow\"; // manual, *follow, error\n            request.referrer = \"client\"; // no-referrer, *client\n        }\n        ;\n        if (options.fetchOptions != null) {\n            const opts = options.fetchOptions;\n            if (opts.mode) {\n                request.mode = opts.mode;\n            }\n            if (opts.cache) {\n                request.cache = opts.cache;\n            }\n            if (opts.credentials) {\n                request.credentials = opts.credentials;\n            }\n            if (opts.redirect) {\n                request.redirect = opts.redirect;\n            }\n            if (opts.referrer) {\n                request.referrer = opts.referrer;\n            }\n        }\n        const response = yield fetch(href, request);\n        const body = yield response.arrayBuffer();\n        const headers = {};\n        if (response.headers.forEach) {\n            response.headers.forEach((value, key)=>{\n                headers[key.toLowerCase()] = value;\n            });\n        } else {\n            response.headers.keys().forEach((key)=>{\n                headers[key.toLowerCase()] = response.headers.get(key);\n            });\n        }\n        return {\n            headers: headers,\n            statusCode: response.status,\n            statusMessage: response.statusText,\n            body: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(new Uint8Array(body))\n        };\n    });\n} //# sourceMappingURL=geturl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvd2ViL2xpYi5lc20vZ2V0dXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWE7QUFDYixJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDZ0Q7QUFDekMsU0FBU1EsT0FBT0MsSUFBSSxFQUFFQyxPQUFPO0lBQ2hDLE9BQU90QixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ25DLElBQUlzQixXQUFXLE1BQU07WUFDakJBLFVBQVUsQ0FBQztRQUNmO1FBQ0EsTUFBTUMsVUFBVTtZQUNaQyxRQUFTRixRQUFRRSxNQUFNLElBQUk7WUFDM0JDLFNBQVVILFFBQVFHLE9BQU8sSUFBSSxDQUFDO1lBQzlCQyxNQUFPSixRQUFRSSxJQUFJLElBQUlDO1FBQzNCO1FBQ0EsSUFBSUwsUUFBUU0sY0FBYyxLQUFLLE1BQU07WUFDakNMLFFBQVFNLElBQUksR0FBRyxRQUFRLDhCQUE4QjtZQUNyRE4sUUFBUU8sS0FBSyxHQUFHLFlBQVksMERBQTBEO1lBQ3RGUCxRQUFRUSxXQUFXLEdBQUcsZUFBZSw4QkFBOEI7WUFDbkVSLFFBQVFTLFFBQVEsR0FBRyxVQUFVLHlCQUF5QjtZQUN0RFQsUUFBUVUsUUFBUSxHQUFHLFVBQVUsdUJBQXVCO1FBQ3hEOztRQUVBLElBQUlYLFFBQVFZLFlBQVksSUFBSSxNQUFNO1lBQzlCLE1BQU1DLE9BQU9iLFFBQVFZLFlBQVk7WUFDakMsSUFBSUMsS0FBS04sSUFBSSxFQUFFO2dCQUNYTixRQUFRTSxJQUFJLEdBQUlNLEtBQUtOLElBQUk7WUFDN0I7WUFDQSxJQUFJTSxLQUFLTCxLQUFLLEVBQUU7Z0JBQ1pQLFFBQVFPLEtBQUssR0FBSUssS0FBS0wsS0FBSztZQUMvQjtZQUNBLElBQUlLLEtBQUtKLFdBQVcsRUFBRTtnQkFDbEJSLFFBQVFRLFdBQVcsR0FBSUksS0FBS0osV0FBVztZQUMzQztZQUNBLElBQUlJLEtBQUtILFFBQVEsRUFBRTtnQkFDZlQsUUFBUVMsUUFBUSxHQUFJRyxLQUFLSCxRQUFRO1lBQ3JDO1lBQ0EsSUFBSUcsS0FBS0YsUUFBUSxFQUFFO2dCQUNmVixRQUFRVSxRQUFRLEdBQUdFLEtBQUtGLFFBQVE7WUFDcEM7UUFDSjtRQUNBLE1BQU1HLFdBQVcsTUFBTUMsTUFBTWhCLE1BQU1FO1FBQ25DLE1BQU1HLE9BQU8sTUFBTVUsU0FBU0UsV0FBVztRQUN2QyxNQUFNYixVQUFVLENBQUM7UUFDakIsSUFBSVcsU0FBU1gsT0FBTyxDQUFDYyxPQUFPLEVBQUU7WUFDMUJILFNBQVNYLE9BQU8sQ0FBQ2MsT0FBTyxDQUFDLENBQUNqQyxPQUFPa0M7Z0JBQzdCZixPQUFPLENBQUNlLElBQUlDLFdBQVcsR0FBRyxHQUFHbkM7WUFDakM7UUFDSixPQUNLO1lBQ0M4QixTQUFTWCxPQUFPLENBQUVpQixJQUFJLEdBQUlILE9BQU8sQ0FBQyxDQUFDQztnQkFDakNmLE9BQU8sQ0FBQ2UsSUFBSUMsV0FBVyxHQUFHLEdBQUdMLFNBQVNYLE9BQU8sQ0FBQ2tCLEdBQUcsQ0FBQ0g7WUFDdEQ7UUFDSjtRQUNBLE9BQU87WUFDSGYsU0FBU0E7WUFDVG1CLFlBQVlSLFNBQVNTLE1BQU07WUFDM0JDLGVBQWVWLFNBQVNXLFVBQVU7WUFDbENyQixNQUFNUCw4REFBUUEsQ0FBQyxJQUFJNkIsV0FBV3RCO1FBQ2xDO0lBQ0o7QUFDSixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvd2ViL2xpYi5lc20vZ2V0dXJsLmpzP2Y5MGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGFycmF5aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0VXJsKGhyZWYsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogKG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIpLFxuICAgICAgICAgICAgaGVhZGVyczogKG9wdGlvbnMuaGVhZGVycyB8fCB7fSksXG4gICAgICAgICAgICBib2R5OiAob3B0aW9ucy5ib2R5IHx8IHVuZGVmaW5lZCksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLnNraXBGZXRjaFNldHVwICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXF1ZXN0Lm1vZGUgPSBcImNvcnNcIjsgLy8gbm8tY29ycywgY29ycywgKnNhbWUtb3JpZ2luXG4gICAgICAgICAgICByZXF1ZXN0LmNhY2hlID0gXCJuby1jYWNoZVwiOyAvLyAqZGVmYXVsdCwgbm8tY2FjaGUsIHJlbG9hZCwgZm9yY2UtY2FjaGUsIG9ubHktaWYtY2FjaGVkXG4gICAgICAgICAgICByZXF1ZXN0LmNyZWRlbnRpYWxzID0gXCJzYW1lLW9yaWdpblwiOyAvLyBpbmNsdWRlLCAqc2FtZS1vcmlnaW4sIG9taXRcbiAgICAgICAgICAgIHJlcXVlc3QucmVkaXJlY3QgPSBcImZvbGxvd1wiOyAvLyBtYW51YWwsICpmb2xsb3csIGVycm9yXG4gICAgICAgICAgICByZXF1ZXN0LnJlZmVycmVyID0gXCJjbGllbnRcIjsgLy8gbm8tcmVmZXJyZXIsICpjbGllbnRcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGlmIChvcHRpb25zLmZldGNoT3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0gb3B0aW9ucy5mZXRjaE9wdGlvbnM7XG4gICAgICAgICAgICBpZiAob3B0cy5tb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5tb2RlID0gKG9wdHMubW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5jYWNoZSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FjaGUgPSAob3B0cy5jYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuY3JlZGVudGlhbHMgPSAob3B0cy5jcmVkZW50aWFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5yZWRpcmVjdCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVkaXJlY3QgPSAob3B0cy5yZWRpcmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5yZWZlcnJlcikge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVmZXJyZXIgPSBvcHRzLnJlZmVycmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2goaHJlZiwgcmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB5aWVsZCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzLmZvckVhY2gpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICgocmVzcG9uc2UuaGVhZGVycykua2V5cykoKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2U6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICBib2R5OiBhcnJheWlmeShuZXcgVWludDhBcnJheShib2R5KSksXG4gICAgICAgIH07XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXR1cmwuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsImFycmF5aWZ5IiwiZ2V0VXJsIiwiaHJlZiIsIm9wdGlvbnMiLCJyZXF1ZXN0IiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJ1bmRlZmluZWQiLCJza2lwRmV0Y2hTZXR1cCIsIm1vZGUiLCJjYWNoZSIsImNyZWRlbnRpYWxzIiwicmVkaXJlY3QiLCJyZWZlcnJlciIsImZldGNoT3B0aW9ucyIsIm9wdHMiLCJyZXNwb25zZSIsImZldGNoIiwiYXJyYXlCdWZmZXIiLCJmb3JFYWNoIiwia2V5IiwidG9Mb3dlckNhc2UiLCJrZXlzIiwiZ2V0Iiwic3RhdHVzQ29kZSIsInN0YXR1cyIsInN0YXR1c01lc3NhZ2UiLCJzdGF0dXNUZXh0IiwiVWludDhBcnJheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/web/lib.esm/geturl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ethersproject/web/lib.esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ethersproject/web/lib.esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _fetchData: () => (/* binding */ _fetchData),\n/* harmony export */   fetchJson: () => (/* binding */ fetchJson),\n/* harmony export */   poll: () => (/* binding */ poll)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_base64__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/base64 */ \"(ssr)/./node_modules/@ethersproject/base64/lib.esm/base64.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ \"(ssr)/./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/properties */ \"(ssr)/./node_modules/@ethersproject/properties/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/strings */ \"(ssr)/./node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ \"(ssr)/./node_modules/@ethersproject/logger/lib.esm/index.js\");\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ \"(ssr)/./node_modules/@ethersproject/web/lib.esm/_version.js\");\n/* harmony import */ var _geturl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geturl */ \"(ssr)/./node_modules/@ethersproject/web/lib.esm/geturl.js\");\n\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nconst logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);\n\nfunction staller(duration) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, duration);\n    });\n}\nfunction bodyify(value, type) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof value === \"string\") {\n        return value;\n    }\n    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isBytesLike)(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(value);\n            } catch (error) {}\n            ;\n        }\n        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(value);\n    }\n    return value;\n}\nfunction unpercent(value) {\n    return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code)=>{\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nfunction _fetchData(connection, body, processFunc) {\n    // How many times to retry in the event of a throttle\n    const attemptLimit = typeof connection === \"object\" && connection.throttleLimit != null ? connection.throttleLimit : 12;\n    logger.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n    const throttleCallback = typeof connection === \"object\" ? connection.throttleCallback : null;\n    const throttleSlotInterval = typeof connection === \"object\" && typeof connection.throttleSlotInterval === \"number\" ? connection.throttleSlotInterval : 100;\n    logger.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n    const errorPassThrough = typeof connection === \"object\" ? !!connection.errorPassThrough : false;\n    const headers = {};\n    let url = null;\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options = {\n        method: \"GET\"\n    };\n    let allow304 = false;\n    let timeout = 2 * 60 * 1000;\n    if (typeof connection === \"string\") {\n        url = connection;\n    } else if (typeof connection === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n        url = connection.url;\n        if (typeof connection.timeout === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n        if (connection.headers) {\n            for(const key in connection.headers){\n                headers[key.toLowerCase()] = {\n                    key: key,\n                    value: String(connection.headers[key])\n                };\n                if ([\n                    \"if-none-match\",\n                    \"if-modified-since\"\n                ].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n        options.allowGzip = !!connection.allowGzip;\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\"basic authentication requires a secure https url\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"url\",\n                    url: url,\n                    user: connection.user,\n                    password: \"[REDACTED]\"\n                });\n            }\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + (0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_4__.encode)((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(authorization))\n            };\n        }\n        if (connection.skipFetchSetup != null) {\n            options.skipFetchSetup = !!connection.skipFetchSetup;\n        }\n        if (connection.fetchOptions != null) {\n            options.fetchOptions = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.shallowCopy)(connection.fetchOptions);\n        }\n    }\n    const reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\n    const dataMatch = url ? url.match(reData) : null;\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: {\n                    \"content-type\": dataMatch[1] || \"text/plain\"\n                },\n                body: dataMatch[2] ? (0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_4__.decode)(dataMatch[3]) : unpercent(dataMatch[3])\n            };\n            let result = response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(result);\n        } catch (error) {\n            logger.throwError(\"processing response error\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = {\n                key: \"Content-Type\",\n                value: \"application/octet-stream\"\n            };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = {\n                key: \"Content-Length\",\n                value: String(body.length)\n            };\n        }\n    }\n    const flatHeaders = {};\n    Object.keys(headers).forEach((key)=>{\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n    const runningTimeout = function() {\n        let timer = null;\n        const promise = new Promise(function(resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(()=>{\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    reject(logger.makeError(\"timeout\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n        const cancel = function() {\n            if (timer == null) {\n                return;\n            }\n            clearTimeout(timer);\n            timer = null;\n        };\n        return {\n            promise,\n            cancel\n        };\n    }();\n    const runningFetch = function() {\n        return __awaiter(this, void 0, void 0, function*() {\n            for(let attempt = 0; attempt < attemptLimit; attempt++){\n                let response = null;\n                try {\n                    response = yield (0,_geturl__WEBPACK_IMPORTED_MODULE_6__.getUrl)(url, options);\n                    if (attempt < attemptLimit) {\n                        if (response.statusCode === 301 || response.statusCode === 302) {\n                            // Redirection; for now we only support absolute locataions\n                            const location = response.headers.location || \"\";\n                            if (options.method === \"GET\" && location.match(/^https:/)) {\n                                url = response.headers.location;\n                                continue;\n                            }\n                        } else if (response.statusCode === 429) {\n                            // Exponential back-off throttling\n                            let tryAgain = true;\n                            if (throttleCallback) {\n                                tryAgain = yield throttleCallback(attempt, url);\n                            }\n                            if (tryAgain) {\n                                let stall = 0;\n                                const retryAfter = response.headers[\"retry-after\"];\n                                if (typeof retryAfter === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                    stall = parseInt(retryAfter) * 1000;\n                                } else {\n                                    stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                                }\n                                //console.log(\"Stalling 429\");\n                                yield staller(stall);\n                                continue;\n                            }\n                        }\n                    }\n                } catch (error) {\n                    response = error.response;\n                    if (response == null) {\n                        runningTimeout.cancel();\n                        logger.throwError(\"missing response\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                            requestMethod: options.method,\n                            serverError: error,\n                            url: url\n                        });\n                    }\n                }\n                let body = response.body;\n                if (allow304 && response.statusCode === 304) {\n                    body = null;\n                } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {\n                    runningTimeout.cancel();\n                    logger.throwError(\"bad response\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                        status: response.statusCode,\n                        headers: response.headers,\n                        body: bodyify(body, response.headers ? response.headers[\"content-type\"] : null),\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n                if (processFunc) {\n                    try {\n                        const result = yield processFunc(body, response);\n                        runningTimeout.cancel();\n                        return result;\n                    } catch (error) {\n                        // Allow the processFunc to trigger a throttle\n                        if (error.throttleRetry && attempt < attemptLimit) {\n                            let tryAgain = true;\n                            if (throttleCallback) {\n                                tryAgain = yield throttleCallback(attempt, url);\n                            }\n                            if (tryAgain) {\n                                const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                                //console.log(\"Stalling callback\");\n                                yield staller(timeout);\n                                continue;\n                            }\n                        }\n                        runningTimeout.cancel();\n                        logger.throwError(\"processing response error\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                            body: bodyify(body, response.headers ? response.headers[\"content-type\"] : null),\n                            error: error,\n                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                            requestMethod: options.method,\n                            url: url\n                        });\n                    }\n                }\n                runningTimeout.cancel();\n                // If we had a processFunc, it either returned a T or threw above.\n                // The \"body\" is now a Uint8Array.\n                return body;\n            }\n            return logger.throwError(\"failed response\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                requestMethod: options.method,\n                url: url\n            });\n        });\n    }();\n    return Promise.race([\n        runningTimeout.promise,\n        runningFetch\n    ]);\n}\nfunction fetchJson(connection, json, processFunc) {\n    let processJsonFunc = (value, response)=>{\n        let result = null;\n        if (value != null) {\n            try {\n                result = JSON.parse((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(value));\n            } catch (error) {\n                logger.throwError(\"invalid JSON\", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n        return result;\n    };\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body = null;\n    if (json != null) {\n        body = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(json);\n        // Create a connection with the content-type set for JSON\n        const updated = typeof connection === \"string\" ? {\n            url: connection\n        } : (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.shallowCopy)(connection);\n        if (updated.headers) {\n            const hasContentType = Object.keys(updated.headers).filter((k)=>k.toLowerCase() === \"content-type\").length !== 0;\n            if (!hasContentType) {\n                updated.headers = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.shallowCopy)(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        } else {\n            updated.headers = {\n                \"content-type\": \"application/json\"\n            };\n        }\n        connection = updated;\n    }\n    return _fetchData(connection, body, processJsonFunc);\n}\nfunction poll(func, options) {\n    if (!options) {\n        options = {};\n    }\n    options = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.shallowCopy)(options);\n    if (options.floor == null) {\n        options.floor = 0;\n    }\n    if (options.ceiling == null) {\n        options.ceiling = 10000;\n    }\n    if (options.interval == null) {\n        options.interval = 250;\n    }\n    return new Promise(function(resolve, reject) {\n        let timer = null;\n        let done = false;\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = ()=>{\n            if (done) {\n                return false;\n            }\n            done = true;\n            if (timer) {\n                clearTimeout(timer);\n            }\n            return true;\n        };\n        if (options.timeout) {\n            timer = setTimeout(()=>{\n                if (cancel()) {\n                    reject(new Error(\"timeout\"));\n                }\n            }, options.timeout);\n        }\n        const retryLimit = options.retryLimit;\n        let attempt = 0;\n        function check() {\n            return func().then(function(result) {\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) {\n                        resolve(result);\n                    }\n                } else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n                } else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n                // Otherwise, exponential back-off (up to 10s) our next request\n                } else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) {\n                            reject(new Error(\"retry limit reached\"));\n                        }\n                        return;\n                    }\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) {\n                        timeout = options.floor;\n                    }\n                    if (timeout > options.ceiling) {\n                        timeout = options.ceiling;\n                    }\n                    setTimeout(check, timeout);\n                }\n                return null;\n            }, function(error) {\n                if (cancel()) {\n                    reject(error);\n                }\n            });\n        }\n        check();\n    });\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvd2ViL2xpYi5lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFhO0FBQ2IsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQ3VGO0FBQzNCO0FBQ0o7QUFDVztBQUNwQjtBQUNWO0FBQ3JDLE1BQU1rQixTQUFTLElBQUlGLHlEQUFNQSxDQUFDQyw2Q0FBT0E7QUFDQztBQUNsQyxTQUFTRyxRQUFRQyxRQUFRO0lBQ3JCLE9B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aEUsVUFBVUgsUUFBUW9FLE9BQU8sRUFBRTt3QkFDM0JqRSxVQUFVSCxRQUFRb0UsT0FBTztvQkFDN0I7b0JBQ0E3RixXQUFXaUcsT0FBT3JFO2dCQUN0QjtnQkFDQSxPQUFPO1lBQ1gsR0FBRyxTQUFVdkIsS0FBSztnQkFDZCxJQUFJNkQsVUFBVTtvQkFDVjNGLE9BQU84QjtnQkFDWDtZQUNKO1FBQ0o7UUFDQTRGO0lBQ0o7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtc3RhcnRlci1raXQvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvd2ViL2xpYi5lc20vaW5kZXguanM/ODEzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgZGVjb2RlIGFzIGJhc2U2NERlY29kZSwgZW5jb2RlIGFzIGJhc2U2NEVuY29kZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iYXNlNjRcIjtcbmltcG9ydCB7IGhleGxpZnksIGlzQnl0ZXNMaWtlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBzaGFsbG93Q29weSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IGdldFVybCB9IGZyb20gXCIuL2dldHVybFwiO1xuZnVuY3Rpb24gc3RhbGxlcihkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJvZHlpZnkodmFsdWUsIHR5cGUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzQnl0ZXNMaWtlKHZhbHVlKSkge1xuICAgICAgICBpZiAodHlwZSAmJiAodHlwZS5zcGxpdChcIi9cIilbMF0gPT09IFwidGV4dFwiIHx8IHR5cGUuc3BsaXQoXCI7XCIpWzBdLnRyaW0oKSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHVucGVyY2VudCh2YWx1ZSkge1xuICAgIHJldHVybiB0b1V0ZjhCeXRlcyh2YWx1ZS5yZXBsYWNlKC8lKFswLTlhLWZdWzAtOWEtZl0pL2dpLCAoYWxsLCBjb2RlKSA9PiB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGNvZGUsIDE2KSk7XG4gICAgfSkpO1xufVxuLy8gVGhpcyBBUEkgaXMgc3RpbGwgYSB3b3JrIGluIHByb2dyZXNzOyB0aGUgZnV0dXJlIGNoYW5nZXMgd2lsbCBsaWtlbHkgYmU6XG4vLyAtIENvbm5lY3Rpb25JbmZvID0+IEZldGNoRGF0YVJlcXVlc3Q8VCA9IGFueT5cbi8vIC0gRmV0Y2hEYXRhUmVxdWVzdC5ib2R5PyA9IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCB7IGNvbnRlbnRUeXBlOiBzdHJpbmcsIGRhdGE6IHN0cmluZyB8IFVpbnQ4QXJyYXkgfVxuLy8gICAtIElmIHN0cmluZyA9PiB0ZXh0L3BsYWluLCBVaW50OEFycmF5ID0+IGFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSAoaWYgY29udGVudC10eXBlIHVuc3BlY2lmaWVkKVxuLy8gLSBGZXRjaERhdGFSZXF1ZXN0LnByb2Nlc3NGdW5jID0gKGJvZHk6IFVpbnQ4QXJyYXksIHJlc3BvbnNlOiBGZXRjaERhdGFSZXNwb25zZSkgPT4gVFxuLy8gRm9yIHRoaXMgcmVhc29uLCBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCBpbnRlcm5hbCB1bnRpbCB0aGUgQVBJIGlzIGZpbmFsaXplZFxuZXhwb3J0IGZ1bmN0aW9uIF9mZXRjaERhdGEoY29ubmVjdGlvbiwgYm9keSwgcHJvY2Vzc0Z1bmMpIHtcbiAgICAvLyBIb3cgbWFueSB0aW1lcyB0byByZXRyeSBpbiB0aGUgZXZlbnQgb2YgYSB0aHJvdHRsZVxuICAgIGNvbnN0IGF0dGVtcHRMaW1pdCA9ICh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcIm9iamVjdFwiICYmIGNvbm5lY3Rpb24udGhyb3R0bGVMaW1pdCAhPSBudWxsKSA/IGNvbm5lY3Rpb24udGhyb3R0bGVMaW1pdCA6IDEyO1xuICAgIGxvZ2dlci5hc3NlcnRBcmd1bWVudCgoYXR0ZW1wdExpbWl0ID4gMCAmJiAoYXR0ZW1wdExpbWl0ICUgMSkgPT09IDApLCBcImludmFsaWQgY29ubmVjdGlvbiB0aHJvdHRsZSBsaW1pdFwiLCBcImNvbm5lY3Rpb24udGhyb3R0bGVMaW1pdFwiLCBhdHRlbXB0TGltaXQpO1xuICAgIGNvbnN0IHRocm90dGxlQ2FsbGJhY2sgPSAoKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwib2JqZWN0XCIpID8gY29ubmVjdGlvbi50aHJvdHRsZUNhbGxiYWNrIDogbnVsbCk7XG4gICAgY29uc3QgdGhyb3R0bGVTbG90SW50ZXJ2YWwgPSAoKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIChjb25uZWN0aW9uLnRocm90dGxlU2xvdEludGVydmFsKSA9PT0gXCJudW1iZXJcIikgPyBjb25uZWN0aW9uLnRocm90dGxlU2xvdEludGVydmFsIDogMTAwKTtcbiAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKHRocm90dGxlU2xvdEludGVydmFsID4gMCAmJiAodGhyb3R0bGVTbG90SW50ZXJ2YWwgJSAxKSA9PT0gMCksIFwiaW52YWxpZCBjb25uZWN0aW9uIHRocm90dGxlIHNsb3QgaW50ZXJ2YWxcIiwgXCJjb25uZWN0aW9uLnRocm90dGxlU2xvdEludGVydmFsXCIsIHRocm90dGxlU2xvdEludGVydmFsKTtcbiAgICBjb25zdCBlcnJvclBhc3NUaHJvdWdoID0gKCh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcIm9iamVjdFwiKSA/ICEhKGNvbm5lY3Rpb24uZXJyb3JQYXNzVGhyb3VnaCkgOiBmYWxzZSk7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGxldCB1cmwgPSBudWxsO1xuICAgIC8vIEBUT0RPOiBBbGxvdyBDb25uZWN0aW9uSW5mbyB0byBvdmVycmlkZSBzb21lIG9mIHRoZXNlIHZhbHVlc1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICB9O1xuICAgIGxldCBhbGxvdzMwNCA9IGZhbHNlO1xuICAgIGxldCB0aW1lb3V0ID0gMiAqIDYwICogMTAwMDtcbiAgICBpZiAodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmwgPSBjb25uZWN0aW9uO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChjb25uZWN0aW9uID09IG51bGwgfHwgY29ubmVjdGlvbi51cmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgVVJMXCIsIFwiY29ubmVjdGlvbi51cmxcIiwgY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gY29ubmVjdGlvbi51cmw7XG4gICAgICAgIGlmICh0eXBlb2YgKGNvbm5lY3Rpb24udGltZW91dCkgPT09IFwibnVtYmVyXCIgJiYgY29ubmVjdGlvbi50aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgdGltZW91dCA9IGNvbm5lY3Rpb24udGltZW91dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdGlvbi5oZWFkZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb25uZWN0aW9uLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHsga2V5OiBrZXksIHZhbHVlOiBTdHJpbmcoY29ubmVjdGlvbi5oZWFkZXJzW2tleV0pIH07XG4gICAgICAgICAgICAgICAgaWYgKFtcImlmLW5vbmUtbWF0Y2hcIiwgXCJpZi1tb2RpZmllZC1zaW5jZVwiXS5pbmRleE9mKGtleS50b0xvd2VyQ2FzZSgpKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93MzA0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5hbGxvd0d6aXAgPSAhIWNvbm5lY3Rpb24uYWxsb3dHemlwO1xuICAgICAgICBpZiAoY29ubmVjdGlvbi51c2VyICE9IG51bGwgJiYgY29ubmVjdGlvbi5wYXNzd29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodXJsLnN1YnN0cmluZygwLCA2KSAhPT0gXCJodHRwczpcIiAmJiBjb25uZWN0aW9uLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbiAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFzaWMgYXV0aGVudGljYXRpb24gcmVxdWlyZXMgYSBzZWN1cmUgaHR0cHMgdXJsXCIsIExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwgeyBhcmd1bWVudDogXCJ1cmxcIiwgdXJsOiB1cmwsIHVzZXI6IGNvbm5lY3Rpb24udXNlciwgcGFzc3dvcmQ6IFwiW1JFREFDVEVEXVwiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvbiA9IGNvbm5lY3Rpb24udXNlciArIFwiOlwiICsgY29ubmVjdGlvbi5wYXNzd29yZDtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdID0ge1xuICAgICAgICAgICAgICAgIGtleTogXCJBdXRob3JpemF0aW9uXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiQmFzaWMgXCIgKyBiYXNlNjRFbmNvZGUodG9VdGY4Qnl0ZXMoYXV0aG9yaXphdGlvbikpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0aW9uLnNraXBGZXRjaFNldHVwICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2tpcEZldGNoU2V0dXAgPSAhIWNvbm5lY3Rpb24uc2tpcEZldGNoU2V0dXA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3Rpb24uZmV0Y2hPcHRpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZmV0Y2hPcHRpb25zID0gc2hhbGxvd0NvcHkoY29ubmVjdGlvbi5mZXRjaE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlRGF0YSA9IG5ldyBSZWdFeHAoXCJeZGF0YTooW147Ol0qKT8oO2Jhc2U2NCk/LCguKikkXCIsIFwiaVwiKTtcbiAgICBjb25zdCBkYXRhTWF0Y2ggPSAoKHVybCkgPyB1cmwubWF0Y2gocmVEYXRhKSA6IG51bGwpO1xuICAgIGlmIChkYXRhTWF0Y2gpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgICAgICAgICBzdGF0dXNNZXNzYWdlOiBcIk9LXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyBcImNvbnRlbnQtdHlwZVwiOiAoZGF0YU1hdGNoWzFdIHx8IFwidGV4dC9wbGFpblwiKSB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IChkYXRhTWF0Y2hbMl0gPyBiYXNlNjREZWNvZGUoZGF0YU1hdGNoWzNdKSA6IHVucGVyY2VudChkYXRhTWF0Y2hbM10pKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSByZXNwb25zZS5ib2R5O1xuICAgICAgICAgICAgaWYgKHByb2Nlc3NGdW5jKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJvY2Vzc0Z1bmMocmVzcG9uc2UuYm9keSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJwcm9jZXNzaW5nIHJlc3BvbnNlIGVycm9yXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keWlmeShkYXRhTWF0Y2hbMV0sIGRhdGFNYXRjaFsyXSksXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiBudWxsLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChib2R5KSB7XG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gXCJQT1NUXCI7XG4gICAgICAgIG9wdGlvbnMuYm9keSA9IGJvZHk7XG4gICAgICAgIGlmIChoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID09IG51bGwpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSB7IGtleTogXCJDb250ZW50LVR5cGVcIiwgdmFsdWU6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVyc1tcImNvbnRlbnQtbGVuZ3RoXCJdID09IG51bGwpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXSA9IHsga2V5OiBcIkNvbnRlbnQtTGVuZ3RoXCIsIHZhbHVlOiBTdHJpbmcoYm9keS5sZW5ndGgpIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmxhdEhlYWRlcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhoZWFkZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gaGVhZGVyc1trZXldO1xuICAgICAgICBmbGF0SGVhZGVyc1toZWFkZXIua2V5XSA9IGhlYWRlci52YWx1ZTtcbiAgICB9KTtcbiAgICBvcHRpb25zLmhlYWRlcnMgPSBmbGF0SGVhZGVycztcbiAgICBjb25zdCBydW5uaW5nVGltZW91dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobG9nZ2VyLm1ha2VFcnJvcihcInRpbWVvdXRcIiwgTG9nZ2VyLmVycm9ycy5USU1FT1VULCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keTogYm9keWlmeShvcHRpb25zLmJvZHksIGZsYXRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogdGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aW1lciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgcHJvbWlzZSwgY2FuY2VsIH07XG4gICAgfSkoKTtcbiAgICBjb25zdCBydW5uaW5nRmV0Y2ggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBhdHRlbXB0TGltaXQ7IGF0dGVtcHQrKykge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB5aWVsZCBnZXRVcmwodXJsLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPCBhdHRlbXB0TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDEgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVkaXJlY3Rpb247IGZvciBub3cgd2Ugb25seSBzdXBwb3J0IGFic29sdXRlIGxvY2F0YWlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb24gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRob2QgPT09IFwiR0VUXCIgJiYgbG9jYXRpb24ubWF0Y2goL15odHRwczovKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MjkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBvbmVudGlhbCBiYWNrLW9mZiB0aHJvdHRsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyeUFnYWluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhyb3R0bGVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlBZ2FpbiA9IHlpZWxkIHRocm90dGxlQ2FsbGJhY2soYXR0ZW1wdCwgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUFnYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFsbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSByZXNwb25zZS5oZWFkZXJzW1wicmV0cnktYWZ0ZXJcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHJldHJ5QWZ0ZXIpID09PSBcInN0cmluZ1wiICYmIHJldHJ5QWZ0ZXIubWF0Y2goL15bMS05XVswLTldKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhbGwgPSBwYXJzZUludChyZXRyeUFmdGVyKSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFsbCA9IHRocm90dGxlU2xvdEludGVydmFsICogcGFyc2VJbnQoU3RyaW5nKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTdGFsbGluZyA0MjlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHN0YWxsZXIoc3RhbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZXJyb3IucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibWlzc2luZyByZXNwb25zZVwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiBib2R5aWZ5KG9wdGlvbnMuYm9keSwgZmxhdEhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJvZHkgPSByZXNwb25zZS5ib2R5O1xuICAgICAgICAgICAgICAgIGlmIChhbGxvdzMwNCAmJiByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDQpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFlcnJvclBhc3NUaHJvdWdoICYmIChyZXNwb25zZS5zdGF0dXNDb2RlIDwgMjAwIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gMzAwKSkge1xuICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzcG9uc2VcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5aWZ5KGJvZHksICgocmVzcG9uc2UuaGVhZGVycykgPyByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIDogbnVsbCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHByb2Nlc3NGdW5jKGJvZHksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSBwcm9jZXNzRnVuYyB0byB0cmlnZ2VyIGEgdGhyb3R0bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci50aHJvdHRsZVJldHJ5ICYmIGF0dGVtcHQgPCBhdHRlbXB0TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHJ5QWdhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aHJvdHRsZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUFnYWluID0geWllbGQgdGhyb3R0bGVDYWxsYmFjayhhdHRlbXB0LCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJ5QWdhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHRocm90dGxlU2xvdEludGVydmFsICogcGFyc2VJbnQoU3RyaW5nKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU3RhbGxpbmcgY2FsbGJhY2tcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHN0YWxsZXIodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJwcm9jZXNzaW5nIHJlc3BvbnNlIGVycm9yXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keWlmeShib2R5LCAoKHJlc3BvbnNlLmhlYWRlcnMpID8gcmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA6IG51bGwpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhZCBhIHByb2Nlc3NGdW5jLCBpdCBlaXRoZXIgcmV0dXJuZWQgYSBUIG9yIHRocmV3IGFib3ZlLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBcImJvZHlcIiBpcyBub3cgYSBVaW50OEFycmF5LlxuICAgICAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiZmFpbGVkIHJlc3BvbnNlXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW3J1bm5pbmdUaW1lb3V0LnByb21pc2UsIHJ1bm5pbmdGZXRjaF0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoSnNvbihjb25uZWN0aW9uLCBqc29uLCBwcm9jZXNzRnVuYykge1xuICAgIGxldCBwcm9jZXNzSnNvbkZ1bmMgPSAodmFsdWUsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHRvVXRmOFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJpbnZhbGlkIEpTT05cIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzRnVuYykge1xuICAgICAgICAgICAgcmVzdWx0ID0gcHJvY2Vzc0Z1bmMocmVzdWx0LCByZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8vIElmIHdlIGhhdmUganNvbiB0byBzZW5kLCB3ZSBtdXN0XG4gICAgLy8gLSBhZGQgY29udGVudC10eXBlIG9mIGFwcGxpY2F0aW9uL2pzb24gKHVubGVzcyBhbHJlYWR5IG92ZXJyaWRkZW4pXG4gICAgLy8gLSBjb252ZXJ0IHRoZSBqc29uIHRvIGJ5dGVzXG4gICAgbGV0IGJvZHkgPSBudWxsO1xuICAgIGlmIChqc29uICE9IG51bGwpIHtcbiAgICAgICAgYm9keSA9IHRvVXRmOEJ5dGVzKGpzb24pO1xuICAgICAgICAvLyBDcmVhdGUgYSBjb25uZWN0aW9uIHdpdGggdGhlIGNvbnRlbnQtdHlwZSBzZXQgZm9yIEpTT05cbiAgICAgICAgY29uc3QgdXBkYXRlZCA9ICh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcInN0cmluZ1wiKSA/ICh7IHVybDogY29ubmVjdGlvbiB9KSA6IHNoYWxsb3dDb3B5KGNvbm5lY3Rpb24pO1xuICAgICAgICBpZiAodXBkYXRlZC5oZWFkZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNDb250ZW50VHlwZSA9IChPYmplY3Qua2V5cyh1cGRhdGVkLmhlYWRlcnMpLmZpbHRlcigoaykgPT4gKGsudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIikpLmxlbmd0aCkgIT09IDA7XG4gICAgICAgICAgICBpZiAoIWhhc0NvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZC5oZWFkZXJzID0gc2hhbGxvd0NvcHkodXBkYXRlZC5oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVkLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZWQuaGVhZGVycyA9IHsgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0aW9uID0gdXBkYXRlZDtcbiAgICB9XG4gICAgcmV0dXJuIF9mZXRjaERhdGEoY29ubmVjdGlvbiwgYm9keSwgcHJvY2Vzc0pzb25GdW5jKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb2xsKGZ1bmMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBvcHRpb25zID0gc2hhbGxvd0NvcHkob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuZmxvb3IgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLmZsb29yID0gMDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2VpbGluZyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMuY2VpbGluZyA9IDEwMDAwO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbnRlcnZhbCA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMuaW50ZXJ2YWwgPSAyNTA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBjYW5jZWwgd2FzIHN1Y2Nlc3NmdWwuIFVuc3VjY2Vzc2Z1bCBjYW5jZWwgbWVhbnMgd2UncmUgYWxyZWFkeSBkb25lLlxuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwidGltZW91dFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXRyeUxpbWl0ID0gb3B0aW9ucy5yZXRyeUxpbWl0O1xuICAgICAgICBsZXQgYXR0ZW1wdCA9IDA7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcmVzdWx0LCBvciBhcmUgYWxsb3dlZCBudWxsIHRoZW4gd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuY2VsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uY2VQb2xsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25jZVBvbGwub25jZShcInBvbGxcIiwgY2hlY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uY2VCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uY2VCbG9jay5vbmNlKFwiYmxvY2tcIiwgY2hlY2spO1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGV4cG9uZW50aWFsIGJhY2stb2ZmICh1cCB0byAxMHMpIG91ciBuZXh0IHJlcXVlc3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA+IHJldHJ5TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJyZXRyeSBsaW1pdCByZWFjaGVkXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgdGltZW91dCA9IG9wdGlvbnMuaW50ZXJ2YWwgKiBwYXJzZUludChTdHJpbmcoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0IDwgb3B0aW9ucy5mbG9vcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG9wdGlvbnMuZmxvb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiBvcHRpb25zLmNlaWxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBvcHRpb25zLmNlaWxpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjaGVjaywgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2soKTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJkZWNvZGUiLCJiYXNlNjREZWNvZGUiLCJlbmNvZGUiLCJiYXNlNjRFbmNvZGUiLCJoZXhsaWZ5IiwiaXNCeXRlc0xpa2UiLCJzaGFsbG93Q29weSIsInRvVXRmOEJ5dGVzIiwidG9VdGY4U3RyaW5nIiwiTG9nZ2VyIiwidmVyc2lvbiIsImxvZ2dlciIsImdldFVybCIsInN0YWxsZXIiLCJkdXJhdGlvbiIsInNldFRpbWVvdXQiLCJib2R5aWZ5IiwidHlwZSIsInNwbGl0IiwidHJpbSIsImVycm9yIiwidW5wZXJjZW50IiwicmVwbGFjZSIsImFsbCIsImNvZGUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJwYXJzZUludCIsIl9mZXRjaERhdGEiLCJjb25uZWN0aW9uIiwiYm9keSIsInByb2Nlc3NGdW5jIiwiYXR0ZW1wdExpbWl0IiwidGhyb3R0bGVMaW1pdCIsImFzc2VydEFyZ3VtZW50IiwidGhyb3R0bGVDYWxsYmFjayIsInRocm90dGxlU2xvdEludGVydmFsIiwiZXJyb3JQYXNzVGhyb3VnaCIsImhlYWRlcnMiLCJ1cmwiLCJvcHRpb25zIiwibWV0aG9kIiwiYWxsb3czMDQiLCJ0aW1lb3V0IiwidGhyb3dBcmd1bWVudEVycm9yIiwia2V5IiwidG9Mb3dlckNhc2UiLCJpbmRleE9mIiwiYWxsb3dHemlwIiwidXNlciIsInBhc3N3b3JkIiwic3Vic3RyaW5nIiwiYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uIiwidGhyb3dFcnJvciIsImVycm9ycyIsIklOVkFMSURfQVJHVU1FTlQiLCJhcmd1bWVudCIsImF1dGhvcml6YXRpb24iLCJza2lwRmV0Y2hTZXR1cCIsImZldGNoT3B0aW9ucyIsInJlRGF0YSIsIlJlZ0V4cCIsImRhdGFNYXRjaCIsIm1hdGNoIiwicmVzcG9uc2UiLCJzdGF0dXNDb2RlIiwic3RhdHVzTWVzc2FnZSIsIlNFUlZFUl9FUlJPUiIsInJlcXVlc3RCb2R5IiwicmVxdWVzdE1ldGhvZCIsImxlbmd0aCIsImZsYXRIZWFkZXJzIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJoZWFkZXIiLCJydW5uaW5nVGltZW91dCIsInRpbWVyIiwicHJvbWlzZSIsIm1ha2VFcnJvciIsIlRJTUVPVVQiLCJjYW5jZWwiLCJjbGVhclRpbWVvdXQiLCJydW5uaW5nRmV0Y2giLCJhdHRlbXB0IiwibG9jYXRpb24iLCJ0cnlBZ2FpbiIsInN0YWxsIiwicmV0cnlBZnRlciIsIk1hdGgiLCJyYW5kb20iLCJwb3ciLCJzZXJ2ZXJFcnJvciIsInN0YXR1cyIsInRocm90dGxlUmV0cnkiLCJyYWNlIiwiZmV0Y2hKc29uIiwianNvbiIsInByb2Nlc3NKc29uRnVuYyIsIkpTT04iLCJwYXJzZSIsInVwZGF0ZWQiLCJoYXNDb250ZW50VHlwZSIsImZpbHRlciIsImsiLCJwb2xsIiwiZnVuYyIsImZsb29yIiwiY2VpbGluZyIsImludGVydmFsIiwiRXJyb3IiLCJyZXRyeUxpbWl0IiwiY2hlY2siLCJ1bmRlZmluZWQiLCJvbmNlUG9sbCIsIm9uY2UiLCJvbmNlQmxvY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ethersproject/web/lib.esm/index.js\n");

/***/ })

};
;